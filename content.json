{"meta":{"title":"h^ovny's blog","subtitle":"Forever","description":"devil.","author":"h^ovny","url":"http://hovnySiLenCe.github.io"},"pages":[{"title":"categories","date":"2019-03-24T10:48:26.000Z","updated":"2020-01-29T03:29:45.099Z","comments":false,"path":"categories/index.html","permalink":"http://hovnySiLenCe.github.io/categories/index.html","excerpt":"","text":"咕 $ing$","keywords":"分类"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-11-10T23:50:05.810Z","comments":false,"path":"about/index.html","permalink":"http://hovnySiLenCe.github.io/about/index.html","excerpt":"","text":"h^ovny 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"client/index.html","permalink":"http://hovnySiLenCe.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-11-12T09:44:59.545Z","comments":false,"path":"bangumi/index.html","permalink":"http://hovnySiLenCe.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"comment/index.html","permalink":"http://hovnySiLenCe.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"Links","date":"2019-11-12T13:26:29.000Z","updated":"2019-11-12T13:26:41.725Z","comments":true,"path":"links/index.html","permalink":"http://hovnySiLenCe.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"Lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-01-29T02:55:54.638Z","comments":false,"path":"lab/index.html","permalink":"http://hovnySiLenCe.github.io/lab/index.html","excerpt":"","text":"everything here is just for test. ab\\\\ab$AtCoder$ 居然要在输出最后换行…… 目前发现的 $bug$ 就是插入视频后下面什么都没了 &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=对应aid&amp;amp;cid=对应cid&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;95%&quot; height=&quot;600&quot;&gt; &lt;/iframe&gt; &lt;center&gt;&lt;video src=&quot;https://cdn.jsdelivr.net/gh/hovnySiLenCe/cdn@1.1/videos/Believer.mp4&quot; /&gt;&lt;/center&gt;","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"donate/index.html","permalink":"http://hovnySiLenCe.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"「Problem Lists」","date":"2019-12-21T14:48:31.000Z","updated":"2020-06-13T06:47:05.720Z","comments":false,"path":"lists/index.html","permalink":"http://hovnySiLenCe.github.io/lists/index.html","excerpt":"","text":"交互题 [x] CF1336D Yui and Mahjong Set [ ] CF1365G Secure Password [x] CF1363D Guess The Maximums(差点就吃显卡了)","keywords":"「Problem Lists」"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-12T13:48:20.871Z","comments":false,"path":"music/index.html","permalink":"http://hovnySiLenCe.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"资源","date":"2019-11-23T01:52:06.000Z","updated":"2020-01-23T09:37:11.436Z","comments":false,"path":"source/index.html","permalink":"http://hovnySiLenCe.github.io/source/index.html","excerpt":"","text":"$Solfware\\ Download$CCR-Plus","keywords":"资源"},{"title":"rss","date":"2019-10-24T07:26:21.000Z","updated":"2019-10-24T07:26:47.649Z","comments":true,"path":"rss/index.html","permalink":"http://hovnySiLenCe.github.io/rss/index.html","excerpt":"","text":""},{"title":"「Author's Choice」","date":"2019-12-21T14:48:31.000Z","updated":"2020-08-06T08:05:33.176Z","comments":false,"path":"startdash/index.html","permalink":"http://hovnySiLenCe.github.io/startdash/index.html","excerpt":"","text":"mistakes2020-7-30 原来 double 的精度 15 位是包括整部的！！！ $\\mathtt{Luogu\\ P4166}$ 2020-7-29 原来 1&lt;&lt;k 也要注意开 LL 的 $\\mathtt{Luogu\\ P4140}$ 又又又没开 LL，F 和 G 两个 $tag$ 数组没开 LL $\\mathtt{CF1114F}$ 2020-6-2 打 $CF$ 模拟赛又又又又没看清题意/qiao 2020-5-28 打 $CF$ 模拟赛的时候第三次没看清题意 $\\mathtt{CF1344C\\ Quantifier\\ Question}$ 2020-5-24 状压方向弄反了 $\\mathtt{Link}$ 数组排序后没取最小值&amp;爆 int 了 $\\mathtt{Link}$ tips2020-8-6 对于这类求一段区间的权值 $=length\\times value$ 的 max 或 min 值题目，一般采取用分治的思想解决 2020-8-1 旋转卡壳最大外接矩形时维护左右边界可以使用点积 2020-4-4 带权并查集 $\\mathtt{Link}$ 2020-2-7 处理数据的顺序要灵活变换 $\\mathtt{Link}$ 2020-2-5 线段树区间合并可以使用重载运算符来简化代码复杂度 对 $Treap$ 可以用中序遍历进行线性化 2020-2-4 树上 $DP$ 可以转换为 $DFS$ 序后解决 $DP$ 遇到困难，要考虑改变状态，一般来说，有问题就找 $DP$ 状态，如：行先改变为列先 使用 for(i=S;i;i=S&amp;(i-1)) 来遍历集合的所有子集 2020-1-30 底数不变的矩阵快速幂可以用分块优化 Todo List [ ] 线段树分治？！ [ ] 后缀家族 [ ] 概率期望 [x] 旋转卡壳 $\\mathtt{Link}$ something wrong2020-5-24这个原本应该是昨天写的，但是确实由于没有电脑只好今天回校再来写，确实还有希望，要相信自己，慢慢来，可以的！ 2020-5-10居然连提高+的题都做不来了……要加油啊！…… 2020-3-29时隔将近两个月了，我终于回来了，感觉实在是无能，生活过于颓废，无能啊 2020-2-7感觉不是很好，状态，包括自我调整，挣扎到最后发现自己不过还是个人……","keywords":"「Author's Choice」"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-01-23T14:26:03.499Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://hovnySiLenCe.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo 主题 Sakura 修改自 WordPress 主题 Sakura，感谢原作者 Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"「Author's Choice」","date":"2019-12-21T14:48:31.000Z","updated":"2020-08-06T08:05:22.612Z","comments":false,"path":"startdashface/index.html","permalink":"http://hovnySiLenCe.github.io/startdashface/index.html","excerpt":"","text":"mistakes2020-7-30 原来 double 的精度 15 位是包括整部的！！！ $\\mathtt{Luogu\\ P4166}$ 2020-7-29 原来 1&lt;&lt;k 也要注意开 LL 的 $\\mathtt{Luogu\\ P4140}$ 又又又没开 LL，F 和 G 两个 $tag$ 数组没开 LL $\\mathtt{CF1114F}$ 2020-6-2 打 $CF$ 模拟赛又又又又没看清题意/qiao 2020-5-28 打 $CF$ 模拟赛的时候第三次没看清题意 $\\mathtt{CF1344C\\ Quantifier\\ Question}$ 2020-5-24 状压方向弄反了 $\\mathtt{Luogu\\ P1391}$ 数组排序后没取最小值&amp;爆 int 了 $\\mathtt{CF161B\\ Discounts}$ tips2020-8-6 对于这类求一段区间的权值 $=length\\times value$ 的 max 或 min 值题目，一般采取用分治的思想解决 2020-8-1 旋转卡壳最大外接矩形时维护左右边界可以使用点积 2020-4-4 带权并查集 $\\mathtt{Luogu\\ P4079}$ 2020-2-7 处理数据的顺序要灵活变换 $\\mathtt{Link}$ 2020-2-5 线段树区间合并可以使用重载运算符来简化代码复杂度 对 $Treap$ 可以用中序遍历进行线性化 2020-2-4 树上 $DP$ 可以转换为 $DFS$ 序后解决 $DP$ 遇到困难，要考虑改变状态，一般来说，有问题就找 $DP$ 状态，如：行先改变为列先 使用 for(i=S;i;i=S&amp;(i-1)) 来遍历集合的所有子集 2020-1-30 底数不变的矩阵快速幂可以用分块优化","keywords":"「Author's Choice」"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-01-29T03:29:42.757Z","comments":false,"path":"tags/index.html","permalink":"http://hovnySiLenCe.github.io/tags/index.html","excerpt":"","text":"咕 $ing$","keywords":"标签"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-29T00:30:58.470Z","comments":false,"path":"video/index.html","permalink":"http://hovnySiLenCe.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"「Luogu P5502」[JSOI2015]最大公约数 解题报告","slug":"Luogu_P5502-[JSOI2015]MaximumGcd-Solution","date":"2020-08-06T08:03:41.000Z","updated":"2020-08-06T08:41:28.971Z","comments":true,"path":"2020/08/06/Luogu_P5502-[JSOI2015]MaximumGcd-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2020/08/06/Luogu_P5502-[JSOI2015]MaximumGcd-Solution/","excerpt":"","text":"题面求一段区间的权值 $=length\\times value$ 的 $max$ 值题目 解题思路方法一：ST表+倍增+贪心显然： 如果区间左端点 $l$ 确定，该区间可能的 $gcd$ 取值最多只有 $log_2a_l$ 种 如果 $gcd$ 确定，区间长度越长，答案越优 如此一来，我们就可以枚举 $l$，用倍增求每一个 $gcd$ 可能值的最右端点 $r$，由于随着 $r$ 的变化，$gcd$ 的取值最多有 $log_2a_l$ 种，就算乘上倍增的 $log_2(n-l+1)+1$ ，复杂度也是允许的，只需用 $ST$ 表事先处理区间 $gcd$ 即可 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline LL read() { rll s=0;rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,m,b[19],Log[N];LL f[N][19],ans,res; inline LL calc(rint l,rint r) { rint k=Log[r-l+1]; return __gcd(f[l][k],f[r-b[k]+1][k]); } inline void solve(rint l) {//分别求出每种gcd的左右端点 rint k,r=l;LL c; while(r&lt;=n) { for(k=Log[n-l+1],c=calc(l,r);k&gt;=0;--k) if(r+b[k]-1&lt;=n&amp;&amp;c==calc(l,r+b[k]-1)) r+=b[k]; cmax(ans,c*(r-l)); } } int main() { rint i,j;n=read(),Log[0]=-1,b[0]=1; for(i=1;i&lt;=n;i++) f[i][0]=read(),Log[i]=Log[i&gt;&gt;1]+1;m=Log[n]; for(i=1;i&lt;=m;++i) b[i]=b[i-1]&lt;&lt;1; for(j=1;j&lt;=m;j++)//ST表 for(i=1;i+(1&lt;&lt;j)&lt;=n+1;++i) f[i][j]=__gcd(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); for(i=1;i&lt;=n;i++) solve(i);//枚举左端点 printf(&quot;%lld&quot;,ans); return 0; } 方法二：分治这波是从题解学到的 下为原话 对于这类求一段区间的权值 $=length \\times value$ 的 $max$ 或 $min$ 值题目，一般采取用分治的思想解决 设 $\\large mid=\\frac {l+r} 2$，则 $[l,mid]$ 与 $[mid+1,r]$ 合并时，一定会包含 $a_{mid}$ 由于运用的是分治，我们可以参考归并排序中 $[a_l&lt;b_r]$ 的 $cmp$ 条件 这里我们使用 $\\large gcd(al,a{mid})$ 与 $\\large gcd(ar,a{mid})$ 的大小关系作为拓展条件 以 $mid$ 为中心，将 $l,r$ 向 $gcd$ 较大的方向拓展，通过贪心可以证明这样的选法是更优的，每次计算得答案即可 时间复杂度（不算 $gcd$ 时间）为 $nlog_2n$ Code当然是嫖的 $Link$ %:pragma GCC optimize(2) %:pragma GCC optimize(3) #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define ull unsigned long long #define lll __int128 const int N = 100005; ll a[N]; int n; ll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; } ll dfs(int l, int r) { if (l == r) return a[l]; int mid = (l + r) &gt;&gt; 1; ll ans = max(dfs(l, mid), dfs(mid + 1, r)); ll g = gcd(a[mid], a[mid + 1]); ans = max(ans, 2LL * g); int x = mid, y = mid + 1; while (x &gt; l &amp;&amp; y &lt; r) { if (gcd(g, a[x - 1]) &gt; gcd(g, a[y + 1])) {//选择拓展方向 g = gcd(g, a[x - 1]); x--; } else { g = gcd(g, a[y + 1]); y++; } ans = max(ans, (ll)(y - x + 1) * g); } while (x &gt; l) {//可能一侧已经拓展完了 g = gcd(g, a[x - 1]); x--; ans = max(ans, (ll)(y - x + 1) * g); } while (y &lt; r) { g = gcd(g, a[y + 1]); y++; ans = max(ans, (ll)(y - x + 1) * g); } return ans; } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a[i]); } printf(&quot;%lld\\n&quot;, dfs(1, n)); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://hovnySiLenCe.github.io/tags/贪心/"},{"name":"分治","slug":"分治","permalink":"http://hovnySiLenCe.github.io/tags/分治/"},{"name":"ST表","slug":"ST表","permalink":"http://hovnySiLenCe.github.io/tags/ST表/"},{"name":"倍增","slug":"倍增","permalink":"http://hovnySiLenCe.github.io/tags/倍增/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2523」[HAOI2011]Problem c 解题报告","slug":"Luogu_P2523-[HAOI2011]Problem_c-Solution","date":"2020-06-08T13:36:54.000Z","updated":"2020-06-08T14:23:14.294Z","comments":true,"path":"2020/06/08/Luogu_P2523-[HAOI2011]Problem_c-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2020/06/08/Luogu_P2523-[HAOI2011]Problem_c-Solution/","excerpt":"","text":"题面解题思路动态规划 分析显然，如果我们对每个确定的位置进行标记，然后做一个后缀和，就可以得出无解的情况，得出 $i$ 位置后最多能放元素的个数 显然，如果我们对这个后缀和从前往后取个 $min$ 的话，我们就可以真正意义上的出 $i$ 位置后最多能放的元素个数（然而这并没有什么软用 实际有用的就是怎么去计算方案 显然直接暴上组合数是会炸的（无法计算重复的部分），那么我们就 $DP$ 转移方程为： \\large f_{i,j}=\\sum_{k=0}^{s_i}\\binom{j}{k}f_{i+1,j-k} \\pmod p$f_{i,j}$ 表示倒序做到 $i$ 这个位置，安排了 $j$ 个人的方案数，$\\large \\binom{j}{k}$ 表示从这 $j$ 个人中选出 $k$ 个，安排在 $i$ 这个位置的方案，转移即可 就做完了 Warning1、记得开 long long 2、累加 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 303 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,m,p,T; int s[N],f[N][N],C[N][N]; inline int dec(rint x) {return (x&gt;=p)?x-p:x;} int main() { rint i,j,k;T=read(); while(T--) {n=read(),m=read(),p=read(); memset(s,0,sizeof(s)), memset(f,0,sizeof(f)); for(i=1;i&lt;=m;i++) read(),++s[read()]; for(i=n;i;--i) if((s[i]+=s[i+1])&gt;n-i+1) break; if(i) printf(&quot;NO\\n&quot;); else {m=n-m,C[0][0]=1; for(i=1;i&lt;=m;i++) { C[i][0]=1; for(j=1;j&lt;=i;j++) C[i][j]=dec(C[i-1][j-1]+C[i-1][j]); }s[0]=inf; for(i=1;i&lt;=n;++i) s[i]=min(s[i-1],n-i+1-s[i]);//求最多的个数，没什么用 f[n+1][0]=1;//记得初始值 for(i=n;i;i--) { for(j=0;j&lt;=s[i];++j) { for(k=0;k&lt;=j;k++) f[i][j]=dec(f[i][j]+(LL)C[j][k]*f[i+1][j-k]%p);//转移就完了 } }printf(&quot;YES %d\\n&quot;,f[1][m]); } } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF1344D」Résumé Review 解题报告","slug":"CF1344D-Resume_Review-Solution","date":"2020-05-29T13:29:29.000Z","updated":"2020-07-23T08:31:00.514Z","comments":true,"path":"2020/05/29/CF1344D-Resume_Review-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2020/05/29/CF1344D-Resume_Review-Solution/","excerpt":"","text":"题面解题思路推理+二分+解方程 分析这手操作有点骚 我们首先可以分析一手这个函数有什么性质 \\sum_{i=1}^nb_i(a_i-b_i^2),b_i\\in [0,a_i]有点小头秃，但是我们可以分析一手单个函数的变化 不难发现，$b_i(a_i-b_i^2)$ 随着 $b_i$ 变化的增量是单调递减的 令 $f(b)=b(a-b^2),f(b+1)=(b+1)(a-(b+1)^2)$， f(b+1)-f(b)=ab+a-(b+1)^3-ab-b^3 f(b+1)-f(b)=a-3b^2-3b-1整理可得： f(b+1)-f(b)=-3b^2-3b+a-1对称轴为 $x=\\frac 1 2$，也就是这个函数是在 $\\Z ^+$ 上单调递减（不含 $0$ )， 这样子就启发我们，可以把这个函数拆开看，就等同于 现在有 $n$ 堆数，要从中取出 $K$ 个数使得结果最大 这样一下子贪心显然是成立的，但是如果一个个取的话…… 这个时候我们就可以请出我们的二分了！ 不难想到我们可以二分 选中的数的最小值，显然这东西是单调的 即，最小值越小，越有可能选出 $K$ 个， 大则相反 然后瓶颈就转向了如何求出每堆中要选几个 我们可以把 $f(b+1)-f(b)$ 记为 $g(b)=-3b^2-3b+a-1$， 只需解 $g(b)=-3b^2-3b+a-1\\ge mid$ （ $mid$ 为二分的最小值），即可 由求根公式可得，$\\large x=\\lfloor \\frac {3-\\sqrt{9+4(a-1-mid)}} {-6}\\rfloor$ 最后要我们输出方案，也可以这么求，但是要注意的是，可能我们选的数总和会超出 $K$，因为有些数会卡在最小值那个线上 我们只要判断一下去掉即可 于是就做完了 Warning1、别忘了 long long 2、注意求根无解的状况 3、注意精度 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100007 using namespace std; const long double A=-3,B=-3; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline LL read() { rll s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } LL n,a[N],l,r,m,K,sum,Ans[N],ans; inline LL calc(long double C) {//求根 if(A+B+C&lt;0) return 0; return (-B-sqrt(B*B-4*A*C))/(2*A); } inline LL solve(rll m) {//判断是否满足K个 sum=0; for(rint i=1;i&lt;=n;i++) sum+=min(calc(a[i]-1-m),a[i]); return sum; } inline void work_out(rll m) { sum=0; for(rint i=1;i&lt;=n;i++) sum+=Ans[i]=min(calc(a[i]-1-m),a[i]); } int main() { rint i;n=read(),K=read(),l=inf; for(i=1;i&lt;=n;i++) a[i]=read(),cmax(r,a[i]),cmin(l,a[i]-3*a[i]*a[i]-3*a[i]-1); while(l&lt;=r) { m=(l+r)&gt;&gt;1; if(solve(m)&gt;=K) ans=m,l=m+1; else r=m-1; }work_out(ans); for(i=1;i&lt;=n;i++) { if(sum&gt;K&amp;&amp;a[i]-3*Ans[i]*Ans[i]-3*Ans[i]-1==ans) --Ans[i],--sum;//判掉多出的 printf(&quot;%lld &quot;,Ans[i]); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://hovnySiLenCe.github.io/tags/二分/"},{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF1344C」Quantifier Question 解题报告","slug":"CF1344C-Quantifier_Question-Solution","date":"2020-05-28T08:32:11.000Z","updated":"2020-07-23T08:34:51.835Z","comments":true,"path":"2020/05/28/CF1344C-Quantifier_Question-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2020/05/28/CF1344C-Quantifier_Question-Solution/","excerpt":"","text":"题面解题思路拓扑排序 一开始没看懂题目，感觉复杂的，后来就感觉还是可以的 分析首先，我们要明确，如果有相关的若干个命题，一定要先出现 $\\forall$，再出现 $\\exist$，因此有了这个限制之后，我们想题目就会方便很多 显然，如果有环肯定是不成立的 我们先考虑对于一个点 $i$，如果 $i$ 点能到达的点 或者 能到达 $i$ 点的点的 $id &lt; i$ ，显然 $i$ 点不能为 $\\forall$，否则就能为 $\\forall$，这样就做完了 Warning1、注意是所有能到 $i$ 或者 $i$ 能到的点 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 200007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int HF[N],HL[N],n,m,t,d[N],S[N],ans; int ver[N&lt;&lt;1],nxt[N&lt;&lt;1],P[N],vis[N],o[N];//别忘了N&lt;&lt;1 inline void Add(rint x,rint y) { ver[++t]=y,nxt[t]=HF[x],HF[x]=t; ver[++t]=x,nxt[t]=HL[y],HL[y]=t; } inline bool solve_P() { rint i,c,to,sum=0;queue&lt;int&gt;p; memset(P,inf,(n+1)&lt;&lt;2); for(i=1;i&lt;=n;i++) if(!d[i]) p.push(i); while(!p.empty()) { c=p.front(),p.pop(),++sum; for(i=HF[c];i;i=nxt[i]) { --d[to=ver[i]],cmin(P[to],min(P[c],c)); if(!d[to]) p.push(to); } } return sum&lt;n; } inline void solve_S() { rint i,c,to;queue&lt;int&gt;p; memset(S,inf,(n+1)&lt;&lt;2); for(i=1;i&lt;=n;i++) if(!o[i]) p.push(i); while(!p.empty()) { c=p.front(),p.pop(); for(i=HL[c];i;i=nxt[i]) { --o[to=ver[i]],cmin(S[to],min(S[c],c)); if(!o[to]) p.push(to); } } } int main() { rint i,x,y; n=read(),m=read(); for(i=1;i&lt;=m;i++) ++o[x=read()],++d[y=read()],Add(x,y);//要建正反图跑一跑 if(solve_P()) {printf(&quot;-1&quot;);return 0;}solve_S(); for(i=1;i&lt;=n;i++) if(P[i]&gt;i&amp;&amp;i&lt;S[i]) vis[i]=1,++ans; printf(&quot;%d\\n&quot;,ans); for(i=1;i&lt;=n;i++) printf(&quot;%c&quot;,vis[i]?&#39;A&#39;:&#39;E&#39;); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://hovnySiLenCe.github.io/tags/拓扑排序/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「SP2916」GSS5 - Can you answer these queries V 解题报告","slug":"SP2916-GSS5-Can_you_answer_these_queries_V-Solution","date":"2020-05-12T07:27:55.000Z","updated":"2020-05-28T08:46:45.157Z","comments":true,"path":"2020/05/12/SP2916-GSS5-Can_you_answer_these_queries_V-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2020/05/12/SP2916-GSS5-Can_you_answer_these_queries_V-Solution/","excerpt":"","text":"题面解题思路线段树 分析分析一手，分为两种情况讨论 两区间没有相交的部分 这种情况还是比较好处理的，只要找出左边的最大右子段和，找出右边的最大左子段和 两区间有相交的部分 设左端点 $l$ 所在区间为 $A$，右端点 $r$ 所在区间为 $B$，则令 $A \\cap B=C$ 显然，有这样几种情况： $l \\in \\complement_AC,r \\in B$，变成了没有相交的情况 $l \\in C,r\\in C$，直接普通求就好 $l\\in A,r\\in \\complement_BC$，也是没有相交的情况 直接写就好 Warning1、八倍四倍空间 2、注意普通求解操作 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 10003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rgt int s=0,p=1; rgt char c=getchar(); while(!isdigit(c)) p=(c==&#39;-&#39;)?-1:1,c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s*p; } int T,n,m,a[N],f[N&lt;&lt;2],Fl[N&lt;&lt;2],Sum; int Fr[N&lt;&lt;2],sum[N&lt;&lt;2],s[N],ans,res,Ans;//Ans和ans的区别 inline void Update(rint k,rint ls,rint rs) {//更新 f[k]=max(max(f[ls],f[rs]),Fr[ls]+Fl[rs]), Fl[k]=max(Fl[ls],Fl[rs]+sum[ls]), Fr[k]=max(Fr[rs],Fr[ls]+sum[rs]), sum[k]=sum[ls]+sum[rs]; } inline void built(rint k,rint l,rint r) { if(l==r) {f[k]=Fl[k]=Fr[k]=sum[k]=a[l];return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; built(ls,l,m),built(ls|1,m+1,r), Update(k,ls,ls|1); } inline void Query(rint k,rint l,rint r,rint L,rint R) {//普通 if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) { cmax(ans,max(f[k],res+Fl[k])), res=max(Fr[k],res+sum[k]); return; }rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Query(ls,l,m,L,R),Query(ls|1,m+1,r,L,R); } inline void Query_Left(rint k,rint l,rint r,rint L,rint R) {//最大右子段和 if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {cmax(ans,res+Fr[k]),res+=sum[k];return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Query_Left(ls|1,m+1,r,L,R), Query_Left(ls,l,m,L,R); } inline void Query_Right(rint k,rint l,rint r,rint L,rint R) {//最大左子段和 if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {cmax(ans,res+Fl[k]),res+=sum[k];return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Query_Right(ls,l,m,L,R), Query_Right(ls|1,m+1,r,L,R); } inline int Q(rint L,rint R) { ans=-inf,res=0,Sum=0,Query(1,1,n,L,R); return ans; } inline int QL(rint L,rint R) { if(L&lt;=R) { ans=-inf,res=0,Query_Left(1,1,n,L,R); return ans; }return 0; } inline int QR(rint L,rint R) {//这一串是为了方便返回值 if(L&lt;=R) { ans=-inf,res=0,Query_Right(1,1,n,L,R); return ans; }return 0; } int main() { rint i,lx,rx,ly,ry;T=read(); while(T--) {n=read(); for(i=1;i&lt;=n;i++) a[i]=read(),s[i]=s[i-1]+a[i]; built(1,1,n),m=read(); for(i=1;i&lt;=m;i++) { lx=read(),rx=read(),ly=read(),ry=read(); if(rx&lt;ly) printf(&quot;%d\\n&quot;,QL(lx,rx)+s[ly-1]-s[rx]+QR(ly,ry));//注意中间前缀和处理 else { Ans=Q(ly,rx), cmax(Ans,QL(lx,ly-1)+QR(ly,ry)), cmax(Ans,QL(lx,rx)+QR(rx+1,ry)),//分情况讨论 printf(&quot;%d\\n&quot;,Ans); } } } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3963」[TJOI2013]奖学金 解题报告","slug":"Luogu_P3963-[TJOI2013]Scholarship-Solution","date":"2020-02-07T10:12:52.000Z","updated":"2020-07-23T08:34:51.059Z","comments":true,"path":"2020/02/07/Luogu_P3963-[TJOI2013]Scholarship-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2020/02/07/Luogu_P3963-[TJOI2013]Scholarship-Solution/","excerpt":"","text":"题面解题思路这是一道用 priority\\_queue 显然可做的题，然而明明可以反着做，我却一定要正序做…… 深深地明白自己的弱小…… Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 200007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int sco,rew; inline void in() { sco=read(),rew=read(); } inline bool operator&lt; (const node x) const{ return sco&lt;x.sco; } }b[N]; int n,m,ans=-1; LL sum,res,f[N]; priority_queue&lt;int&gt;pl,pr; int main() { rint i,k,c; k=(read()-1)&gt;&gt;1,n=read(),m=read(); for(i=1;i&lt;=n;i++) b[i].in(); if(!k) { for(i=1;i&lt;=n;i++) if(b[i].rew&lt;=m) cmax(ans,b[i].sco); printf(&quot;%d&quot;,ans);return 0; }sort(b+1,b+n+1); for(i=n-k+1;i&lt;=n;i++) res+=b[i].rew,pr.push(b[i].rew); for(i=n-k;i&gt;k;--i) { f[i]=res;//只不过正序做就不用记录，不知道为什么感觉反着做有点投机取巧…… if(pr.top()&gt;b[i].rew) res=res-pr.top()+b[i].rew, pr.pop(),pr.push(b[i].rew); } for(i=1;i&lt;=k;i++) sum+=b[i].rew,pl.push(b[i].rew); for(i=k+1;i&lt;=n-k;i++) { if(sum+b[i].rew+f[i]&lt;=m) ans=b[i].sco; if(pl.top()&gt;b[i].rew) sum=sum-pl.top()+b[i].rew, pl.pop(),pl.push(b[i].rew); }printf(&quot;%d\\n&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"优先队列","slug":"优先队列","permalink":"http://hovnySiLenCe.github.io/tags/优先队列/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「某讲稿」扫描线 学习笔记","slug":"LectureNotes-ScanningLine-Notes","date":"2020-01-27T13:52:15.000Z","updated":"2020-01-31T12:37:55.055Z","comments":true,"path":"2020/01/27/LectureNotes-ScanningLine-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2020/01/27/LectureNotes-ScanningLine-Notes/","excerpt":"","text":"前言扫描线也不算是一个很冷门的算法吧，但是实现的时候还是稍微有点问题，这里就稍作分析 正文扫面线开幕雷击 扫描线一般用于解决图形面积、周长等问题，最典型的应用就是处理矩形面积并、周长并类问题 矩形面积并题面一般是这样的： 求 $n$ 个矩形的面积并，每个矩形以左下角 $(x_1,y_1)$ 和右上角 $(x_2,y_2)$ 的形式给出 (1\\le n \\le 10^5,0\\le x_1< x_2\\le 10^9,0\\le y_1< y_2\\le 10^9) 有些时候坐标还不是整数，当然啦，这些都不是问题 来康康下面的例子 有效面积为： 那么我们是不是可以按照小学数学方法——割补法来求，按照 $x$ 的顺序从左到右割成若干个矩形，然后从左到右像扫描一样依次求解，这就叫做扫描线 根据 $x$ 值的不同，我们可以把这个平面图形切成好几部分，每一部分都可以看做规则的矩形来求解，而矩形的长 $a$ 是显然的，为两条线相邻 $x$ 的差，关键在于如何维护矩形的宽 $b$，也就是 $y$ 上图以第一、二条线为例，$a=3-1=2,b=(6-3)+(2-1)=4$ 如图由于每条线段的含义不同，分为 $+1$ 和 $-1$ 两种，通过差分来表示某段 $y$ 区间被覆盖的次数，由此可以得知 $b$，即有效的 $y$ 区间大小。其实维护点是没有意义的，因为会出现点太多和点在实数范围的情况，实际上，对于一条线段来说，左右端点之间的点本质是相同的，我们只需要维护区间即可 就比如上图中 $A,B,C,D$ 四点所在的直线，我们可以看成由四个点分出的五个部分来维护。简而言之，我们不维护点，而是将每个点离散化后维护两点之间的区间 p[++t]=ly,p[++t]=ry;//所有y值一起离散，就好像上图A和E之间也应有一段区间 sort(p+1,p+t+1),t=unique(p+1,p+t+1)-p-1; 比较难以理解的就是用线段树实现部分 tag[k] 维护的是差分数组，f[k] 表示有效 $y$ 值，也就是 $b$ inline void Update(rint k,rint l,rint r) { if(tag[k]) f[k]=p[r+1]-p[l];//表示这段区间都被覆盖了，则b为这段区间的长度，r+1是因为端点原因 else if(l==r) f[k]=0;//一个点无法构成区间，为0 else f[k]=f[k&lt;&lt;1]+f[k&lt;&lt;1|1];//否则从儿子处更新 } inline void Modify(rint k,rint l,rint r,rint op) {//op=+1/-1，表示当前线段类型 if(r&lt;L||R&lt;l) return;//[L,R]表示修改区间 if(L&lt;=l&amp;&amp;r&lt;=R) {tag[k]+=op;return Update(k,l,r);} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,m,op),Modify(ls|1,m+1,r,op), Update(k,l,r); } 直接这样打标记会不会出什么问题？ 确实，这样我们就不能查询任意一个区间，然而扫描线查询的是所有区间的总和，也就是 f[1]，因此不会出问题，我们可以讨论一下 设 $k$ 为当前区间，$ls$ 表示当前区间的左子区间，$ls|1$ 为右子区间，就和线段树一样哈 讨论覆盖的情况 假设 $k$ 没有被覆盖那么覆盖了 $k$ 的子区间之后，f[k] 会从 f[ls]&amp;f[ls|1] 处更新，结果是正确的 假设 $k$ 被覆盖了那么覆盖 $k$ 的子区间对 $k$ 是没有影响的，f[k] 由自身的区间长度决定 然后我们就可以得知 f[1] 是肯定正确的，emmm，感觉这证明好像没有什么用 讨论覆盖和删除并存情况 按照平常肯定是会出问题的，但是，矩形有个优美的性质：对边平行且相等，有覆盖肯定有删除，不会出错，因此直接写成上述那样是没问题的 来康康主函数咋写 int main() { int i,x,y;n=read(); for(i=1;i&lt;=n;i++) {//x,L,y,R分别是x1,y1,x2,y2 x=read(),L=read(),y=read(),R=read(), p[++t]=L,b[t]=seg(x,L,R,1), p[++t]=R,b[t]=seg(y,L,R,-1);//存线段 }n&lt;&lt;=1; sort(b+1,b+n+1,cmp),sort(p+1,p+t+1);//b数组按照x排序，p是y的数组用于离散化 t=unique(p+1,p+t+1)-p-1;//去重 R=lower_bound(p+1,p+t+1,b[1].r)-p-1,//得到区间的离散值，记得端点和区间的区别 L=lower_bound(p+1,p+t+1,b[1].l)-p,Modify(1,1,t,b[1].op); for(i=2;i&lt;=n;i++) { ans+=(LL)(b[i].p-b[i-1].p)*f[1];//b[i].p-b[i-1].p=a,f[1]=b L=lower_bound(p+1,p+t+1,b[i].l)-p, R=lower_bound(p+1,p+t+1,b[i].r)-p-1, Modify(1,1,t,b[i].op); }printf(&quot;%lld&quot;,ans); return 0; } 扫描线还是比较单纯的 除了会打出炒面线、草苗线、扫面线之外 CodeLuogu P5490 【模板】扫描线 #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct seg{//线段 int p,l,r,op; seg(rint a,rint b,rint c,rint d):p(a),l(b),r(c),op(d){} seg(){} }b[N&lt;&lt;1]; int n,f[N&lt;&lt;3],tag[N&lt;&lt;3],p[N&lt;&lt;1],L,R,t;//注意数组大小 LL ans; inline void Update(rint k,rint l,rint r) { if(tag[k]) f[k]=p[r+1]-p[l]; else if(l==r) f[k]=0; else f[k]=f[k&lt;&lt;1]+f[k&lt;&lt;1|1]; } inline void Modify(rint k,rint l,rint r,rint op) { if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {tag[k]+=op;return Update(k,l,r);} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,m,op),Modify(ls|1,m+1,r,op), Update(k,l,r); } inline bool cmp(rgt seg a,rgt seg b) {//按照x排序扫描 return a.p&lt;b.p; } int main() { rint i,x,y;n=read(); for(i=1;i&lt;=n;i++) { x=read(),L=read(),y=read(),R=read(), p[++t]=L,b[t]=seg(x,L,R,1), p[++t]=R,b[t]=seg(y,L,R,-1); }n&lt;&lt;=1; sort(b+1,b+n+1,cmp),sort(p+1,p+t+1); t=unique(p+1,p+t+1)-p-1; R=lower_bound(p+1,p+t+1,b[1].r)-p-1, L=lower_bound(p+1,p+t+1,b[1].l)-p,Modify(1,1,t,1); for(i=2;i&lt;=n;i++) { ans+=(LL)(b[i].p-b[i-1].p)*f[1];//b[i].p-b[i-1].p=a,f[1]=b L=lower_bound(p+1,p+t+1,b[i].l)-p, R=lower_bound(p+1,p+t+1,b[i].r)-p-1, Modify(1,1,t,b[i].op);//修改 }printf(&quot;%lld&quot;,ans); return 0; } 矩形周长并矩形周长并的思路和面积并类似，也是通过扫描线一条一条进行处理 来看如下例子： 可以看出，原本矩形的边会互相影响，并且多个矩形构成的新图形可能内部是空的 当然了，这些问题扫描线都可以处理 依旧按照上述方法，从左往右扫描 计算平行于 y 轴的边长平行于 $y$ 轴的边长可以看成是在 $y$ 轴上覆盖区间长度，每扫一条线，$y$ 轴上覆盖的区间就会变化，而这个变化的大小就是有效的边长长度 用 f[1] 表示用线段树维护的在 $y$ 轴上的覆盖区间大小 例如从 1 过渡到了 2，f[1] 从 $2$ 变成了 $4$，那么有效的边长就为 $abs(4-2)=2,ans=0+2=2$， 从 3-4，f[1] 从 $5\\to6$，有效边长为 $1,ans=5+1=6$， 从 4-5，f[1] 从 $6\\to5$，有效边长为 $abs(5-6)=1,ans=6+1=7$， 从 7-8，f[1] 从 $6\\to6$，无变化， 但是如果我们把扫描的顺序换一下，变成 8-7，f[1] 从 $1\\to 6$，$abs(1-6)=5$，然而有效边长实际上为 $0$，这就出现了问题 因此我们需要在排序的时候把 $x$ 轴坐标相同的，按照 $op$ 类型排序，先 $+1$ 后 $-1$ struct seg{ int p,l,r,op; seg(rint a,rint b,rint c,rint d):p(a),l(b),r(c),op(d){} seg(){} inline bool operator&lt; (const seg x) const{ return (p!=x.p)?p&lt;x.p:op&gt;x.op; } } 同时不要忘记第一次扫描所带来的有效边长 计算平行于 x 轴的边长如果按照从左到右处理的话，两次扫描之间的 $x$ 坐标的差值是很容易得出的，需要知道的就是在这两次扫描之间平行于 $x$ 轴的线段的数目，显然，这个只需要维护 $y$ 轴覆盖区间形成的线段数即可 这就需要我们多记录几个值，bool fl[k],fr[k] 分别表示左右端点是否被覆盖，int g[k] 表示线段数 $Update()$ 还是比较容易理解的，就不再赘述，其余部分什么多大区别 inline void Update(rint k,rint l,rint r) { if(tag[k]) f[k]=p[r+1]-p[l],g[k]=fl[k]=fr[k]=1; else if(l==r) f[k]=g[k]=fl[k]=fr[k]=0; else { rint ls=k&lt;&lt;1; f[k]=f[ls]+f[ls|1], g[k]=g[ls]+g[ls|1]-(fr[ls]&amp;&amp;fl[ls|1]), fl[k]=fl[ls],fr[k]=fr[ls|1]; } } 当然我们还可以纵向扫描啊，也就是再做一次类似平行 $y$ 轴的操作，至于码量嘛，这个你自己好好思考一下谁更优秀 最后还需要注意，每条线段有两个端点 CodeLuogu P1856 [USACO5.5]矩形周长Picture #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 5003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0,p=1; rgt char c=getchar(); while(!isdigit(c)) {if(c==&#39;-&#39;) p=-1;c=getchar();} while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s*p; } struct seg{ int p,l,r,op; seg(rint a,rint b,rint c,rint d):p(a),l(b),r(c),op(d){} seg(){} inline bool operator&lt; (const seg x) const{ return (p!=x.p)?p&lt;x.p:op&gt;x.op; } }b[N&lt;&lt;1]; int n,L,R,p[N&lt;&lt;1],t,c,ans; int f[N&lt;&lt;3],g[N&lt;&lt;3],tag[N&lt;&lt;3]; bool fl[N&lt;&lt;3],fr[N&lt;&lt;3]; inline void Update(rint k,rint l,rint r) { if(tag[k]) f[k]=p[r+1]-p[l],g[k]=fl[k]=fr[k]=1; else if(l==r) f[k]=g[k]=fl[k]=fr[k]=0; else { rint ls=k&lt;&lt;1; f[k]=f[ls]+f[ls|1], g[k]=g[ls]+g[ls|1]-(fr[ls]&amp;&amp;fl[ls|1]), fl[k]=fl[ls],fr[k]=fr[ls|1]; } } inline void Modify(rint k,rint l,rint r,rint op) { if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {tag[k]+=op;return Update(k,l,r);} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,m,op),Modify(ls|1,m+1,r,op), Update(k,l,r); } int main() { rint i,x,y;n=read(); for(i=1;i&lt;=n;i++) { x=read(),L=read(),y=read(),R=read(), p[++t]=L,b[t]=seg(x,L,R,1), p[++t]=R,b[t]=seg(y,L,R,-1); }n&lt;&lt;=1; sort(b+1,b+t+1),sort(p+1,p+t+1); t=unique(p+1,p+t+1)-p-1, R=lower_bound(p+1,p+t+1,b[1].r)-p-1, L=lower_bound(p+1,p+t+1,b[1].l)-p, Modify(1,1,t,1),ans=c=f[1];//第一次扫描的有效长度 for(i=2;i&lt;=n;i++) { ans+=2*g[1]*(b[i].p-b[i-1].p), L=lower_bound(p+1,p+t+1,b[i].l)-p, R=lower_bound(p+1,p+t+1,b[i].r)-p-1, Modify(1,1,t,b[i].op),ans+=abs(f[1]-c),c=f[1]; }printf(&quot;%lld&quot;,ans); return 0; } Problem List [x] Luogu P5490 【模板】扫描线 [x] Luogu P3875 [TJOI2010]被污染的河流 [x] Luogu P1502 窗口的星星 [x] Luogu P1856 [USACO5.5]矩形周长Picture [x] 「HDU1542」Atlantis [x] 「HDU1828」Picture (多组数据) [ ] 「HDU3265」Posters","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"},{"name":"扫描线","slug":"扫描线","permalink":"http://hovnySiLenCe.github.io/tags/扫描线/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}]},{"title":"「Luogu P4404」[JSOI2010]缓存交换 解题报告","slug":"Luogu_P4404-JSOI2010-CacheSwap-Solution","date":"2019-12-21T01:09:32.000Z","updated":"2019-12-21T01:37:51.545Z","comments":true,"path":"2019/12/21/Luogu_P4404-JSOI2010-CacheSwap-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/12/21/Luogu_P4404-JSOI2010-CacheSwap-Solution/","excerpt":"","text":"题面解题思路优先队列&amp;贪心 分析一开始给的数据范围过大，先离散化 $\\to$ 直接上板子接着有显然的结论，删去 $Cache$ 中再出现的位置最后的元素是最优的，只要用 priority\\_queue 维护即可 如何证明贪心的正确性 真·显然，如果删去再出现位置较前的，当做到这个位置 $i$ 时需要重新加入一次，而删去较后的元素，在 $i$ 位置时，就不需要重新加入 关于优先队列 优先队列维护最大值可以说是静态的，当比较的关键字在外部改变时，优先队列内部是不会做出调整的比如，优先队列中比较关键字为 f[x]，如果 f[x] 在该元素插入之后改变，该元素在优先队列内部的顺序不会改变不仅如此，随之带来的一系列迷之操作根本停不下来 warning就算一个值已经出现在了 $Cache$ 中，相应的信息也要更新 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 1000007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,m,t,p[N],b[N],f[N],ls[N],ans; bool vis[N]; struct cmp{ inline bool operator() (const int a,const int b) { return f[a]&lt;f[b]; } }; priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;P;//重载运算符，根据一个元素下一次出现的位置 int main() { rint i;n=read(),m=read(); for(i=1;i&lt;=n;i++) p[i]=b[i]=read(); sort(p+1,p+n+1),t=unique(p+1,p+n+1)-p-1; for(i=1;i&lt;=n;++i) b[i]=lower_bound(p+1,p+t+1,b[i])-p;//离散化 memset(ls,inf,(t+1)&lt;&lt;2); for(i=n;i;--i) f[i]=ls[b[i]],ls[b[i]]=i;//下一次出现的位置 for(i=1,t=0;i&lt;=n;i++) { if(vis[b[i]]) {P.push(i);continue;}//存在于Cache中也要更新 if(t&lt;m) ++t; else vis[b[P.top()]]=0,P.pop(); ++ans,vis[b[i]]=1,P.push(i); }printf(&quot;%d&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"优先队列","slug":"优先队列","permalink":"http://hovnySiLenCe.github.io/tags/优先队列/"},{"name":"贪心","slug":"贪心","permalink":"http://hovnySiLenCe.github.io/tags/贪心/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3409」值日班长值周班长 解题报告","slug":"Luogu_P3409-DailyMonitors-Solution","date":"2019-12-12T07:21:11.000Z","updated":"2019-12-12T08:02:24.843Z","comments":true,"path":"2019/12/12/Luogu_P3409-DailyMonitors-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/12/12/Luogu_P3409-DailyMonitors-Solution/","excerpt":"","text":"题面解题思路数学与 Ex\\_gcd 分析根据题意，我们可以列出如下的方程组，设 $w$ 为周数，$bit$ 为离这周的周五还有几天 \\begin{equation} \\left\\{ \\begin{aligned} (5w-bit)\\%n=m\\ \\ \\ \\ \\ \\ (1)\\\\ w\\%p=q\\ \\ \\ \\ \\ \\ \\ (2) \\end{aligned} \\right. \\end{equation}先将 $(2)$ 转换形式得： w=px+q\\ \\ \\ \\ \\ \\ (3)将 $(3)$ 代入 $(1)$ 得： (5px+5q-bit)\\%n=m\\\\ 5px+5q-bit=ny+m\\\\整理得： 5px+ny=m-5q+bit\\\\令： \\begin{equation} \\left\\{ \\begin{aligned} a=5p\\\\ b=n\\\\ c=m-5q+bit \\end{aligned} \\right. \\end{equation}原式就可以变成： ax+by=c这样的话，$x$ 的值就可以通过 Ex\\_gcd 得出一个最小正整数解，那么也就可以得出 $w$ 的值，从而得出最小满足条件的天数 最后通过枚举 $bit$ 来检验每个解即可 Warning注意范围以及输出格式，每周只有五天，不要算周末的时间 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } LL n,m,p,q,a,b,c,d,x,y,ans,res; inline LL Ex_gcd(rll a,rll b,rll &amp;x,rll &amp;y) { if(!b){x=1,y=0;return a;} rll d=Ex_gcd(b,a%b,y,x); y-=a/b*x;return d; } int main() { rint i; while(~scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;p,&amp;q)) { a=5*p,b=n,c=m-5*q,ans=-1;//不想赋inf d=Ex_gcd(a,b,x,y),a/=d,b/=d; for(i=0;i&lt;5;i++) {//枚举 if((c+i)%d) continue;//有没有解 res=((x*(c+i)/d%b)+b)%b;//得出最小正整数x res=res*5*p+5*q-i;//得出天数 if(~ans) cmin(ans,res); else ans=res; } if(~ans) printf(&quot;%lld\\n&quot;,ans); else printf(&quot;Orz mgh!!!\\n&quot;); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"},{"name":"扩展欧几里得","slug":"扩展欧几里得","permalink":"http://hovnySiLenCe.github.io/tags/扩展欧几里得/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「SP17247」PR003004 - Digit Sum 解题报告","slug":"SP17247-PR003004_DigitSum-Solution","date":"2019-12-05T06:27:23.000Z","updated":"2019-12-05T06:54:35.408Z","comments":true,"path":"2019/12/05/SP17247-PR003004_DigitSum-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/12/05/SP17247-PR003004_DigitSum-Solution/","excerpt":"","text":"题面解题思路数位 $DP$ 分析关于数的相关计算，很容易使人想到数位 $DP$，直接记搜即可 如何 $DP$？ 众所周知，这里我们只要先把每个数拆成几个数字，然后 $dfs$ 的时候记录 $k,st,op$，分别表示当前是从最低位开始的第 $k$ 位，$st$ 表示当前已枚举的前几位的和，$op$ 表示是否前几位是否达到上界，开数组记忆化即可 Warning1、传值的时候注意 $long\\ long$ 2、注意数组 $st$ 那维的大小 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} int num[19],t,nm,T; LL f[19][191][2],l,r; inline LL dfs(rint k,rint st,rint op) { if(!k) return st; if(~f[k][st][op]) return f[k][st][op]; rint i,t=op?num[k]:9;rll res=0; for(i=0;i&lt;=t;i++) res+=dfs(k-1,st+i,op&amp;(i==t)); return f[k][st][op]=res; } inline LL solve(rll c) { t=0;while(c) num[++t]=c%10,c/=10; memset(f,-1,sizeof(f));//记得初始化为0 return dfs(t,0,1); } int main() { scanf(&quot;%d&quot;,&amp;T); while(T--) scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r),l=max(l-1,0ll),//不能为-1 printf(&quot;%lld\\n&quot;,solve(r)-solve(l));//差分 return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"},{"name":"数位DP","slug":"数位DP","permalink":"http://hovnySiLenCe.github.io/tags/数位DP/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「NowCoder51271」Katu Puzzle 解题报告","slug":"NowCoder51271-Katu_Puzzle-Solution","date":"2019-11-28T07:17:23.000Z","updated":"2019-11-28T13:34:55.075Z","comments":true,"path":"2019/11/28/NowCoder51271-Katu_Puzzle-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/28/NowCoder51271-Katu_Puzzle-Solution/","excerpt":"","text":"题面有 $N(1\\le N \\le 1000)$ 个变量 $X_{1\\cdots N}$，每个变量的可能取值是 $0$ 或 $1$，现有 $M(1\\le M\\le 10^6)$ 个限制条件，每个条件的形式为： X_i\\ op \\ X_j=c,c\\in \\{0,1\\},op\\in\\{and,or,xor\\}求是否有合法的方案，使所有条件成立，输出 YES 或 NO 解题思路$2-SAT\\&amp;SCC$ 分析每个变量只有两种选择，明显是一个 $2-SAT$ 问题模板，考虑如何建图 对于每种 $op$ 分情况讨论： $x\\ and\\ y=0$考虑什么时候需要限制，显然，当 $x,y$ 两者有一个为 $1$ 时，另一个必为 $0$因此建立有向边：$x+n\\to y,y+n\\to x$ $x\\ and\\ y=1$仍然考虑什么时候需要限制，显然，$x,y$ 都必须为 $1$，也就是 $x,y$ 都不能为 $0$直接让两者同时不满足即可，因此建有向边：$x\\to x+n,y\\to y+n$，显然 $x,y$ 为 $0$ 时，上述条件无法满足 $x \\ or \\ y=0$$x,y$ 都必须为 $0$，与情况 2 类似，建有向边：$x+n\\to x,y+n\\to y$ $x\\ or\\ y=1$与 1 类似，建立有向边：$x\\to y+n,y\\to x+n$ $x\\ xor\\ y=0$$x,y$ 的值必须相同，建有向边：$x\\to y,y\\to x,x+n\\to y+n,y+n\\to x+n$ $x\\ xor\\ y=1$$x,y$ 的值必须不同，建有向边：$x\\to y+n,y\\to x+n,y+n\\to x,x+n\\to y$ 总结即为： $x\\ and\\ y=0$$x+n\\to y,y+n\\to x$ $x\\ and\\ y=1$$x\\to x+n,y\\to y+n$ $x \\ or \\ y=0$$x+n\\to x,y+n\\to y$ $x\\ or\\ y=1$$x\\to y+n,y\\to x+n$ $x\\ xor\\ y=0$$x\\to y,y\\to x,x+n\\to y+n,y+n\\to x+n$ $x\\ xor\\ y=1$$x\\to y+n,y\\to x+n,y+n\\to x,x+n\\to y$ 之后用 $tarjan$ 求出 $SCC$ 判断是否存在 $i$，使得 $i,i+n$ 在同一个强连通分量内即可 Warning1、边的数量上限为条件数的四倍 2、变量的下标从 $0$ 开始 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define M 1000003 #define N 1003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline char getc() {//读个操作，个人爱好而已 rgt char c=getchar(); while(c&lt;&#39;A&#39;||c&gt;&#39;Z&#39;) c=getchar(); return c; } int head[N&lt;&lt;1],ver[M&lt;&lt;2],nxt[M&lt;&lt;2],t,n,m,res;//边开四倍 int dfn[N&lt;&lt;1],low[N&lt;&lt;1],bl[N&lt;&lt;1],St[N&lt;&lt;1],top,num;//其余开两倍 inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t; } inline void tarjan(rint k) { rint i,to; dfn[k]=low[k]=++num,St[++top]=k; for(i=head[k];i;i=nxt[i]) { to=ver[i]; if(!dfn[to]) tarjan(to),cmin(low[k],low[to]); else if(!bl[to]) cmin(low[k],dfn[to]); } if(dfn[k]==low[k]) { bl[k]=++res; while(St[top]!=k) bl[St[top--]]=res; --top; } } int main() { rint i,x,y,c;char op; n=read(),m=read(); for(i=1;i&lt;=m;i++) { x=read()+1,y=read()+1,//下标+1，不加影响不大（个人喜好 c=read(),op=getc(); if(op==&#39;A&#39;) {//分情况加边 if(c) add(x,x+n),add(y,y+n); else add(x+n,y),add(y+n,x); } else if(op==&#39;O&#39;) { if(c) add(x,y+n),add(y,x+n); else add(x+n,x),add(y+n,y); } else { if(c) add(x,y+n),add(y,x+n),add(x+n,y),add(y+n,x); else add(x,y),add(y,x),add(x+n,y+n),add(y+n,x+n); } } for(i=1;i&lt;=(n&lt;&lt;1);i++) if(!dfn[i]) tarjan(i); for(i=1;i&lt;=n;i++) if(bl[i]==bl[i+n]) {//在同一个强连通分量内就无解 printf(&quot;NO&quot;);return 0; } printf(&quot;YES&quot;); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://hovnySiLenCe.github.io/tags/2-SAT/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3825」[NOI2017]游戏 解题报告","slug":"Luogu_P3825-[NOI2017]Game-Solution","date":"2019-11-22T14:28:17.000Z","updated":"2019-12-01T07:28:27.640Z","comments":true,"path":"2019/11/22/Luogu_P3825-[NOI2017]Game-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/22/Luogu_P3825-[NOI2017]Game-Solution/","excerpt":"","text":"题面$2-SAT$ 问题的相关应用 解题思路$2-SAT+SCC$ 分析由于条件限制，每场比赛只能由两种车参加，因此就能把三种车型缩成两种，比如，当前的地图类型为 $a$，那么只用 $B$ 和 $C$ 类型车能使用，这样就能把三种状态缩成两种状态，用 $2-SAT$ 解决即可 考虑如何处理 $x$ 类型地图由于 $x$ 类型地图的数量很少，最多只有 $8$ 个，因此可以考虑枚举 $x$ 类地图的状态，即可以将 $x$ 类型地图看做其他类型的地图，但这样的复杂度是 $O(3^8(n+m))$，稳 $T$。不过不难发现，将 $x$ 类地图看做 $a$ 类地图时，$B$ 和 $C$ 车能在该地图上使用，将 $x$ 类地图看做 $b$ 类地图时，$A$ 和 $C$ 车能在该地图上使用，这样三种车都出现过了，因此枚举三种状态是无必要的，只要枚举两种状态即可，这样复杂度就降至了 $O(2^8(n+m))$ 考虑如何建图对于每个限制，当然要判断这种限制是否合法，比如如下样例： 10 0 abbbacabab 20 5 A 3 B 9 A 4 C 4 C 10 A 8 B 3 C 6 C 10 A 5 A 9 C 8 A 2 C 5 A 8 B 10 A 10 A 5 B 4 B 6 C 10 C 2 C 4 B 5 C 7 B 5 A 10 B 3 A 7 B 6 B 4 B 3 C 8 B 1 B 3 B 4 B 3 C 8 A 2 A CAAACABCBA 对于上述第 $13$ 行的限制，当第 $5$ 场比赛使用 $B$ 类车时，第 $4$ 场比赛必须用 $B$ 类车，显然对于第 $4$ 场比赛，这是不合法的，但是这个条件仍然是有约束力的，即造成第 $5$ 场比赛不能使用 $B$ 类车，那么如何建图维护这种约束呢？ 显然，我们只需要连一条 $5B$ 向 $5C$ 的单向边即可，这样就表明如果取 $5B$ 那么一定要取 $5C$ ，明显是不合法的，最后输出方案的时候就不会输出 $5B$ 也有可能形如上述第 $4$ 行的限制，这种限制由于没有 $5A$ 这个节点，也连不出边，直接舍弃即可 其他一般情况下，由于限制类型是 x_p \\ and \\ y_q，因此一方面要建 x_p \\to y_q 的边，同时也要建 y_{1-q} \\to x_{1-p} 的边 Warning1、上述的两种情况 2、数组大小 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define M 100007 #define N 50003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline int getc() { rgt char c=getchar(); while(c&lt;&#39;A&#39;||c&gt;&#39;Z&#39;) c=getchar(); return (c-&#39;A&#39;); } struct node{ int x,y,vx,vy; inline void in() {x=read(),vx=getc(),y=read(),vy=getc();} }b[M]; int head[N&lt;&lt;1],ver[M&lt;&lt;1],nxt[M&lt;&lt;1],n,m,t,d,num,ans,p[11]; int dfn[N&lt;&lt;1],low[N&lt;&lt;1],St[N&lt;&lt;1],bl[N&lt;&lt;1],res,top,D; char s[N]; inline void add(rint x,rint y) {//建单向边 ver[++t]=y,nxt[t]=head[x],head[x]=t; } inline void tarjan(rint k) {//求SCC rint i,to; dfn[k]=low[k]=++num,St[++top]=k; for(i=head[k];i;i=nxt[i]) { to=ver[i]; if(!dfn[to]) tarjan(to),cmin(low[k],low[to]); else if(!bl[to]) cmin(low[k],dfn[to]); } if(dfn[k]==low[k]) { bl[k]=++res; while(St[top]!=k) bl[St[top--]]=res; --top; } } int main() { rint i,j,x,y,vx,vy; n=read(),d=read(),scanf(&quot;%s&quot;,s+1),m=read(); for(i=1;i&lt;=m;i++) b[i].in();D=1&lt;&lt;d; for(i=1;i&lt;=n;i++) if(s[i]==&#39;x&#39;) p[t++]=i; for(j=0;j&lt;D;j++) {//枚举x图状态 for(t=0;t&lt;d;++t) s[p[t]]=(j&gt;&gt;t)&amp;1?&#39;a&#39;:&#39;b&#39;;//更新状态 t=num=res=0,ans=1; memset(bl,0,(n+1)&lt;&lt;3), memset(dfn,0,(n+1)&lt;&lt;3), memset(head,0,(n+1)&lt;&lt;3);//初始化 for(i=1;i&lt;=m;i++) { x=b[i].x,y=b[i].y; if(b[i].vx==s[x]-&#39;a&#39;) continue;//无用的限制 if(s[x]==&#39;c&#39;) vx=b[i].vx&gt;0; else vx=b[i].vx&gt;1; if(b[i].vy==s[y]-&#39;a&#39;) add(x+vx*n,x+(vx^1)*n);//一个点不能取的限制 else {//一般情况 if(s[y]==&#39;c&#39;) vy=b[i].vy&gt;0; else vy=b[i].vy&gt;1; add(x+vx*n,y+vy*n), add(y+(vy^1)*n,x+(vx^1)*n); } } for(i=1;i&lt;=(n&lt;&lt;1);i++) if(!dfn[i]) tarjan(i); for(i=1;i&lt;=n;i++) if(bl[i]==bl[i+n]) {ans=0;break;} if(ans) { for(i=1;i&lt;=n;i++) { x=bl[i]&lt;bl[i+n];//小的先选肯定是最优的 if(s[i]==&#39;a&#39;) printf(&quot;%c&quot;,x?&#39;B&#39;:&#39;C&#39;); else if(s[i]==&#39;b&#39;) printf(&quot;%c&quot;,x?&#39;A&#39;:&#39;C&#39;); else printf(&quot;%c&quot;,x?&#39;A&#39;:&#39;B&#39;);//分情况讨论 } return 0; } } printf(&quot;-1&quot;); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://hovnySiLenCe.github.io/tags/2-SAT/"},{"name":"缩点","slug":"缩点","permalink":"http://hovnySiLenCe.github.io/tags/缩点/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「某讲稿」 2-SAT 学习笔记","slug":"LectureNotes-2-SAT-Notes","date":"2019-11-21T08:27:23.000Z","updated":"2019-12-01T07:33:27.241Z","comments":true,"path":"2019/11/21/LectureNotes-2-SAT-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/21/LectureNotes-2-SAT-Notes/","excerpt":"","text":"写在前面好孩纸写学习笔记要有格式 题目引入就用 $2-SAT$ 模板趴，但其实感jio第二题更加经典 「Luogu P4782」【模板】2-SAT问题题目背景$2-SAT$ 问题 模板 题目描述有 $n$ 个布尔变量 $x_i$，另有 $m$ 个需要满足的条件，每个条件的形式都是 “$x_i$ 为 $true/false$ 或 $x_j$ 为 $true/false$ “。比如 “$x_1$ 为 $ture$ 或 $x_3$ 为 $false$ “、”$x_7$ 为 $false$ 或 $x_2$ 为 $false$”。$2-SAT$ 问题的目标是给每个变量赋值使得所有条件得到满足。 输入格式第一行两个整数 $n$ 和 $m$，意义如体面所述。 接下来 $m$ 行每行 $4$ 个整数 $i\\ a\\ j\\ b$，表示 “$x_i$ 为 $a$ 或 $x_j$ 为 $b$”$(a,b\\in {0,1})$ 输出格式如无解，输出 IMPOSSIBLE； 否则输出 POSSIBLE，下 一行 $n$ 个整数 $x_i(x_i\\in {0,1})$，表示构造出的解。 输入输出样例输入样例 #1：3 1 1 1 3 0 输出样例 #1：POSSIBLE 0 0 0 说明/提示$1\\le n,m\\le1e6$，前 $3$ 个点卡小错误，后面 $5$ 个点卡效率，由于数据随机生成，可能会含有 10 0 10 0 之类的坑 「NowCoder51271」 Katu Puzzle题目描述 Katu Puzzle is presented as a directed graph G(V, E) with each edge e(a, b) labeled by a boolean operator op (one of AND, OR, XOR) and an integer $c (0 \\leq c \\leq 1)$. One Katu is solvable if one can find each vertex Vi a value $X_i (0 ≤ X_i ≤ 1)$ such that for each edge e(a, b) labeled by op and c, the following formula holds: $X_a\\ op\\ X_b = c$ The calculating rules are: Given a Katu Puzzle, your task is to determine whether it is solvable. 输入格式The first line contains two integers $N (1 \\leq N \\leq 1000)$ and $M(0 \\leq M \\leq 1,000,000)$, indicating the number of vertices and edges.The following M lines contain three integers $a (0 \\leq a \\lt N)$, $b(0 \\leq b \\lt N)$, $c$ and an operator op each, describing the edges. 输出格式Output a line containing YES or NO. 输入输出样例输入样例 #1：4 4 0 1 1 AND 1 2 1 OR 3 2 0 AND 3 0 0 XOR 输出样例 #1：YES //此行纯粹是为了行号 说明/提示$X_0 = 1, X_1 = 1, X_2 = 0$. 正文$SAT$ 是 $satisfiability$ 的缩写，是一类适应性问题的简称，一般形式为 $k-$适应性问题，简称 $k-SAT$ $2-SAT$ 是 $k-SAT$ 的一种情况，因为当 $k&gt;2$ 时 $k-SAT$ 问题是 $NP$ 问题，所以…… 像上述题目一样，$2-SAT$ 形式一般为：给出 $n$ 个变量，以及 $m$ 个限制条件，每个限制条件形如 $(not)a_i\\ op\\ (not)a_j=0/1$，求是否存在对 $n$ 个变量的合法赋值方案，使 $m$ 个条件均得到满足。其中 $a_i,a_j\\in {0,1}$，$op$ 可以是 $or,and,xor$ 等，也就是 $bool$ 类型运算，除了上述的类型外，貌似其他的不是很常见 判定方法$2-SAT$ 问题的判定方法如下： 1、建立 $2n$ 个节点的有向图，每个变量的 $a_i$ 对应 $2$ 个节点，一般设为 $i$ 和 $i+n$ 2、考虑每个条件，形如 “若 $a_i$ 为 $p$ 则 $a_j$ 必须为 $q$”，$p,q\\in {0,1}$。建立 $i+p\\times n \\to j+q\\times n$ 的单向边。当然，要注意的是，上述条件蕴含着它的逆否命题 “若 $a_j$ 为 $1-q$ 则 $a_i$ 必须为 $1-p$”，因此在建图的时候还应该建立 $j+(1-q)\\times n\\to i+(1-p)\\times n$ 的单向边，也就是说，点数和边数都应是变量数和条件数的两倍，开数组，初始化的时候应特别注意 3、这个时候我们就可以用 $tarjan$算法求出有向图中所有的强连通分量 4、若存在 $i\\in [1,n]$，满足 $i$ 和 $i+n$ 属于同一个强连通分量，则表明：若 $a_i$ 赋值为 $p$，则 $a_i$ 必须赋值为 $1-p$，显然矛盾，说明问题无解。否则题目一定有解。 时间复杂度 $O(n+m)$ 来康个栗子 3 2 1 1 3 0 2 1 3 1 根据上述方法建图，可得： 不存在 $i,i+n$ 属于同一个强连通分量里，因此一定有解 而下图则由于存在 $i,i+n$ 属于同一个强连通分量而无解 合法方案以下图为例 在 $tarjan$ 得出每个强连通分量的基础上，考虑如何构造合法方案 显然，在一个 $SCC$ 中，如果有一个变量确定了，那么它之后的一系列变量的值也确定了，因此我们可以考虑缩点来做。又因为，互为 “逆否命题”的有向边在图中成对出现，也就是说如果一个点的入度为 $0$，那么其对立点的出度即为 $0$，显然选择入度为 $0$ 的点会使其对立点被选，而选出度为 $0$ 的点则不会产生这种影响，如上图 $3,6$ 互为对立点，选 $6$ 不行，但是选 $3$ 满足 于是我们就可以缩点后建出反图，其中反图中的一个点即为原图的一个 $SCC$，然后我们在反图上执行拓扑排序即可，也就是说我们想要得到的是缩点后图的拓扑序的反序，具体实现留与读者自行思考，这里不做详细分析 考虑如何优化，不难发现，在 $tarjan​$ 求 $SCC​$ 的时候，由于 $tarjan​$ 是递归进行的，最先得出的 $SCC​$ 肯定是出度为 $0​$ 的，第二出度再其次，其实已经很像或者说 就是用递归求出了拓扑序的反序，即联通块的编号的顺序就是缩点后图的反序，直接根据联通块的编号判断贪心的取即可 对于点 $i$ 和 $i+n$，如果 $bl[i]\\lt bl[i+n]$，也就是说 $i$ 所在的 $SCC$ 编号小于 $i+n$，此时取 $i$，否则取 $i+n$ 例题选讲「Luogu P4782」【模板】2-SAT问题由于或的性质，只要在一侧不满足的情况下向另一侧满足的情况连接有向边表示限制即可 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 1000003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int head[N&lt;&lt;1],ver[N&lt;&lt;1],nxt[N&lt;&lt;1],n,m,t,num; int bl[N&lt;&lt;1],St[N&lt;&lt;1],top,dfn[N&lt;&lt;1],low[N&lt;&lt;1],res; bool vis[N],w[N]; inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t; } inline void tarjan(rint k) { rint i,to; dfn[k]=low[k]=++num,St[++top]=k; for(i=head[k];i;i=nxt[i]) { to=ver[i]; if(!dfn[to]) tarjan(to),cmin(low[k],low[to]); else if(!bl[to]) cmin(low[k],dfn[to]); } if(dfn[k]==low[k]) { bl[k]=++res; while(St[top]!=k) bl[St[top]]=res,--top; --top; } } inline void dfs(rint k) { rint i,to; if(k&gt;n) vis[k-n]=1,w[k-n]=1; else vis[k]=1; for(i=head[k];i;i=nxt[i]) { to=ver[i]&gt;n?ver[i]-n:ver[i]; if(!vis[to]) dfs(ver[i]); } } int main() { rint i,x,y,vx,vy; n=read(),m=read(); for(i=1;i&lt;=m;i++) { x=read(),vx=read(), y=read(),vy=read(), add(y+(vy^1)*n,x+vx*n),//一侧命题为假时向另一侧命题为真连边表示限制 add(x+(vx^1)*n,y+vy*n); } for(i=1;i&lt;=(n&lt;&lt;1);i++) if(!dfn[i]) tarjan(i); for(i=1;i&lt;=n;i++) if(bl[i]==bl[i+n]) { printf(&quot;IMPOSSIBLE&quot;);//无解 return 0; } printf(&quot;POSSIBLE\\n&quot;); for(i=1;i&lt;=n;i++) printf(&quot;%d &quot;,bl[i]&gt;bl[i+n]);//根据反序或者说SCC编号 return 0; } 「NowCoder51271」 Katu Puzzle$Solution’s\\ Link$ 推荐题目类似于模板 Luogu P4171 [JSOI2010]满汉全席NowCoder51346 Priest John’s Busiest Day","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://hovnySiLenCe.github.io/tags/2-SAT/"},{"name":"缩点","slug":"缩点","permalink":"http://hovnySiLenCe.github.io/tags/缩点/"},{"name":"SCC","slug":"SCC","permalink":"http://hovnySiLenCe.github.io/tags/SCC/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CSP2019游记」","slug":"CSP2019-Travel-Notes","date":"2019-11-16T13:55:14.000Z","updated":"2019-11-17T08:25:49.226Z","comments":true,"path":"2019/11/16/CSP2019-Travel-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/16/CSP2019-Travel-Notes/","excerpt":"","text":"或许这才是开始 Day0今天在酒店入住了。晚上和 $louhc$ 一起吃了个锅，回酒店稍微娱乐了一下，稍稍写点游记，准备睡了 Day1深深地明白自己的弱小 早上 $5:44$ 就自然醒了，感觉有点紧张，仍然有点困，又睡到 $6:53$ 下楼去吃早饭。话说早上的面味道还真的不是有点怪，冷热的东西都吃了居然还没事，感觉可能是自己 $RP++$ 了（多谢巨佬 坐公交车到学军，人是真的有点多，但是没多大在意，心里比较平淡。看了看考场还有厕所，这厕所真的是让人不敢恭维。看安装包下面，原本以为能用 $Sublime$ 的，结果安装包损坏，只好作罢 准备了一盒黑笔，一支蓝笔，一支红笔，还有一整包纸，自带的温水，感觉要做到万事具备了 解压文件的时候，和省选一样，忽略了最后的问号，错误了一次，不过心里没多大影响，反而笑了笑 $T1$ 相对还是比较轻松的，手玩了几组数据，然后就把细节写下来了，注意到了 $n\\le 64$，开了 $unsigned\\ long\\ long$，大概就半个小时过去了 $T2$ 看了题目之后还是比较有思路的，直接就打了个 $dfs$，维护了几个信息，结果第二个样例没过，有点小紧张，先写了个暴力，然后打了个对拍，对拍一时间找不出什么问题，就再思考了一下，发现是没有判 $AB$ 的情况，内心复杂，感觉有点难维护，思考了一下打了个栈，仍然没过，又发现是 $AB$ 是要连续的，维护了一个 $fa[k]$，$St[top]$ 表示成了位置，再对了一会拍，显示 $2000$ 的数据，看貌似没什么问题，又对了 $30000$ 的数据，一会没出现什么问题就扔了，现在想想有点小慌，都因为 $T3$ 我觉得 $T3$ 应该是我 $Day1$ 最大的败笔了吧。心里一直想着实现那个进冬令营的目标，对自己的压力竟有些大了，脑子一时间转不过来，想要把 $T3$ 正解想出来，想要 $Day1$ 拿 $300pts$，然后才有机会进任意冬令营。但是我似乎想头了，大概花了很久想这道题，半个小时里没什么思路，随便打了个 $n\\le10$ 的暴力，貌似常数有点大，样例 $T$ 了，然后就抱着再尝试一下的心理，继续想。到了还有大概 $35min$ 的时候，想出了一个比较正确的算法，就是维护比较复杂，而且复杂度貌似有问题，虽然跑不满，就是想的不是很周全，一会后又发现自己想法的一点缺陷，感觉就算想出来了也打不出来，放弃了。心里一直在纠结，是打暴力还是想正解，很犹豫，然后最后 $30min$ 又太紧张，暴力没有想出来，也没有打，感觉数据不会那么良心，心态爆炸，感觉别人都 $AK$ 了 $Day1$，只有一个实力不足的自己最多能拿 $200pts$，越想反而越紧张了，对 $10pts$ 也放弃了，而又心存侥幸地打了个很错误、没有丝毫依据的解法，纯粹是一种侥幸心理，真的感觉自己的心态很不好，放弃了，前两题没仔细查过，$T3$ 又没打暴力，很后悔 可能也是自己定的目标有点多且大了吧，甚至搞到自己在考场上都自卑了，出来问了一下，貌似 $T3$ 没有多少人想打出暴力，最多也就 $10pts$，$bzt$ 和 $louhc$ 多打了菊花图的情况，有 $35pts$，心态有点吃不消，才发现自己拿去年的成绩做对比是有多么蠢。深深地明白自己的弱小 $Day2$ 不知道能不能翻盘，加油了，为了自己的梦，发现其实自己也还不是那么成熟，有些情况甚至有点幼稚了，很无奈，应该更加客观一点，早睡了，但还是怕想太多… Day2深深地明白自己的弱小 什么都不多说了，只是感觉自己太弱了。真的 太弱了 或许曾经守着过去的荣耀，如今真的什么都没有了，深深地明白自己的弱小 昨天晚上还是和 $22:00$ 出头睡的，早上有很早醒来，感觉很紧张，仍然很困，洗了把脸，稍微清醒了一点，早饭没吃多少，不是很有胃口 公交没昨天准时，稍微等了一会才上，到了考场大概 $8:00$ 多了，吸取昨天的教训，准备好好打暴力 一开始有点着急，没去厕所，心态还是比较好的吧 看看了题目，定了个目标，$A$ 掉 $T1$，然后 $T2$、$T3$ 暴力拿满就有 $200pts$ 了，这样冬令营就稍微有点可能了，但貌似我又错了 $T1$ 先想了一会，然后开始打，一个小时左右发现自己的思路有问题，中断了，再想了半个小时，吸取教训，滚去打暴力了，一开始以为 $T3$ 比较简单，所以正着做会越来越容易，可是渐渐发现，$T1$ 没有想象中的好写，回想以前，貌似自己真的没有想过如果不会正解的情况，一道也不会的那种，怎么安排暴力的时间，于是自己就炸了。真的爆炸。 $T3$ 打了 $55pts$ 的暴力，没有继续往下想，因为不甘心 $T1$，或者说我仍然被去年的分数影响着，不够客观吧，考场上心情复杂，有点小小的贪心，想要拿更高的分数，结果发现自己是真的菜，心里还是存在一种不想打暴力的心理，不知道该怎么想出正解，不知道该怎么权衡暴力与正解，是自己太菜了，想不出来正解，却仍然如此执着于正解 $T3$ 其实感觉如果深入思考的话也是没有问题的，因为曾经在 $Luogu$ 上看到过类似的题，不过那题貌似是动态的，就是 一次合并两棵树维护重心，心想着把暴力拿满就好，就离梦想很近了。算上链的情况，大概用了 $40min$，链式手推的，因为感觉正解就是类似于链的情况，没打算拿满分就没有实现那种方法 $T2$ 拿了 $64pts$ 的部分分，感觉这道题也是原题改编，也在 $Luogu$ 上看到过类似的，只不过不要求单调上升而已，感觉自己太菜了，想拿 $88pts$ 的，可是又想不出来，很快就放弃了，以为 $T1$ 能写出来的 还有一个小时的时候，重新回去想 $T1$，有点想不出来，又放弃了，以为暴力拿满的话也应该挺不错的，想 $n\\le40$ 的暴力。暴力调了 $40min$ 吧，样例二没过，发现自己思路的漏洞，绝望了，心态爆炸。想放弃，但不甘心，匆匆打了四维的 $DP$，不敢测样例。结果最后 $5$ 分钟的时候，把四维 $DP$ 删了，以为那个错误的算法能拿更多的分，还随手加了点玄学的修改，应该是已经错的离谱了 $Day2$，真心态爆炸了，深深地感觉到自己的弱小 巨哥 $Day1\\ 200pts$，$Day2\\ 203pts$，应该稳了，还有 $louhc$，也比我高几十分，心态爆炸…… $CSP2019$ 就结束了，炸了，滚回去颓文化课……省一都不保了吧，谈什么冬令营，笑话…… 高中三年，从其他 $OIer$ 那里得知要有规划，而我只可能走两年的 $OI$ 路，如今一次已经废了，当在疯狂努力一年，下次吧，这样开始，不想还是以这样结束…… 深深地明白自己的弱小 $2019.11.17$ 于归程","categories":[{"name":"游记","slug":"游记","permalink":"http://hovnySiLenCe.github.io/categories/游记/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://hovnySiLenCe.github.io/tags/游记/"}],"keywords":[{"name":"游记","slug":"游记","permalink":"http://hovnySiLenCe.github.io/categories/游记/"}]},{"title":"「Luogu P5305」[GXOI/GZOI2019]旧词 解题报告","slug":"Luogu_P5305-[GXOIGZOI2019]OldWords-Solution","date":"2019-11-13T23:48:37.000Z","updated":"2019-12-01T07:28:11.524Z","comments":true,"path":"2019/11/14/Luogu_P5305-[GXOIGZOI2019]OldWords-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/14/Luogu_P5305-[GXOIGZOI2019]OldWords-Solution/","excerpt":"","text":"题面解题思路树链剖分+差分 分析这道题的基本思路和 $\\mathtt{Link}$ 相同，考虑如何维护 $k$ 次方，仍然按照同样的思路，既然是累加的和，那么我们就可以把这些数的 $k$ 次方差分，累加即可得到结果 warning注意差分顺序 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define p 998244353 #define N 50003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int i,val; node(int a,int b):i(a),val(b){} node(){} }cur; int head[N],ver[N&lt;&lt;1],nxt[N&lt;&lt;1],n,m,t,k,L,R,Ans[N]; int seg[N],top[N],rev[N],Ie[N],f[N&lt;&lt;2],num,sum[N&lt;&lt;2]; int dep[N],son[N],size[N],fa[N],tag[N&lt;&lt;2],ans,pos; queue&lt;node&gt;P[N]; inline int Pw(rll a) { rint b=k;rll res=1; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1) res=res*a%p; return res; } inline int dec(rint x){return(x&gt;=p)?x-p:x;} inline int rec(rint x){return(x&lt;0)?x+p:x;} inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t, ver[++t]=x,nxt[t]=head[y],head[y]=t; } inline void dfs1(rint k) { rint i,to; dep[k]=dep[fa[k]]+1,size[k]=1; for(i=head[k];i;i=nxt[i]) { to=ver[i];if(to==fa[k]) continue; fa[to]=k,dfs1(to),size[k]+=size[to]; if(size[to]&gt;size[son[k]]) son[k]=to; } } inline void dfs2(rint k) { if(son[k]) { seg[son[k]]=++num, top[son[k]]=top[k], rev[num]=son[k], dfs2(son[k]); } rint i,to; for(i=head[k];i;i=nxt[i]) { to=ver[i];if(top[to]) continue; seg[to]=++num, top[to]=rev[num]=to,dfs2(to); } } inline void built(rint k,rint l,rint r) { if(l==r){sum[k]=Ie[dep[rev[l]]];return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; built(ls,l,m),built(ls|1,m+1,r), sum[k]=dec(sum[ls]+sum[ls|1]); } inline void push(rint k,rint l,rint r) { f[k]=dec(f[k]+(LL)tag[k]*sum[k]%p); if(l!=r) { rint ls=k&lt;&lt;1; tag[ls]+=tag[k],tag[ls|1]+=tag[k]; }tag[k]=0; } inline void Modify(rint k,rint l,rint r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R){tag[k]=1;return push(k,l,r);} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,m),Modify(ls|1,m+1,r), f[k]=dec(f[ls]+f[ls|1]); } inline void Query(rint k,rint l,rint r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {ans=dec(ans+f[k]);return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Query(ls,l,m),Query(ls|1,m+1,r); } #define fx top[x] inline void Add(rint x) { while(fx!=1) { L=seg[fx],R=seg[x], Modify(1,1,n),x=fa[fx]; } L=1,R=seg[x],Modify(1,1,n); } inline int Ask(rint x) { ans=0; while(fx!=1) { L=seg[fx],R=seg[x], Query(1,1,n),x=fa[fx]; } L=1,R=seg[x],Query(1,1,n); return ans; } int main() { rint i,j; n=read(),m=read(),k=read(); for(i=n;i;i--) Ie[i]=Pw(i),Ie[i+1]=rec(Ie[i+1]-Ie[i]);//差分是i^k-(i-1)^k的值 for(i=2;i&lt;=n;i++) add(read(),i); for(i=1;i&lt;=m;i++) pos=read(),P[pos].push(node(i,read())); num=seg[1]=rev[1]=top[1]=1, dfs1(1),dfs2(1),built(1,1,n); for(i=1;i&lt;=n;i++) { Add(i); while(!P[i].empty()) { cur=P[i].front(),P[i].pop(), Ans[cur.i]=Ask(cur.val); } } for(i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,Ans[i]); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://hovnySiLenCe.github.io/tags/树链剖分/"},{"name":"离线","slug":"离线","permalink":"http://hovnySiLenCe.github.io/tags/离线/"},{"name":"差分","slug":"差分","permalink":"http://hovnySiLenCe.github.io/tags/差分/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「SP11470」TTM - To the moon 解题报告","slug":"SP11470-TTM_ToTheMoon-Solution","date":"2019-11-12T10:55:15.000Z","updated":"2019-12-01T07:28:10.252Z","comments":true,"path":"2019/11/12/SP11470-TTM_ToTheMoon-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/12/SP11470-TTM_ToTheMoon-Solution/","excerpt":"","text":"题面解题思路可持久化线段树 分析这里只是提供可持久化线段树的板子，思想和主席树类似，每次对 $\\log n$ 个点进行修改，这样就需要 $n\\log n$ 的空间，因此写成结构体，大小开成 $80n$ ，反正只要不 $MLE$ 往大了开就好 struct node{ int ls,rs; LL sum,tag; }T[N*160];//80应该也是正确的 warning要注意的地方是标记永久化，不仅要标记永久化，而且 $T[root].sum$ 的值也要做一定修改（比如 $root$ 这个区间完全包含修改区间的时候） Code#include&lt;bits/stdc++.h&gt;//大致上和主席树类似，emmm...貌似主席树就是可持久化线段树... #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline LL read() { rll s=0,p=0; rgt char c=getchar(); while(!isdigit(c)) p=(c==&#39;-&#39;),c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return p?-s:s; } inline void getc(char&amp;c) { c=getchar();while(c&lt;&#39;A&#39;||c&gt;&#39;Z&#39;) c=getchar(); } struct node{ int ls,rs; LL sum,tag; }T[N*160]; int n,m,L,R,t,res,a[N],root[N];LL w,ans; inline void built(rint k,rint l,rint r) { cmax(t,k); if(l==r) {T[k].sum=a[l];return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; built(T[k].ls=ls,l,m),built(T[k].rs=ls|1,m+1,r), T[k].sum=T[ls].sum+T[ls|1].sum; } inline void Modify(rint l,rint r,rint &amp;x,rint y) { if(r&lt;L||R&lt;l) return; x=++t,T[t]=T[y]; if(L&lt;=l&amp;&amp;r&lt;=R) {T[x].tag+=w;return;} T[t].sum+=w*(min(r,R)-max(l,L)+1);//划重点，标记永久化的影响 rint m=(l+r)&gt;&gt;1; Modify(l,m,T[x].ls,T[y].ls), Modify(m+1,r,T[x].rs,T[y].rs); } inline void push(rll tag,rint l,rint r) { ans+=(min(R,r)-max(L,l)+1)*tag; } inline void Query(rint l,rint r,rint root) { if(r&lt;L||R&lt;l) return; if(T[root].tag) push(T[root].tag,l,r);//划重点，标记永久化的影响 if(L&lt;=l&amp;&amp;r&lt;=R) {ans+=T[root].sum;return;} rint m=(l+r)&gt;&gt;1; Query(l,m,T[root].ls),Query(m+1,r,T[root].rs); } int main() { rint i;char op; n=read(),m=read(); for(i=1;i&lt;=n;i++) a[i]=read(); built(1,1,n),root[0]=1; while(m--) { getc(op); if(op==&#39;C&#39;) { L=read(),R=read(),w=read(),++res; Modify(1,n,root[res],root[res-1]); } else if(op==&#39;Q&#39;) ans=0,L=read(),R=read(),Query(1,n,root[res]),printf(&quot;%lld\\n&quot;,ans); else if(op==&#39;H&#39;) ans=0,L=read(),R=read(),Query(1,n,root[read()]),printf(&quot;%lld\\n&quot;,ans); else res=read(); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"可持久化线段树","slug":"可持久化线段树","permalink":"http://hovnySiLenCe.github.io/tags/可持久化线段树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4198」楼房重建 解题报告","slug":"Luogu_P4198-BuildingReconstruction-Solution","date":"2019-11-12T07:36:04.000Z","updated":"2019-12-01T07:28:25.588Z","comments":true,"path":"2019/11/12/Luogu_P4198-BuildingReconstruction-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/12/Luogu_P4198-BuildingReconstruction-Solution/","excerpt":"","text":"题面给出长度为 $n$ 的序列，$q$ 次修改，求每次修改首项固定的最长上升子序列长度，$n,q\\le 10^5$ 解题思路线段树（合并较难） 分析感觉有点像线段树，但是线段树维护的话，合并的时候貌似不能 $O(1)$，然后就放弃了 结果，正解合并就是 $\\log$ 的……深深地明白自己的弱小 这样子的话，就是可以给我们要维护的区间找一找相同点或者不同点，比如我们发现一开始的区间，如果有建筑，那么这个建筑是肯定要选的，换句话说，可以认为就是某个区间的左端点必须选，因为肯定是看得到第一幢建筑的，那么由于这个特殊性质处理起来比较麻烦，我们考虑能不能让所有区间都带上这个性质，思考之后可以发现，这样是可以的，而且经过这样的处理，就不用去管第一个点必须选的特殊性了 再考虑哪些信息有用，区间中的最大值 $fa[k]$ 是需要的，因为该区间中的合法序列肯定以该值结尾，当然还要一个 $f[k]$ 记录当前区间的最长序列的长度 考虑如何合并答案，$fa[k]$ 的合并较简单，$O(1)$ 转移即可（如果有不会的……，问题在于如何对 $f[k]$ 进行合并 先枚举几种情况， $fa[ls]\\ge fa[rs]$，左区间的最大值比右区间的大，右区间无贡献，故 f[k]=f[ls] $fa[ls]&lt;a[m+1]$，左区间的最大值小于右区间的左端点，右区间都有贡献，故 f[k]=f[ls]+f[rs] $a[m+1]\\le fa[ls]&lt; fa[rs]$，也就是两区间的序列有交叉的部分，此时要计算贡献，只能用 $\\log n$ 式递归查询 处理上述最后一种情况，即查询右区间中范围在 $fa[ls]$~$fa[rs]$ 的部分 最大限制不用管，肯定能满足，就考虑最小限制 $fa[ls]$，记为 $val$，考虑如何递归计算 若一个区间的最大值 $fa[k]\\le val$ ，那么这个区间没有贡献 return 0 若一个区间的左端点 $a[l]&gt;val$，那么整个区间都有贡献 return f[k] 若只有一个点，即递归边界，则 return a[l]&gt;val 上述情况都不满足，但若左区间的最大值 $fa[k]&gt;val$，说明有一部分贡献在左区间，递归左区间，加上右区间 return Query(ls,l,m)+f[k]-f[ls|1] (右区间很妙) 否则就说明贡献在右区间，递归右区间即可 return Query(ls|1,m+1,r) 如此一来，就可以在 $O(q\\log^2n)$ 复杂度内求解 warning1、$Updata$ 的递归边界一定要判 2、右区间可以由 f[k]-f[ls] 得，真的很妙 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,T,pos,f[N&lt;&lt;2]; double a[N],fa[N&lt;&lt;2],val; inline int Query(rint k,rint l,rint r) { if(fa[k]&lt;=val) return 0;//最大值小于val if(a[l]&gt;val) return f[k];//val小于左端点 if(l==r) return 0;//递归边界 rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; if(val&lt;fa[ls]) return Query(ls,l,m)+f[k]-f[ls];//val在左区间有贡献 return Query(ls|1,m+1,r);//在左区间无贡献 } inline void Modify(rint k,rint l,rint r) { if(l==r) {fa[k]=a[l],f[k]=(a[l]!=0);return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1,rs=ls|1; (pos&lt;=m)?Modify(ls,l,m):Modify(rs,m+1,r); if(fa[ls]&gt;=fa[rs]) fa[k]=fa[ls],f[k]=f[ls];//只有左区间有贡献 else { fa[k]=fa[rs]; if(fa[ls]&lt;a[m+1]) f[k]=f[ls]+f[rs];//左右区间贡献不重叠 else val=fa[ls],f[k]=f[ls]+Query(rs,m+1,r);//要递归求的部分 } } int main() { n=read(),T=read(); while(T--) { pos=read(),a[pos]=(double)read()/pos; Modify(1,1,n),printf(&quot;%d\\n&quot;,f[1]); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4211」[LNOI2014]LCA 解题报告","slug":"Luogu_P4211-[LNOI2014]LCA-Solution","date":"2019-11-11T23:25:15.000Z","updated":"2019-12-01T07:28:25.180Z","comments":true,"path":"2019/11/12/Luogu_P4211-[LNOI2014]LCA-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/12/Luogu_P4211-[LNOI2014]LCA-Solution/","excerpt":"","text":"题面一棵 $n(n\\le 5\\times 10^4)$ 个节点的树，$q(q\\le5\\times 10^4)$ 次询问，每次询问 $[l,r]$ 区间中所有点和 $z$ 的公共祖先的深度和，即： \\sum_{l\\le i\\le r}dep[LCA(i,z)]解题思路离线后用树剖+线段树维护 真的不要往 $Lca$ 那方面想，虽然貌似有巨佬那样切掉了 分析不难发现，一个点 $i$ 的深度可以用 $dis(i,root)+1$ 的表示，而两个点的 $Lca$ 到根节点的路径又是一致的，这样我们就可以把一个点到 $root$ 路径上的所有点权值 $+1$，这样是不是就可以表示一个点做出的贡献了。这样查询时，两点 $Lca$ 到根节点路径上的权值会被计算贡献，而其他的没有影响，这样就去除了 $Lca$ 的影响 然鹅现在是一个区间 $[l,r]$ 与节点 $z$ 的 $dep[Lca(i,z)]$ 之和。显然，如果能得出一个前缀答案的话，$[l,r]$ 的贡献即可表示为 $ans(r)-ans(l-1)$，能大大降低复杂度，因此我们可以按 $id$ 的顺序修改点到 $root$ 的路径的权值，对于询问则把每个询问拆成两个点，离线处理即可 更新某点到 $root$ 路径上点的权值可以用树链剖分维护，时间复杂度 $O(n\\log^2n)$，加之树链剖分优秀的常数，这道题就很显然了 warning由于题中需要取模，因此 $ans(r)-ans(l-1)$ 的值可能为负数 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define N 50003 using namespace std; const int p=201314; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int op,pos,val; node(int a,int b,int c):op(a),pos(b),val(c){} node(){} }cur; int head[N],n,m,t,ver[N],nxt[N],num,ans; int seg[N],rev[N],top[N],f[N&lt;&lt;2],tag[N&lt;&lt;2]; int deep[N],size[N],son[N],fa[N],L,R,Ans[N]; queue&lt;node&gt;P[N]; inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t; } inline int dec(rint x){return(x&gt;=p)?x-p:x;} inline int rec(rint x){return(x&lt;0)?x+p:x;} inline void dfs1(rint k) { rint i,to; deep[k]=deep[fa[k]]+1,size[k]=1; for(i=head[k];i;i=nxt[i]) { to=ver[i],fa[to]=k,dfs1(to), size[k]+=size[to]; if(size[to]&gt;size[son[k]]) son[k]=to; } } inline void dfs2(rint k) { if(son[k]) { seg[son[k]]=++num, top[son[k]]=top[k], rev[num]=son[k], dfs2(son[k]); } rint i,to; for(i=head[k];i;i=nxt[i]) { to=ver[i];if(top[to]) continue; seg[to]=++num,top[to]=rev[num]=to,dfs2(to); } } inline void push(rint k,rint l,rint r) { f[k]=(f[k]+(LL)(r-l+1)*tag[k])%p; if(l!=r) { rint ls=k&lt;&lt;1; tag[ls]+=tag[k],tag[ls|1]+=tag[k]; }tag[k]=0; } inline void Modify(rint k,rint l,rint r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {tag[k]=1;return push(k,l,r);} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,m),Modify(ls|1,m+1,r); f[k]=dec(f[ls]+f[ls|1]); } inline void Query(rint k,rint l,rint r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {ans=(ans+f[k])%p;return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Query(ls,l,m),Query(ls|1,m+1,r); } #define fx top[x] inline void Add(rint x) { while(fx!=1) { L=seg[fx],R=seg[x], Modify(1,1,n),x=fa[fx]; } L=1,R=seg[x],Modify(1,1,n); } inline int Ask(rint x) { ans=0; while(fx!=1) { L=seg[fx],R=seg[x], Query(1,1,n),x=fa[fx]; } L=1,R=seg[x],Query(1,1,n); return ans; } int main() { rint i,l,r,op,pos,val; n=read(),m=read(); for(i=2;i&lt;=n;i++) add(read()+1,i); for(i=1;i&lt;=m;i++) { l=read(),r=read()+1,val=read()+1; P[l].push(node(0,i,val)),//每个询问拆成两个 P[r].push(node(1,i,val)); } num=seg[1]=rev[1]=top[1]=1,dfs1(1),dfs2(1);//树剖 for(i=1;i&lt;=n;i++) { Add(i);//第i个点的贡献 while(!P[i].empty()) { cur=P[i].front(),P[i].pop(); op=cur.op,pos=cur.pos,val=cur.val; if(op) Ans[pos]+=Ask(val);//按照左右端点，计算贡献 else Ans[pos]-=Ask(val); } } for(i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,rec(Ans[i]));//注意可能为负数 return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://hovnySiLenCe.github.io/tags/树链剖分/"},{"name":"离线","slug":"离线","permalink":"http://hovnySiLenCe.github.io/tags/离线/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P5304」[GXOI/GZOI2019]旅行者 解题报告","slug":"Luogu_P5304-[GXOIGZOI]Traveler-Solution","date":"2019-11-11T11:31:41.000Z","updated":"2019-12-01T07:28:11.972Z","comments":true,"path":"2019/11/11/Luogu_P5304-[GXOIGZOI]Traveler-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/11/Luogu_P5304-[GXOIGZOI]Traveler-Solution/","excerpt":"","text":"题面解题思路两遍Dijkstra染色 说几句闲话最近几天状态不是很好，想题目也没什么思路，深深地明白自己的弱小 分析 $O(n\\log^2n)$ 算法 由于距离最近的点之间，二进制肯定有一位不同，因此我们可以把点按照二进制位为 $1/0$ 分成两组，然后做 $\\log k$ 次多源多汇最短路即可，这样的时间复杂度为 $O(n\\log^2n)$ $O(n\\log n)$ 算法 个人认为这种算法前面的更加好想，但是没有上者来的妙，这种算法的思路是，枚举最短路经过的点，那么我们需要预处理离这条边两端最近的点，这个用两遍 $Dijkstra$，一遍建正边，一遍建反边，然后记录离每个点最近的感兴趣的城市用于之后判断即可 Code$O(n\\log^2n)\\ version:$ #include&lt;bits/stdc++.h&gt; #define getchar() *(pos++) #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define M 500003 #define N 100003 using namespace std; char bf[1&lt;&lt;25],*pos=bf; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct Edge{ int to,nxt,cost; Edge(int a,int b,int c):to(a),nxt(b),cost(c){} Edge(){} }b[M]; struct node{ int p;LL cost; node(int a,rll b):p(a),cost(b){} node(){} inline bool operator&lt; (const node x) const{ return cost&gt;x.cost; } }; int head[N],n,m,T,t,K,a[N],num,E[N]; LL d[N],ans;bool vis[N]; inline void add(rint x,rint y,rint cost) { b[++t]=Edge(y,head[x],cost),head[x]=t; } inline void DS() { rint i,to,cur;rll cost; priority_queue&lt;node&gt;p; memset(vis,0,n+1), memset(d,inf,(n+1)&lt;&lt;3); for(i=1;i&lt;=K;i++) if(E[a[i]]-1) p.push(node(a[i],0)),d[a[i]]=0; while(!p.empty()) { cur=p.top().p,p.pop(); if(E[cur]==1) return cmin(ans,d[cur]),void(); if(vis[cur]) continue;vis[cur]=1; for(i=head[cur];i;i=b[i].nxt) { to=b[i].to,cost=b[i].cost+d[cur]; if(d[to]&gt;cost) d[to]=cost,p.push(node(to,cost)); } } } inline void DE() { rint i,to,cur;rll cost; priority_queue&lt;node&gt;p; memset(vis,0,n+1), memset(d,inf,(n+2)&lt;&lt;3); for(i=1;i&lt;=K;i++) if(E[a[i]]==1) p.push(node(a[i],0)),d[a[i]]=0; while(!p.empty()) { cur=p.top().p,p.pop(); if(E[cur]==2) return cmin(ans,d[cur]),void(); if(vis[cur]) continue;vis[cur]=1; for(i=head[cur];i;i=b[i].nxt) { to=b[i].to,cost=b[i].cost+d[cur]; if(d[to]&gt;cost) d[to]=cost,p.push(node(to,cost)); } } } int main() { bf[fread(bf,1,1&lt;&lt;25,stdin)]=&#39;\\0&#39;; rint i,x,y,cost,c;T=read(); while(T--) { n=read(),m=read(),K=read(), t=0,ans=1e16,memset(head,0,(n+1)&lt;&lt;2); for(i=1;i&lt;=m;i++) { x=read(),y=read(),cost=read(); if(x==y) continue; add(x,y,cost); } for(i=1;i&lt;=K;i++) a[i]=read(); for(c=1;c&lt;=K;c&lt;&lt;=1) {//每位做一个多源多汇最短路 num=K; for(i=1;i&lt;=K;i++) if(i&amp;c) E[a[i]]=1,--num; else E[a[i]]=2; if(0&lt;num&amp;&amp;num&lt;K) DS(),DE(); }memset(E,0,(n+1)&lt;&lt;2); printf(&quot;%lld\\n&quot;,ans); } } $O(n\\log n)\\ version:$ #include&lt;bits/stdc++.h&gt; #define getchar() *(pos++) #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x3f3f3f3f #define M 500003 #define N 100003 using namespace std; char bf[1&lt;&lt;25],*pos=bf; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct RealEdge{ int x,y,cost; }E[M]; struct Edge{ int to,nxt,cost; Edge(int a,int b,int c):to(a),nxt(b),cost(c){} Edge(){} }b[M]; struct node{ int p;LL cost; node(int a,rll b):p(a),cost(b){} inline bool operator&lt; (const node x) const{ return cost&gt;x.cost; } }; int head[N],T,t,n,m,k,res,a[N],bl[2][N]; LL d[2][N],ans;bool vis[N]; inline void add(rint x,rint y,rint cost) { b[++t]=Edge(y,head[x],cost),head[x]=t; } inline void Dijkstra(rll *d,rint *bl) { rint i,to,c;rll cost; priority_queue&lt;node&gt;p; memset(d,inf,(n+1)&lt;&lt;3), memset(vis,0,n+1); for(i=1;i&lt;=k;i++) p.push(node(a[i],0)),d[a[i]]=0,bl[a[i]]=a[i]; while(!p.empty()) { c=p.top().p,p.pop(); if(vis[c]) continue;vis[c]=1; for(i=head[c];i;i=b[i].nxt) { to=b[i].to,cost=d[c]+b[i].cost; if(d[to]&gt;cost)//染色，即记录有哪个感兴趣的城市更新而来 d[to]=cost,bl[to]=bl[c],p.push(node(to,cost)); } } } int main() { bf[fread(bf,1,1&lt;&lt;25,stdin)]=&#39;\\0&#39;; rint i,x,y,cost;T=read(); while(T--) { n=read(),m=read(),k=read(),ans=1e16, res=t=0,memset(head,0,(n+1)&lt;&lt;2); for(i=1;i&lt;=m;i++) { x=read(),y=read(),cost=read(); if(x==y) continue;add(x,y,cost); E[++res].x=x,E[res].y=y,E[res].cost=cost; } for(i=1;i&lt;=k;i++) a[i]=read(); Dijkstra(d[0],bl[0]);//跑正向多源最短路 memset(head,0,(n+1)&lt;&lt;2),t=0; for(i=1;i&lt;=res;i++) add(E[i].y,E[i].x,E[i].cost); Dijkstra(d[1],bl[1]);//反向 for(i=1;i&lt;=res;i++) { x=E[i].x,y=E[i].y,cost=E[i].cost;//最后判断一下即可 if(bl[0][x]!=bl[1][y]) cmin(ans,d[0][x]+d[1][y]+cost); }printf(&quot;%lld\\n&quot;,ans); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://hovnySiLenCe.github.io/tags/Dijkstra/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「UVA12716」GCD等于XOR GCD XOR 解题报告","slug":"UVa12716-GCDEqualToXOR_GCD_XOR-Solution","date":"2019-11-10T11:40:25.000Z","updated":"2019-12-19T12:43:19.934Z","comments":true,"path":"2019/11/10/UVa12716-GCDEqualToXOR_GCD_XOR-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/10/UVa12716-GCDEqualToXOR_GCD_XOR-Solution/","excerpt":"","text":"题面求范围 $n$ 以内，XOR $=$ GCD 的数的对数，$n\\in [1,3\\times 10^7]$ 即： \\sum_{a=1}^n\\sum_{b=1}^a[\\gcd(a,b)=xor(a,b)]解题思路数学推理+暴力枚举 说几句闲话一开始对这道题没什么思路，以为是一个和二进制数有关的 $DP$，猜测复杂度是 $O(n\\log n)$，然后就发现貌似自己，哪里推不出来，于是只好点开一个叫做题解的东西 经过三天的思考无果之后，点开题解，结果发现和自己的思路截然不同， 深深地明白自己的弱小 分析求 $\\gcd(a,b)=xor(a,b)$，那么先看看这两个数有什么限制或者联系 首先 $gcd(a,b)\\le min(a,b)$，又有 $xor(a,b)$ 的范围挺广的，没有什么限制，看来这样不行 再尝试一下 $a-b(a&gt;=b)$ 和 $xor(a,b)$ 的大小关系，不难发现 $a-b\\le xor(a,b)=gcd(a,b)$ 由辗转相除法，可知 $a-b\\ge xor(a,b)=\\gcd(a,b)$ 也就说 $a-b=\\gcd(a,b)=xor(a,b)$，用 $c$ 表示上式 就有 $a=b+c$，而 $b=kc$ ，所以 $a=(k+1)c$，那么是不是只要枚举 $c$，然后累加上去就好了，这样最后再用前缀和记录一下即可，如果 $c$ 不枚举 $1$，那么实际理论复杂度就是 $O(n\\log n)$，和猜的一样 但是，这么简单我还是没有想出来，深深地明白自己的弱小 warning注意异或的优先级低于等号 Code#include&lt;bits/stdc++.h&gt;//没有显示结果，Luogu的Romote Judge貌似锅了 #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 30000007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n;LL Ans[N+3]; int main() { rint i,j;n=read(); for(i=1;i&lt;=N;i++) {//很简单的核心代码 for(j=i;j+i&lt;=N;j+=i) if((j^(j+i))==i) ++Ans[j+i];//注意加括号 Ans[i]+=Ans[i-1]; } for(i=1;i&lt;=n;i++) printf(&quot;Case %d: %lld\\n&quot;,i,Ans[read()]); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「AT3913」XOR Tree 解题报告","slug":"AT3913-XOR_Tree-Solution","date":"2019-11-09T13:14:02.000Z","updated":"2019-12-01T08:47:07.079Z","comments":true,"path":"2019/11/09/AT3913-XOR_Tree-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/09/AT3913-XOR_Tree-Solution/","excerpt":"","text":"题面给定 $n$ 个节点的树，每条边有权值 $val_i\\in[1,15]$ 每次操作可以选一条路径异或上一个数，最小化操作次数 解题思路转边权为点权，然后状压DP 分析首先，如果边权就有点复杂了，考虑如何把边权转化为点权，不难发现，对于一条路径中出了两端的点，每个点都有两两条边与之相连，那么就可以将边权转换为点权，每个点的权值即为所有与之相连的边权值的异或和，这样的话，对一条路径进行操作就变成了对两个点进行操作。又因为所有权值的大小不超过 $15$，范围很小，我们只要开个桶记录一下，权值相同的两两做一次操作即可，这样剩下来不为 $0$ 的点的数量就不超过 $15$ 个了，使用各种奇淫巧技都可以写过去（当然是据说 用状压 $DP$ 可以解决，$f[i]$ 表示状态为 $i$ 时的最小次数，当然 $i$ 需要是一个异或可以为 $0$ 的状态，每个 $i$ 可以从子集转移过来 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100007 using namespace std; const int T=1&lt;&lt;15; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,t,d[N],sum[19],f[T+3],st,ans,p[T+3]; int main() { rint i,j,x,y,val;n=read(); for(i=1;i&lt;n;i++) x=read(),y=read(),val=read(),d[x]^=val,d[y]^=val; for(i=0;i&lt;n;i++) ++sum[d[i]]; for(i=1;i&lt;16;i++) ans+=sum[i]&gt;&gt;1,st|=(sum[i]&amp;1)&lt;&lt;(i-1);//st表示最终状态 for(i=1;i&lt;T;i++) f[i]=f[i&gt;&gt;1]+(i&amp;1);//每个状态有几个1 for(i=1;i&lt;T;i++) --f[i];//f[i]表示每种状态最少做几次即可全部为0,最劣情况明显是1的个数-1 for(i=0;i&lt;T;i++) for(j=0;j&lt;15;j++) if((i&gt;&gt;j)&amp;1) p[i]^=(j+1);//每个状态的异或和 for(i=0;i&lt;T;i++) { if(p[i]) continue;//就是异或和能不能为0 for(j=(i-1)&amp;i;j;j=(j-1)&amp;i)//枚举子集 if(!p[j]) f[i]=min(f[i],f[j]+f[i^j]);//从异或为0的子集转移过来 }printf(&quot;%d&quot;,ans+f[st]); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://hovnySiLenCe.github.io/tags/状压DP/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P1993」小K的农场 解题报告","slug":"Luogu_P1993-LittleKFarm-Solution","date":"2019-11-08T05:25:40.000Z","updated":"2019-12-01T07:28:36.524Z","comments":true,"path":"2019/11/08/Luogu_P1993-LittleKFarm-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/08/Luogu_P1993-LittleKFarm-Solution/","excerpt":"","text":"题面解题思路差分约束+负环 这里只是提供板子，不做具体分析 Code$dfs\\ version:$ #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 10003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int to,nxt,cost; node(int a,int b,int c):to(a),nxt(b),cost(c){} node(){} }b[N*3]; int head[N],n,m,t,d[N]; bool vis[N]; inline void add(rint x,rint y,rint cost) { b[++t]=node(y,head[x],cost),head[x]=t; } inline bool Spfa(rint k) {//dfs才是王道 rint i,to,cost;vis[k]=1; for(i=head[k];i;i=b[i].nxt) { to=b[i].to,cost=d[k]+b[i].cost; if(d[to]&lt;cost) { d[to]=cost; if(vis[to]) return 0; if(!Spfa(to)) return 0; } }vis[k]=0; return 1; } int main() { rint i,op,x,y; n=read(),m=read(); for(i=1;i&lt;=m;i++) { op=read(),x=read(),y=read(); if(op==1) add(y,x,read()); else if(op==2) add(x,y,-read()); else add(x,y,0),add(y,x,0); } for(i=1;i&lt;=n;i++) add(0,i,0),d[i]=-inf; printf(&quot;%s&quot;,Spfa(0)?&quot;Yes&quot;:&quot;No&quot;); return 0; } $Spfa\\ version:$ #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 10003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int to,nxt,cost; node(int a,int b,int c):to(a),nxt(b),cost(c){} node(){} }b[N&lt;&lt;1]; int head[N],n,m,t,usd[N],d[N]; bool vis[N],ans=1; inline void add(rint x,rint y,rint cost) { b[++t]=node(y,head[x],cost),head[x]=t; } inline bool Spfa(rint S) { rint i,to,cur,cost; queue&lt;int&gt;p; memset(d,-inf,sizeof(d)); d[S]=0,p.push(S),vis[S]=1; while(!p.empty()) { cur=p.front(),p.pop();vis[cur]=0; if(usd[cur]&gt;n*0.3) return 0;++usd[cur];//按理说应该是大于n的，但是数据肯定不会这么恶心 for(i=head[cur];i;i=b[i].nxt) {//一般我写的都是n*0.5，一般能过（逃 to=b[i].to,cost=d[cur]+b[i].cost; if(d[to]&lt;cost) { d[to]=cost; if(!vis[to]) vis[to]=1, p.push(to); } } }return 1; } int main() { rint i,op,x,y; n=read(),m=read(); for(i=1;i&lt;=m;i++) { op=read(),x=read(),y=read(); if(op==1) add(y,x,read()); else if(op==2) add(x,y,-read()); else add(x,y,0),add(y,x,0); } for(i=1;i&lt;=n&amp;&amp;ans;i++) if(!usd[i]) ans&amp;=Spfa(i); printf(&quot;%s&quot;,ans?&quot;Yes&quot;:&quot;No&quot;); return 0; } 顺便贴上 Luogu P3385 【模板】负环 的代码 #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define M 3010 #define N 2010 using namespace std; struct node{ int to,cost; int nxt; node(int a,int b):to(a),cost(b){ } node(){ } }b[M&lt;&lt;1]; int head[N],d[N],Ti[N]; int n,m,T,t,Min; bool vis[N]; int read(){ int s=0,p=1; char c=getchar(); while(!isdigit(c)) { if(c==&#39;-&#39;) p=-1; c=getchar(); } while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s*p; } void init(){ t=0;memset(head,0,sizeof(head)); memset(Ti,0,sizeof(Ti));Min=0; } void add(int x,int y,int cost){ b[++t]=node(y,cost);b[t].nxt=head[x];head[x]=t; } bool SPFA() { int i,cur,to,cost; deque&lt;int&gt;p; memset(d,INF,sizeof(d)); memset(vis,0,sizeof(vis)); p.push_back(1);vis[1]=1;Ti[1]=1;d[1]=0; while(!p.empty()) { cur=p.front();p.pop_front(); vis[cur]=0; if(Ti[cur]&gt;=n||d[cur]&lt;Min) return 1; for(i=head[cur];i;i=b[i].nxt) { to=b[i].to;cost=d[cur]+b[i].cost; if(d[to]&gt;cost) { d[to]=cost; Ti[to]++; if(Ti[to]&gt;=n||d[to]&lt;Min) return 1; if(!vis[to]) { vis[to]=1; if(b[i].cost&lt;0) p.push_front(to); else p.push_back(to); } } } } return 0; } int main() { int i; int x,y,cost; T=read(); while(T--) { n=read()/2;m=read();init(); for(i=1;i&lt;=m;i++) { x=read();y=read();cost=read(); Min=min(Min,cost); if(cost&gt;=0) add(y,x,cost); else Min+=cost; add(x,y,cost); } if(SPFA()) printf(&quot;YE5\\n&quot;); else printf(&quot;N0\\n&quot;); } return 0; } 再贴上 Luogu P3275 [SCOI2011]糖果 的代码 #include&lt;bits/stdc++.h&gt; #define rgt register #define LL long long #define N 100003 #define M 300003 using namespace std; struct Edge{ int to,nxt,cost; Edge(int a,int b,int c):to(a),nxt(b),cost(c){} Edge(){} }b[M]; int head[N],n,T,t,d[N],usd[N]; LL ans; bool vis[N]; inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(rgt int x,rgt int y,rgt int cost) { b[++t]=Edge(y,head[x],cost),head[x]=t; } inline void Spfa() { rgt int i,cur,to,cost; queue&lt;int&gt;p;p.push(0),vis[0]=1; while(!p.empty()) { cur=p.front(),p.pop(),vis[cur]=0; for(i=head[cur];i;i=b[i].nxt) { to=b[i].to,cost=b[i].cost+d[cur]; if(d[to]&lt;cost) { d[to]=cost; if(!vis[to]) { ++usd[to]; if(usd[to]&gt;n-1) {ans=-1;return;} vis[to]=1; p.push(to); } } } } for(i=1;i&lt;=n;i++) ans+=d[i]; } int main() { int i,op,x,y; n=read(),T=read(); for(i=n;i;i--) add(0,i,1); while(T--) { op=read(),x=read(),y=read(); if(op==5) add(x,y,0); else if(op==2) { if(x==y) {printf(&quot;-1&quot;);return 0;} add(x,y,1); } else if(op==3) add(y,x,0); else if(op==4) { if(x==y) {printf(&quot;-1&quot;);return 0;} add(y,x,1); } else add(x,y,0),add(y,x,0); }Spfa(); printf(&quot;%lld&quot;,ans); return 0; } 貌似我还是比较喜欢已经死了的Spfa","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"差分约束","slug":"差分约束","permalink":"http://hovnySiLenCe.github.io/tags/差分约束/"},{"name":"负环","slug":"负环","permalink":"http://hovnySiLenCe.github.io/tags/负环/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4872」OIer们的东方梦 解题报告","slug":"Luogu_P4872-OIersEasternDream-Solution","date":"2019-11-08T05:22:30.000Z","updated":"2019-12-01T07:28:22.444Z","comments":true,"path":"2019/11/08/Luogu_P4872-OIersEasternDream-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/08/Luogu_P4872-OIersEasternDream-Solution/","excerpt":"","text":"题面解题思路分层图跑最短路加优化 分析显然分层图跑一跑就好了 用 d[x][y][s][f] 表示到 $(x,y)$ ，状态为 $(sword,flower)$ 的最短路 主要考虑传送门 用 $Dijkstra$ 做的话只要某一个传送门最优，其他传送门肯定可以被这个传送门更新，也就是说，如果我们以 $(sword,flower)$ 的状态走到某个传送门，由于传送门是互相连通的，因此，其他传送门肯定能被更新，所以我们只要对于对于到达传送门的每个不同状态更新一次就可以了，这样就能在 $O(nmlog)$ 的不正确时间内跑出答案（出题人懒得卡 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define M 1000003 #define N 1003 using namespace std; int Cx[4]={1,0,0,-1}; int Cy[4]={0,1,-1,0}; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int x,y; node(int a,int b):x(a),y(b){} node(){} }P[M]; struct stus{ int x,y,s,f,cost; stus(int a,int b,int c,int d,int e):x(a),y(b),s(c),f(d),cost(e){} stus(){} inline bool operator&lt; (const stus x) const{ return cost&gt;x.cost; } }c; int n,m,t,d[N][N][2][2],Sx,Sy,Ex,Ey,ans; char b[N][N];bool v[N][N][2][2]; bool vis[2][2]; inline void Dijstra() { rint i,x,y,s,f,cost,Tx,Ty; priority_queue&lt;stus&gt;p; memset(d,inf,sizeof(d)); p.push(stus(Sx,Sy,0,0,0)); d[Sx][Sy][0][0]=0; while(!p.empty()) { c=p.top(),p.pop(); x=c.x,y=c.y,s=c.s,f=c.f; if(v[x][y][s][f]) continue;v[x][y][s][f]=1; if(x==Ex&amp;&amp;y==Ey) return; if(b[x][y]==&#39;X&#39;&amp;&amp;!vis[s][f]) {//有不同的状态才转移 vis[s][f]=1,cost=d[x][y][s][f]+1; for(i=1;i&lt;=t;i++) { Tx=P[i].x,Ty=P[i].y; if(d[Tx][Ty][s][f]&gt;cost) { d[Tx][Ty][s][f]=cost, p.push(stus(Tx,Ty,s,f,cost)); } } } if(b[x][y]==&#39;5&#39;&amp;&amp;!s) {//拿剑的情况 cost=d[x][y][s][f]+5; if(d[x][y][s|1][f]&gt;cost) { d[x][y][s|1][f]=cost, p.push(stus(x,y,s|1,f,cost)); } } if(b[x][y]==&#39;4&#39;&amp;&amp;!f) {//拿花的情况 cost=d[x][y][s][f]; if(d[x][y][s][f|1]&gt;cost) { d[x][y][s][f|1]=cost, p.push(stus(x,y,s,f|1,cost)); } } for(i=0;i&lt;4;i++) {//向四周走 Tx=x+Cx[i],Ty=y+Cy[i]; if(b[Tx][Ty]==&#39; &#39;) continue; if(b[Tx][Ty]==&#39;X&#39;&amp;&amp;v[Tx][Ty][s][f]) continue; if(b[Tx][Ty]==&#39;1&#39;) { if(s) { cost=d[x][y][s][f]+1; if(d[Tx][Ty][s][f]&gt;cost) { d[Tx][Ty][s][f]=cost, p.push(stus(Tx,Ty,s,f,cost)); } }continue; } cost=d[x][y][s][f]+1; if(b[Tx][Ty]==&#39;2&#39;) {if(!(s|f)) cost+=3;} if(b[Tx][Ty]==&#39;3&#39;) {if(!(s|f)) cost+=8;} if(d[Tx][Ty][s][f]&gt;cost) { d[Tx][Ty][s][f]=cost, p.push(stus(Tx,Ty,s,f,cost)); } } } } int main() { rint i,j; n=read(),m=read(); for(i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,b[i]+1); for(j=1;j&lt;=m;j++) { if(b[i][j]==&#39;X&#39;) P[++t]=node(i,j); if(b[i][j]==&#39;S&#39;) Sx=i,Sy=j; if(b[i][j]==&#39;E&#39;) Ex=i,Ey=j; } } for(i=1;i&lt;=n;i++) b[i][0]=b[i][m+1]=&#39; &#39;; for(i=1;i&lt;=m;i++) b[0][i]=b[n+1][i]=&#39; &#39;;Dijstra(); ans=min(d[Ex][Ey][0][0],d[Ex][Ey][0][1]); cmin(ans,min(d[Ex][Ey][1][0],d[Ex][Ey][1][1])); if(ans&lt;inf) printf(&quot;%d&quot;,ans); else printf(&quot;We want to live in the TouHou World forever&quot;); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://hovnySiLenCe.github.io/tags/Dijkstra/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P5300」[GXOI/GZOI2019]与或和 解题报告","slug":"Luogu_P5300-[GXOI_GZOI2019]ANDORSum-Solution","date":"2019-11-07T03:15:14.000Z","updated":"2019-12-01T07:28:21.156Z","comments":true,"path":"2019/11/07/Luogu_P5300-[GXOI_GZOI2019]ANDORSum-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/07/Luogu_P5300-[GXOI_GZOI2019]ANDORSum-Solution/","excerpt":"","text":"题面给出一个 $N\\times N(N\\le 1000)$ 矩阵，矩阵中自然数 $\\in [0,2^{31}-1]$ 求，所有子矩阵 AND 与 OR 之和，对 $1,000,000,007 (10^9 + 7)$ 取模 解题思路二进制拆位+单调栈 分析对于二进制操作的，一般都想到拆位后处理，拆位后就变成了 $0/1$ 矩阵，处理起来就很方便 因此先拆位，这样问题形式就变成了：求有几个子矩阵 AND 值为 1，OR 值为 1 怎么求子矩阵？ 由于 $N$ 的范围在 $1000$，$N\\times N$ 就是 $10^6$，猜测可以枚举每个子矩阵的右下角，然后用线性的数据结构维护一下 由于 AND 和 OR 操作的性质，只要有 1 或 0 就可以确定当前的结果 因此可以记录一个在以 $(1,1)$ 为左上角，$(i,j)$ 这个点为右下角的矩阵中，离 $(i,j)$ 较近的 1 和 0 的位置 由于 AND 和 OR 操作本质是一致的，因此以下均只论述 OR 的情况 为什么说是较近？ 如图： 1-1 对 $(3,3)$ 来说，较近的点有 $(2,3)$ 和 $(3,1)$，因为如果左上角在 $(3,1)$ 或 $(2,3)$ 的左上方，则 OR 的值定为 1 换句话说，这里的较近点的含义即是会对答案产生影响的点，显然，这些点一定成一条走向为矩阵左下角到右上角的直线，即若 $j$ 的值有序，则 $i$ 值定单调，于是就可以考虑用单调栈维护这些点 如何计算子矩阵的贡献？ 既然我们用单调栈维护了这么一个东西，在更新的过程中得出答案 仍以上图为例，我们用 b[j][1] 表示以当前位置为右下角的矩阵中，在第 $j$ 列，1 最大的 $i$ 值 然后单调队列维护的应是随着 $j$ 逐渐增大，$i$ 值逐渐减小的栈 假设我们大家当前做到 $i=3$ ，一开始要把栈清空 当 $j=1$ 时，$b[1][1]=3$，直接入栈，并加上贡献 res1+=b[j][1]=3 当 $j=2$ 时，$b[2][1]=1$，仍然直接入栈，并加上贡献 res1+=b[j][1]=1 当 $j=3$ 时，$b[3][1]=2$，为了维护单调，要把 $1$ 弹出，并加上如图所示区域的贡献 --t1,res1+=(j-v1[t1]-1)*(min(St1[t1],b[j][1])-St1[t1+1])=1，$t1$ 表示栈顶，St1[_] 存的是 b[_][1]，v1[_] 存的是 $j$ 值 1-2 取 min(St1[t1],b[j][1]) 是因为又能会出现如下另外两种情况 1-3 1-4 关注在 $(3,3)$ 时情况，虽然这两种情况有点相似，但是仍需要注意 还有一点就是把栈弹空的情况（如上图 $1-3$ 和 $1-4$），此时要特判，否则取 min(St1[t1],b[j][1]) 的结果为 0 warning1、记得初始化记录 $i$ 的数组 2、AND 维护的是 0 的单调栈，因此最后计算个数的时候答案应为 i*j-res0 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define p 1000000007 #define N 1003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,f[N][N],b[N][2],res0,res1,l1,l0,M; int St1[N],St0[N],t0,t1,v0[N],v1[N]; LL c,ans1,ans0; int main() { rint i,j;n=read(); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) cmax(M,f[i][j]=read()); for(c=1;c&lt;=M;c&lt;&lt;=1) { memset(b,0,sizeof(b));//记得初始化b数组 for(i=1;i&lt;=n;i++) { t0=t1=res1=res0=0; for(j=1;j&lt;=n;j++) { if(f[i][j]&amp;c) b[j][1]=i;//更新b数组 else b[j][0]=i; res0+=b[j][0],res1+=b[j][1]; while(t0&amp;&amp;St0[t0]&lt;=b[j][0])//维护单调栈，也可以和if写在一起，但是第一次写挂之后就懒得改了 if(--t0) res0+=(j-v0[t0]-1)*(min(St0[t0],b[j][0])-St0[t0+1]); else res0+=(j-1)*(b[j][0]-St0[1]); St0[++t0]=b[j][0],v0[t0]=j; while(t1&amp;&amp;St1[t1]&lt;=b[j][1]) if(--t1) res1+=(j-v1[t1]-1)*(min(St1[t1],b[j][1])-St1[t1+1]); else res1+=(j-1)*(b[j][1]-St1[1]); St1[++t1]=b[j][1],v1[t1]=j; ans1=(ans1+res1*c)%p,//分开计算贡献 ans0=(ans0+(i*j-res0)*c)%p; } } }printf(&quot;%lld %lld&quot;,ans0,ans1); return 0; } 弱化版 Luogu P3400 仓鼠窝","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"二进制拆位","slug":"二进制拆位","permalink":"http://hovnySiLenCe.github.io/tags/二进制拆位/"},{"name":"单调栈","slug":"单调栈","permalink":"http://hovnySiLenCe.github.io/tags/单调栈/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4231」三步必杀 解题报告","slug":"Luogu_P4231-KilledInThreeSteps-Solution","date":"2019-11-06T10:52:34.000Z","updated":"2019-12-01T07:28:24.796Z","comments":true,"path":"2019/11/06/Luogu_P4231-KilledInThreeSteps-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/06/Luogu_P4231-KilledInThreeSteps-Solution/","excerpt":"","text":"题面长度为 $n$ 的序列，$m$ 次修改，每次修改，令 $[l,r]$ 区间加上首项为 $a$，末项为 $b$ 的等差数列 $1\\le n\\leq10^7,1\\le m\\le3\\times 10^5,1\\le l&lt; r\\le n.​$ 解题思路前缀和 分析如果你不怕 $T$ 上天，可以用线段树维护，获得 $O(n\\log n)$ 的优秀复杂度 等差数列的性质能让人联想到等差数列，考虑确实是这样的， 可以通过两个数组，分别维护首项和单位上升的大小 单位上升的大小即为等差数列的公差 这样只用最后扫一遍得出前缀和即可，时间复杂度 $O(n+m)$ （m&lt;&lt; n 可以不用考虑 warning1、维护公差的数组要从 $l+1$ 的位置开始修改 2、维护首项的数组 $r+1$ 的位置要减 $b​$，这样才能抵消前面产生的影响 code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 10000007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} template&lt;class K&gt;inline void read(K&amp;s) { s=0;rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); } int n,T;LL s[N],f[N],ans,res,a,b; int main() { rint i,l,r;read(n),read(T); while(T--) { read(l),read(r),read(a),read(b);//s[_]表示首项的前缀和，注意r+1减的是b s[l]+=a,f[l+1]+=(b-a)/(r-l),s[r+1]-=b,f[r+1]-=(b-a)/(r-l); }//f[_]维护的是公差的前缀和 for(i=1;i&lt;=n;i++) f[i]+=f[i-1],s[i]+=s[i-1]+f[i],ans^=s[i],cmax(res,s[i]); printf(&quot;%lld %lld&quot;,ans,res); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"http://hovnySiLenCe.github.io/tags/前缀和/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4861」按钮 解题报告","slug":"Luogu_P4861-Button-Solution","date":"2019-11-06T04:59:40.000Z","updated":"2019-12-01T07:28:22.852Z","comments":true,"path":"2019/11/06/Luogu_P4861-Button-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/06/Luogu_P4861-Button-Solution/","excerpt":"","text":"题面输入 $M,K \\in [2,2\\times 10^9]$，求最小的 $x$，满足：$K^x\\equiv 1\\pmod {M}$ 解题思路欧拉定理 分析当 $M,K$ 不互质时，必定无解 当 $M,K$ 互质时，显然 $x=\\phi(M)$ 为一解，而最小的 $x$ 应是 $\\phi(M)$ 的约数，证明如下： 假设 $x_0 \\nmid\\ \\phi(m)$ 且 $x_0$ 是 $K^x\\equiv 1 \\pmod M$ 的最小整数解，那么 $x_1=\\phi(M)\\mod x_0$ 必也是一个解且小于 $x_0$ 与假设不符，因此，最小的解必为 $\\phi(M)$ 的约数 枚举 $\\phi(M)$ 的约数，再用快速幂判断即可在 $O(\\sqrt m\\log m)$ 的复杂度内跑过此题 Warning求 $\\phi(M)$ 的时候并不用筛素数，直接 $\\sqrt m$ 求即可，(就是因为这个我才得了 $10pts$ Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int k,p,t,ans,phi;LL c; inline int Pow(rint b) { rll res=1,a=k; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1) res=res*a%p; return res; } int main() { rint i; phi=c=p=read(),k=read(); for(i=2;(LL)i*i&lt;=c;i++)//直接求phi，因为合数肯定是没有贡献的， if(c%i==0) {//并不影响结果 phi-=phi/i; while(c%i==0) c/=i; } if(c&gt;1) phi-=phi/c; if(__gcd(k,p)!=1) printf(&quot;Let&#39;s go Blue Jays!&quot;); else { ans=phi; for(i=2;(LL)i*i&lt;=phi;i++)//枚举 if(phi%i==0) { if(Pow(i)==1) {ans=i;break;} if(Pow(phi/i)==1) cmin(ans,phi/i); } printf(&quot;%d&quot;,ans); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「SP5973」SELTEAM - Selecting Teams 解题报告","slug":"SP5973-SELTEAM_SelectingTeams-Solution","date":"2019-11-06T04:13:12.000Z","updated":"2019-12-01T07:28:08.660Z","comments":true,"path":"2019/11/06/SP5973-SELTEAM_SelectingTeams-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/06/SP5973-SELTEAM_SelectingTeams-Solution/","excerpt":"","text":"题面即求： \\large \\sum_{i=1}^kC_n^i\\sum_{j=1}^iC_i^j\\times j有 $T(1\\le T \\le 10000)$ 组数据，其中 $1\\le k \\le n \\le 100000$ 解题思路组合数+乱搞 分析后面的 $\\times j$ 显然不是很方便，因此提前枚举 $j$，也就是选哪个人为队长，得： \\large \\sum_{i=1}^kC_n^i\\times i\\times 2^{i-1}然而你并没有于是你就会发现这个模数 $8388608​$ 很奇怪，分解得： \\large 8388608=2^{23}这不就很妙了嘛，这下 $i$ 就可以只枚举 $min(k,24)$ 了，至于 $C$，由于模数，不能直接求逆元，但是由于枚举的范围很小，因此可以直接用 $DP$ 预处理出来 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define p 8388608 #define N 100003 using namespace std; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline int dec(rint x){return (x&gt;=p)?x-p:x;} int n,k,T,f[N][25],ans;LL res; int main() { rint i,j;T=read(),f[0][0]=1;//预处理 for(i=1;i&lt;=N;i++) { f[i][0]=1; for(j=1;j&lt;=23;j++) f[i][j]=dec(f[i-1][j]+f[i-1][j-1]); } while(T--) {//枚举 n=read(),k=min(read(),23),ans=0,res=1; for(i=1;i&lt;=k;i++,res&lt;&lt;=1) ans=dec(ans+res*f[n][i]*i%p); printf(&quot;%d\\n&quot;,ans); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4396」[AHOI2013]作业 解题报告","slug":"Luogu_P4396-[AHOI2013]Homework-Solution","date":"2019-11-05T12:20:35.000Z","updated":"2019-12-01T07:28:24.070Z","comments":true,"path":"2019/11/05/Luogu_P4396-[AHOI2013]Homework-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/05/Luogu_P4396-[AHOI2013]Homework-Solution/","excerpt":"","text":"题面解题思路莫队+树状数组 分析区间操作，不带修改，食用莫队大法，然后莫队过程中用树状数组记录每个数出现的次数即可 当然，要记录两个信息，一个是个数，一个是种类数，最后查询即可 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int l,r,x,y,i; }b[N]; int n,m,pos[N],Ans1[N],Ans2[N],fx[N&lt;&lt;2],fy[N&lt;&lt;2],block,l,r,sum[N&lt;&lt;2],a[N]; inline bool cmp(rgt node a,rgt node b) { return (pos[a.l]^pos[b.l])?a.l&lt;b.l:(pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r; } inline void Modify(rint p,rint x,rint y) {//两个数组 if(p) for(;x&lt;=n;x+=x&amp;(-x)) fx[x]+=y; else for(;x&lt;=n;x+=x&amp;(-x)) fy[x]+=y; } inline void Add(rint x) { if(!sum[x]) Modify(0,x,1); ++sum[x],Modify(1,x,1); } inline void Del(rint x) { --sum[x],Modify(1,x,-1); if(!sum[x]) Modify(0,x,-1); } inline void Query(rint i,rint l,rint r) { rint x,y;x=y=0; for(;r;r-=r&amp;(-r)) x+=fx[r],y+=fy[r]; for(;l;l-=l&amp;(-l)) x-=fx[l],y-=fy[l]; Ans1[i]=x,Ans2[i]=y; } int main() { rint i,j; n=read(),m=read(),block=pow(n,0.54); for(i=1;i&lt;=n;i++) a[i]=read(),pos[i]=i/block; for(i=1;i&lt;=m;i++) b[i].l=read(),b[i].r=read(),b[i].x=read(),b[i].y=read(),b[i].i=i; sort(b+1,b+m+1,cmp),l=1; for(i=1;i&lt;=m;i++) { while(r&lt;b[i].r) Add(a[++r]); while(l&gt;b[i].l) Add(a[--l]); while(r&gt;b[i].r) Del(a[r--]); while(l&lt;b[i].l) Del(a[l++]); Query(b[i].i,b[i].x-1,b[i].y);//最后查询 } for(i=1;i&lt;=m;i++) printf(&quot;%d %d\\n&quot;,Ans1[i],Ans2[i]); return 0; } 强弱化版 Luogu P4867 Gty的二逼妹子序列（既强又弱） 正解值域分块，但是不知道为什么普通莫队过掉了 分析普通莫队+树状数组的复杂度是 $O(m\\sqrt n\\log n)$，但是由于数据水跑不满，虽说如此，还是可以看出其的稳定性不是很优，$author$ 亲测最坏时间 $2.66s$，另一个较大的点却跑了 $923ms$ 相较之下，值域分块的复杂度为 $O(m\\sqrt n)$，更加稳定且正确，两个测试点分别跑了 $1.60s$ 和 $1.18s$ 树状数组 $version$：#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define M 1000007 #define N 100007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int l,r,a,b,i; }b[M]; int n,m,l,r,block,a[N],f[N],sum[N],pos[N],Ans[M]; inline bool cmp(rgt node a,rgt node b) { return (pos[a.l]^pos[b.l])?a.l&lt;b.l:(pos[a.l]&amp;1)?a.r&gt;b.r:a.r&lt;b.r; } inline void Modify(rint x,rint p) { if(p) for(;x&lt;=n;x+=x&amp;(-x)) ++f[x]; else for(;x&lt;=n;x+=x&amp;(-x)) --f[x]; } inline int Query(rint l,rint r) { rint res=0; for(;r;r-=r&amp;(-r)) res+=f[r]; for(;l;l-=l&amp;(-l)) res-=f[l]; return res; } inline void Add(rint x) {if(!sum[x]++) Modify(x,1);} inline void Del(rint x) {if(!--sum[x]) Modify(x,0);} int main() { rint i,j; n=read(),m=read(),block=n/(sqrt(0.9*m)+1); for(i=1;i&lt;=n;i++) a[i]=read(),pos[i]=i/block; for(i=1;i&lt;=m;i++) b[i].l=read(),b[i].r=read(),b[i].a=read(),b[i].b=read(),b[i].i=i; sort(b+1,b+m+1,cmp),l=1; for(i=1;i&lt;=m;i++) { while(r&lt;b[i].r) Add(a[++r]); while(l&gt;b[i].l) Add(a[--l]); while(r&gt;b[i].r) Del(a[r--]); while(l&lt;b[i].l) Del(a[l++]); Ans[b[i].i]=Query(b[i].a-1,b[i].b); } for(i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,Ans[i]); return 0; } 值域分块 $version$：#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define M 1000007 #define N 100007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int l,r,a,b,i; }b[M]; int n,m,l,r,block,a[N],f[N],sum[N],pos[N],Ans[M],L[N],R[N],ans[N],num; inline bool cmp(rgt node a,rgt node b) { return (pos[a.l]^pos[b.l])?a.l&lt;b.l:(pos[a.l]&amp;1)?a.r&gt;b.r:a.r&lt;b.r; } inline int Query(rint l,rint r) { rint res=0; if(pos[l]==pos[r]) { while(l&lt;=r) res+=(sum[l]&gt;0),++l; return res; }rint i; for(i=l;i&lt;=R[pos[l]];i++) res+=(sum[i]&gt;0); for(i=L[pos[r]];i&lt;=r;i++) res+=(sum[i]&gt;0); for(i=pos[l]+1;i&lt;pos[r];i++) res+=ans[i]; return res; } inline void Add(rint x) {if(!sum[x]++) ans[pos[x]]++;} inline void Del(rint x) {if(!--sum[x]) ans[pos[x]]--;} int main() { rint i,j; n=read(),m=read(),block=n/(sqrt(0.9*m)+1); for(i=1;i&lt;=n;i++) a[i]=read(),pos[i]=(i-1)/block+1; num=(n-1)/block+1,R[num]=n,L[num]=block*(num-1)+1; for(i=1;i&lt;num;i++) L[i]=block*(i-1)+1,R[i]=block*i; for(i=1;i&lt;=m;i++) b[i].l=read(),b[i].r=read(),b[i].a=read(),b[i].b=read(),b[i].i=i; sort(b+1,b+m+1,cmp),l=1; for(i=1;i&lt;=m;i++) { while(r&lt;b[i].r) Add(a[++r]); while(l&gt;b[i].l) Add(a[--l]); while(r&gt;b[i].r) Del(a[r--]); while(l&lt;b[i].l) Del(a[l++]); Ans[b[i].i]=Query(b[i].a,b[i].b); } for(i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,Ans[i]); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://hovnySiLenCe.github.io/tags/莫队/"},{"name":"树状数组","slug":"树状数组","permalink":"http://hovnySiLenCe.github.io/tags/树状数组/"},{"name":"分块","slug":"分块","permalink":"http://hovnySiLenCe.github.io/tags/分块/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3917」异或序列 解题报告","slug":"Luogu_P3917-XorArray-Solution","date":"2019-11-01T13:55:52.000Z","updated":"2019-12-01T07:28:26.828Z","comments":true,"path":"2019/11/01/Luogu_P3917-XorArray-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/01/Luogu_P3917-XorArray-Solution/","excerpt":"","text":"题面解题思路这里提供一种乱搞新奇的算法（完全在线鬼知道有什么用 分析考虑拆位，由于异或的性质（算是吧，不同位之间不影响，因此可以计算每个位做出的贡献，然后累加 显然，只有奇数个 $1$ 才能做出贡献，所以我们只要能计算出有多少个区间包含奇数个 $1$ 尝试看看有什么规律： 数 $2$ $5$ $6$ $2^2$ $0$ $1$ $1$ $2^1$ $1$ $0$ $1$ $2^0$ $0$ $1$ $0$ 对 2,5,6 分别拆位，表示为上述的表（当然做的时候没必要记录 考虑 $2^2$，以第 $1$ 个数 $2$ 为区间右端点，有贡献的区间有 $0$ 个；以第 $2$ 个数 $5$ 为区间右端点，有贡献的区间有 $[1,2]$ 和 $[2,2]$ 共 $2$ 个；以第 $3$ 个数 $6$ 为区间右端点，有贡献的区间有 $[3,3]$ 共 $1$ 个。做出的总贡献为 $(2+1)\\times 2^2$ 其余位同理 不难看出，如果将序列按 $1$ 的位置分段，则右端点处于某段中（即为 $0$ 的情况）时，有贡献的区间数为与之距离奇数段的区间总跨度；为某段的右端点（即为 $1$ 的情况）时，贡献为与之距离偶数段的区间总跨度，$Rt$ 在一个某段中（即为 $0$ 的情况）， $7,8$ 等，贡献即为其之前蓝色区间的跨度 $6-4=2$ $10,11$ 等，贡献即为其之前红色区间的跨度 $(9-6)+(4-0)=7$ 为某段的右端点（即为 $1$ 的情况）， $4$ 等，贡献即为其之前红色区间的跨度 $4-0=4$ $12$ 等，贡献即为其之前蓝色区间的跨度 $(12-9)+(6-4)=5$ 然后我们就可以得出这样一个代码： int n,k,sum[31][2],p[31],pos[31];LL ans,c; int main() { rint i,j;n=read(); for(i=1;i&lt;=n;i++) { k=read(),c=1; for(j=0;j&lt;30;++j,c&lt;&lt;=1) {//pos记录上一个1的位置，sum[_][0/1]记录红蓝色区间分别的跨度 if(k&amp;c) p[j]^=1,sum[j][p[j]]+=i-pos[j],pos[j]=i; ans+=sum[j][p[j]]*c;//累加贡献 } } printf(&quot;%lld&quot;,ans); return 0; } more但是，还可以优化，由于做到 $1$ 时，红蓝色区间跨度之和定等于 $i$，又做到 $0$ 时，对红蓝色区间的跨度无影响，因此可以改成： rint i,j;n=read(); for(i=1;i&lt;=n;i++) { k=read(),c=1; for(j=0;j&lt;30;++j,c&lt;&lt;=1) {//红蓝区间的跨度可以由另外一个推得 if(k&amp;c) sum[j]=i-sum[j]; ans+=sum[j]*c; } } 或者我们还可以这样考虑：由于异或具有自反性，因此可以考虑拆位后求出异或前缀，这样的话有贡献的区间即为 $1$ 的个数与 $0$ 的个数之积 rint i,j;n=read(); for(i=1;i&lt;=n;i++) { k=read(),c=1; for(j=0;j&lt;30;++j,c&lt;&lt;=1) p[j]^=k&amp;c,++sum[j][p[j]];//分别存前缀异或，以及1和0的个数 } for(i=0,c=1;i&lt;30;++i,c&lt;&lt;=1) ans+=sum[i][0]*sum[i][1]*c; warning$\\mathtt{non}$ Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,k,sum[31];LL ans,c; int main() { rint i,j;n=read(); for(i=1;i&lt;=n;i++) { k=read(),c=1; for(j=0;j&lt;30;++j,c&lt;&lt;=1) { if(k&amp;c) sum[j]=i-sum[j]; ans+=sum[j]*c; } } printf(&quot;%lld&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3618」误会 解题报告","slug":"Luogu_P3618-Mistake-Solution","date":"2019-11-01T05:45:11.000Z","updated":"2019-12-01T07:28:28.089Z","comments":true,"path":"2019/11/01/Luogu_P3618-Mistake-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/01/Luogu_P3618-Mistake-Solution/","excerpt":"","text":"题面解题思路$\\mathtt{DP+hash}$ 分析正解不是很是难想，由于是计数类问题，应该就想到 $DP$，又由于字符串，即可用字符串 $hash$ 解决 记原句为 $A$ 串，长度为 $la$；听到的话为 $B$ 串，长度为 $lb$ 考虑怎么转移，分情况讨论： · 如果在 $A$ 串位置 $i$ 能匹配上 $B$ 串，显然，替换是一种，不替换也是一种选择，直接相加 $\\to$ f[i]=f[i-lb]+f[i-1] · 反之，不能匹配，此时只有不替换一种选择，直接转移 $\\to$ f[i]=f[i-1] 对于 $hash$，使用 $unsigned\\ long\\ long$ 的自然溢出即可，（默认字符串 $hash$ 都会 Warning$f_{0-lb}$ 都应初始为 $1$ Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define ull unsigned LL #define N 100003 using namespace std; const int base=1000000007; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,m,la,lb,t,f[N]; ull s[N],sum,bit[N]; char a[N],b[N]; inline int dec(rint x){return(x&gt;=base)?x-base:x;} int main() { rint i,k;m=read(),bit[0]=1,t=f[0]=1; for(k=1;k&lt;=m;k++) { scanf(&quot;%s%s&quot;,a+1,b+1),la=strlen(a+1),lb=strlen(b+1),sum=0; for(i=1;i&lt;=la;i++) s[i]=s[i-1]*base+a[i]-&#39;0&#39;;//得到A串的前缀hash while(t&lt;=lb) bit[t]=bit[t-1]*base,++t;//base^t for(i=1;i&lt;=lb;i++) sum=sum*base+b[i]-&#39;0&#39;,f[i]=1;//计算B串的hash值&amp;初始化 for(i=lb;i&lt;=la;i++) { if(sum==s[i]-s[i-lb]*bit[lb]) f[i]=f[i-lb];//可以替换 else f[i]=0;f[i]=dec(f[i]+f[i-1]); } printf(&quot;Case #%d: %d\\n&quot;,k,f[la]); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"},{"name":"hash","slug":"hash","permalink":"http://hovnySiLenCe.github.io/tags/hash/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4592」[TJOI2018]异或 解题报告","slug":"Luogu_P4592-[TJOI2018]Xor-Solution","date":"2019-11-01T04:56:08.000Z","updated":"2019-12-01T07:28:23.241Z","comments":true,"path":"2019/11/01/Luogu_P4592-[TJOI2018]Xor-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/11/01/Luogu_P4592-[TJOI2018]Xor-Solution/","excerpt":"","text":"题面莫名其妙翻到的 莫名其妙的题 解题思路树链剖分+可持久化Trie 分析应该也没有什么好分析的，这道数据结构的题没有多少思维量，直接看着做就好了，这里只是提供 树剖+可持久化Trie的板子而已 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int son[2],sum; }T[N*31]; int ver[N&lt;&lt;1],nxt[N&lt;&lt;2],head[N],seg[N],top[N],rev[N]; int deep[N],size[N],fa[N],son[N],num; int n,m,t,a[N],k,root[N],res,ans,l,r; inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t, ver[++t]=x,nxt[t]=head[y],head[y]=t; } inline void dfs1(rint k) { rint i,to; deep[k]=deep[fa[k]]+1,size[k]=1; for(i=head[k];i;i=nxt[i]) { to=ver[i];if(to==fa[k]) continue; fa[to]=k,dfs1(to),size[k]+=size[to]; if(size[to]&gt;size[son[k]]) son[k]=to; } } inline void dfs2(rint k) { if(son[k]) { seg[son[k]]=++num, top[son[k]]=top[k], rev[num]=son[k], dfs2(son[k]); } rint i,to; for(i=head[k];i;i=nxt[i]) { to=ver[i];if(top[to]) continue; seg[to]=++num, rev[num]=top[to]=to,dfs2(to); } } inline int Insert(rint pos,rint k) { rint i,c,x=root[pos]=++t,y=root[pos-1];T[x]=T[y]; for(i=29;i&gt;=0;--i) { c=k&amp;(1&lt;&lt;i)?1:0; x=T[x].son[c]=++t,y=T[y].son[c], T[x]=T[y],++T[x].sum; } } inline void Query(rint x,rint y) { rint i,p=1,c;res=0; for(i=29;i&gt;=0;--i) { c=k&amp;(1&lt;&lt;i)?0:1; if(T[T[y].son[c]].sum-T[T[x].son[c]].sum) y=T[y].son[c],x=T[x].son[c],res+=1&lt;&lt;i; else y=T[y].son[c^1],x=T[x].son[c^1]; }cmax(ans,res); } #define fx top[x] #define fy top[y] inline void Ask(rint x,rint y) { while(fx!=fy) { if(deep[fx]&lt;deep[fy]) swap(x,y); Query(root[seg[fx]-1],root[seg[x]]); x=fa[fx]; } if(deep[x]&lt;deep[y]) swap(x,y); Query(root[seg[y]-1],root[seg[x]]); } int main() { rint i,op;n=read(),m=read(); for(i=1;i&lt;=n;i++) a[i]=read(); for(i=1;i&lt;n;i++) k=read(),add(k,read()); num=seg[1]=rev[1]=top[1]=1, dfs1(1),dfs2(1); for(i=1;i&lt;=n;i++) Insert(i,a[rev[i]]); while(m--) { op=read(),l=read(),ans=0; if(op-1) r=read(),k=read(),Ask(l,r); else k=read(),Query(root[seg[l]-1],root[seg[l]+size[l]-1]); printf(&quot;%d\\n&quot;,ans); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://hovnySiLenCe.github.io/tags/树链剖分/"},{"name":"可持久化Trie树","slug":"可持久化Trie树","permalink":"http://hovnySiLenCe.github.io/tags/可持久化Trie树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4991」愤怒的XiaoX 解题报告","slug":"Luogu_P4991-AngryXiaoX-Solution","date":"2019-10-30T08:27:33.000Z","updated":"2019-12-01T07:28:21.622Z","comments":true,"path":"2019/10/30/Luogu_P4991-AngryXiaoX-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/30/Luogu_P4991-AngryXiaoX-Solution/","excerpt":"","text":"题面区间反/翻转二进制，单点查询 解题思路线段树，只不过要维护两个标记 分析 · 操作 $1$，对每位取反，直接异或上 (1&lt;&lt;k)+1 即可 · 操作 $2$，翻转二进制比较复杂，貌似也没有直接翻转的函数，就只能手写 再深究发现，其实两个操作是互不影响的，因此只需维护两个 $tag$ 即可，再看题目中的 $k$ 的限制，一系列操作的 $k$ 值相同，因此 $tag$ 维护的信息应为 $bool$ 类型，表示上述操作是否做了（因为同一个操作做两次就是无效的 又有 $t$ 小于 $5$，所以在 $k$ 值改变，也就是做下一组询问的时候，可以直接暴力把先前的标记全部下传 关于查询，其实只要把 对查询的点有影响的标记 下传即可，都不用维护区间 warning貌似没有什么特别坑的地方，复制粘贴的时候记得改函数名就好了（尴尬 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 50003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,m,T,K,b[N],L,R,pos,y; bool tag[N&lt;&lt;2],rev[N&lt;&lt;2]; inline void push(rint k,rint l,rint r) {//下传标记 if(l==r) {//如果已经到了某个位置，直接修改 if(tag[k]) b[l]^=y;//反转直接异或(1&lt;&lt;k)-1 if(rev[k]) {//翻转要自己写 rint i,c=b[l]&amp;y,s=0;b[l]-=c; for(i=0;i&lt;K;++i) { if(c&amp;(1&lt;&lt;i)) s+=1&lt;&lt;(K-i-1); }b[l]+=s; } } else {//否则下传标记 rint ls=k&lt;&lt;1; if(tag[k]) tag[ls]^=1,tag[ls|1]^=1; if(rev[k]) rev[ls]^=1,rev[ls|1]^=1; } tag[k]=rev[k]=0; } inline void Modify(rint k,rint l,rint r) {//打反转标记 push(k,l,r);if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {tag[k]^=1;return push(k,l,r);} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,m),Modify(ls|1,m+1,r); } inline void Flip(rint k,rint l,rint r) {//打翻转标记 push(k,l,r);if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {rev[k]^=1;return push(k,l,r);} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Flip(ls,l,m),Flip(ls|1,m+1,r); } inline void Query(rint k,rint l,rint r) {//查询 即将有影响的标记下传 push(k,l,r);if(l==r) return; rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; (pos&lt;=m)?Query(ls,l,m):Query(ls|1,m+1,r); } inline void Update(rint k,rint l,rint r) {//暴力下传所有标记 push(k,l,r);if(l==r) return; rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Update(ls,l,m),Update(ls|1,m+1,r); } int main() { rint i,op; n=read(),T=read(); for(i=1;i&lt;=n;i++) b[i]=read(); while(T--) { m=read(),K=read(),y=(1&lt;&lt;K)-1;//取反异或用 while(m--) { op=read(); if(op==3) pos=read(),Query(1,1,n),printf(&quot;%d\\n&quot;,b[pos]);//下传标记后直接输出当前值 else { L=read(),R=read(); if(op==1) Modify(1,1,n); else Flip(1,1,n); } }Update(1,1,n);//暴力下传标记 } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「UVA10140」 Prime Distance 解题报告","slug":"UVA10140-Prime_Distance-Solution","date":"2019-10-30T05:12:18.000Z","updated":"2019-12-01T07:28:06.063Z","comments":true,"path":"2019/10/30/UVA10140-Prime_Distance-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/30/UVA10140-Prime_Distance-Solution/","excerpt":"","text":"题面大概的意思就是求 $[l,r]$ 区间相邻最近和最远的质数 解题思路这里明显的就是一个埃氏筛的运用（很久前咕掉的现在补上 分析区间的长度不超过 $1e6$，又有筛质数时，有效的其实是小于 $n$ 的质数，因此可以先预处理出 $[1,\\sqrt{\\mathtt{INT\\_MAX}}]$ 的质数，然后在用其取筛 $[l,r]$ 区间的质数，直接那个 $O(n\\log\\log n)$ 的Eratosthenes 筛法即可 Warning1、$1$ 也算质数 2、筛素数的时候可能会把这个质数本身筛掉 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f7f #define M 1000007 using namespace std; const int N=sqrt(INT_MAX); LL l,r,t,Max,Min,lx,ly,rx,ry,x,y,pr[N&gt;&gt;1]; bool v[N+3],b[M]; int main() { rll i,j,c; for(i=2;i&lt;=N;i++) {//初始化质数 if(!v[i]) pr[++t]=i; for(j=1;j&lt;=t;j++) { c=i*pr[j];if(c&gt;N) break; v[c]=1;if(i%pr[j]==0) break; } } while(~scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r)) { memset(b,0,sizeof(b)),Max=-1,Min=inf+1,y=-1; if(l==1) b[0]=1; for(i=1;i&lt;=t&amp;&amp;pr[i]&lt;=r;i++) { c=pr[i]*max(l/pr[i]+(l%pr[i]&gt;0),2ll);//取max是防止不筛掉自己 while(c&lt;=r) b[c-l]=1,c+=pr[i];//标记合数 } for(i=0;i&lt;=r-l;i++) if(!b[i]) { x=y,y=i+l; if(x&lt;0) continue; if(y-x&lt;Min) lx=x,ly=y,Min=y-x; if(y-x&gt;Max) rx=x,ry=y,Max=y-x; } if(Max&lt;0||Min&gt;inf) printf(&quot;There are no adjacent primes.\\n&quot;); else printf(&quot;%lld,%lld are closest, %lld,%lld are most distant.\\n&quot;,lx,ly,rx,ry); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"},{"name":"埃氏筛","slug":"埃氏筛","permalink":"http://hovnySiLenCe.github.io/tags/埃氏筛/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P1941」飞扬的小鸟 解题报告","slug":"Luogu_P1941-FlappyBird-Solution","date":"2019-10-30T04:41:14.000Z","updated":"2019-12-01T07:28:36.980Z","comments":true,"path":"2019/10/30/Luogu_P1941-FlappyBird-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/30/Luogu_P1941-FlappyBird-Solution/","excerpt":"","text":"题面像素鸟有毒 解题思路动态规划，注意一些细节 分析考虑 $DP$，转移状态有两种，一种就是点击屏幕，一种不点击屏幕，可以看出：前者类似完全背包，后者类似0/1背包 因此只要写两个 $DP$ 即可，然而 $author$ 将两种背包混合在了一起，并且使用了滚动数组（= WA × inf Warning1、做完全背包的时候不能先将无法到达的状态赋 $inf$！！！ 2、注意点击后超出 $m$ 的情况 PS：貌似题目所说从 任意整数开始 不包括 $0$（$author$ 没打 $0$，但过了 Code已删去部分无用的板子 #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define inf 0x7f7f7f7f #define N 10007 #define M 1007 using namespace std; template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} struct node{ int p,bt,tp; inline bool operator&lt; (const node x) const{ return p&lt;x.p; } }b[N]; int n,m,k,f[M][2],p,c,t,rs[N],dr[N],rse,drp,ans=inf; int main() { rint i,j,l,r,flg; n=read(),m=read(),k=read(); for(i=1;i&lt;=n;i++) rs[i]=read(),dr[i]=read();//单次点击后上升的高度，否则下降的高度 for(i=1;i&lt;=k;i++) b[i].p=read(),b[i].bt=read(),b[i].tp=read();//存管道 sort(b+1,b+k+1),t=1;//按横坐标排序 for(i=1;i&lt;=n;i++) { c=p^1,rse=rs[i],drp=dr[i],flg=1;//flg用于判断是否能完成游戏，当所有状态都无法到达时为1 for(j=1;j&lt;=m;j++) f[j][c]=inf; if(b[t].p==i) {//这是关键，也是易错点 l=b[t].bt,r=b[t].tp,++t; for(j=rse+1;j&lt;r;j++) cmin(f[j][c],min(f[j-rse][p],f[j-rse][c])+1);//完全背包 for(j=1;j&lt;=l;j++) f[j][c]=inf;//删去碰到管道的情况 for(;j&lt;r;j++) {//0/1背包 if(j+drp&lt;=m) cmin(f[j][c],f[j+drp][p]); if(j&gt;l) flg&amp;=(f[j][c]&gt;=inf); } } else { for(j=1;j&lt;=m;j++) {//没有管道的转移可以同时一起 k=min(j+rse,m),cmin(f[k][c],min(f[j][p],f[j][c])+1); if(j+drp&lt;=m) cmin(f[j][c],f[j+drp][p]); flg&amp;=(f[j][c]&gt;=inf); } }p=c; if(flg) {printf(&quot;0\\n%d&quot;,t-2);return 0;}//无法完成则输出最多能过的柱子数 } for(i=1;i&lt;=m;i++) cmin(ans,f[i][p]); printf(&quot;1\\n%d&quot;,ans); return 0; } 另附某题解代码，自认为层次比 $author$ 的清晰 //by @ZMYJOE(Luogu) #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int maxn=10000+10; const int maxm=2000+10; int n,m,p; int x[maxn],y[maxn]; //i位置，上升x[i],下降y[i] int low[maxn],high[maxn]; //i位置能通过的范围是low[i]-high[i] int f[maxn][maxm]; //到(i,j)的最少点击次数 bool e[maxn]; //e[i]表示i位置有没有管道 int main() { scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]); for(int i=1; i&lt;=n; ++i) { low[i]=1; high[i]=m; } int a,b,c; for(int i=1; i&lt;=p; ++i) { scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); e[a]=1; low[a]=b+1; high[a]=c-1; } memset(f,0x3f,sizeof(f)); for(int i=1; i&lt;=m; ++i) f[0][i]=0; for(int i=1; i&lt;=n; ++i) { for(int j=x[i]+1; j&lt;=m+x[i]; ++j) f[i][j]=min(f[i-1][j-x[i]]+1,f[i][j-x[i]]+1); for(int j=m+1; j&lt;=m+x[i]; ++j) f[i][m]=min(f[i][m],f[i][j]); for(int j=1; j&lt;=m-y[i]; ++j) f[i][j]=min(f[i][j],f[i-1][j+y[i]]); for(int j=1; j&lt;low[i]; ++j) f[i][j]=f[0][0]; //不能通过(INF) for(int j=high[i]+1; j&lt;=m; ++j) f[i][j]=f[0][0]; //不能通过(INF) } int ans=f[0][0]; for(int j=1;j&lt;=m;++j) { ans=min(ans,f[n][j]); } if(ans&lt;f[0][0]) printf(&quot;1\\n%d\\n&quot;,ans); else{ int i,j; for(i=n;i&gt;=1;i--) { for(j=1;j&lt;=m;++j) { if(f[i][j]&lt;f[0][0]) break; } if(j&lt;=m) break; } ans=0; for(int j=1;j&lt;=i;++j) { if(e[j]) ans++; } printf(&quot;0\\n%d\\n&quot;,ans); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3154」[CQOI2009]循环赛 解题报告","slug":"Luogu_P3154-[CQOI2009]CircleMatch-Solution","date":"2019-10-28T13:58:35.000Z","updated":"2020-01-30T09:49:17.151Z","comments":true,"path":"2019/10/28/Luogu_P3154-[CQOI2009]CircleMatch-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/28/Luogu_P3154-[CQOI2009]CircleMatch-Solution/","excerpt":"","text":"题面思路DFS+剪枝+Hash 分析首先肯定是 $dfs$， 看成是一张 $n\\times n$ 的比赛表，然后一次 $dfs$ 每场比赛的胜负即可， 主要考虑如何剪枝 可行性剪枝1、如果当前人赢了所有比赛仍不能达到他的分数，剪枝 2、如果剩下的所有比赛都平所得的总分大于实际总分或者都赢的总分小于实际总分，剪枝 $code$ 如下： if(b[x]+3*(n-y+1)&lt;a[x]) return 0; rint res=(n-x-1)*(n-x)/2+(n-y+1); if(sum+3*res&lt;T||sum+2*res&gt;T) return 0;//T为总分 3、（重点）设在所有比赛中平局的场数为 $l$，任意一方胜利的场数为 $w$，显然有 \\begin{equation} \\left\\{ \\begin{array}{**lr**} w+l=\\dfrac{n\\times(n-1)} {2}\\\\ 3w+2l=T\\\\ \\end{array} \\right. \\end{equation}既然是一个二元一次方程组，就可以解一下，得 \\begin{equation} \\left\\{ \\begin{array}{**lr**} w=T-n\\times(n-1)\\\\ l=\\dfrac {n\\times(n-1)} 2-w \\end{array} \\right. \\end{equation}这样就可以继续可行性剪枝 当胜利的场数或者平局的场数不足时才做，剪去的时间很客观（但是还是过不了 $code$ 如下： if(w&amp;&amp;b[x]+3&lt;=a[x]) --w,b[x]+=3,res+=dfs(x,y+1,sum+3),b[x]-=3,++w; if(l&amp;&amp;b[x]+1&lt;=a[x]&amp;&amp;b[y]+1&lt;=a[y]) { ++b[x],++b[y],--l; res+=dfs(x,y+1,sum+2); --b[x],--b[y],++l; } if(w&amp;&amp;b[y]+3&lt;=a[y]&amp;&amp;b[y]+3+3*(n-x+1)) --w,b[y]+=3,res+=dfs(x,y+1,sum+3),b[y]-=3,++w; 改变搜索顺序将实际分数按从大到小排序后搜索效率更高 记忆化！！！真·神仙 用 $Hash$ 完成记忆化，用 $map$ 存，每次一个人的所有比赛比完之后，判断一下状态是否已经到达过 $code$ 如下： if(y&gt;n) { for(rint i=x+1;i&lt;=n;++i) c[i]=a[i]-b[i]; sort(c+x+1,c+n+1);LL key=0; for(rint i=x+1;i&lt;=n;i++) key=key*base+c[i]; if(v.find(key)!=v.end()) return v[key]; return v[key]=dfs(x+1,x+2,sum); } 要注意的是： 1、我们 $Hash$ 的是每个人当前分数与实际的分数差 2、$Hash$ 之前排序是因为相同数字是等效的，本质上只不过是将一些数字分成几堆，而如何分，顺序是无关的，因此是等效的 warning1、$Hash$ 判断有没有出现过是不能用 if(v[key])，因为可能这种情况无解，应用 if(v.find(key)!=v.end()). 2、别忘排序，$Hash$ 的是当前与实际分数的差 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} const LL base=1e9+7;//base的取值28也可以 inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,T,a[11],b[11],c[11],w,l; map&lt;LL,int&gt;v;//一开始想用ull自然溢出的，不过貌似没有什么问题 inline int dfs(rint x,rint y,rint sum) { if(x==n) return 1; if(b[x]+3*(n-y+1)&lt;a[x]) return 0;//可行性剪枝1 if(y&gt;n) {//一个人的所有比赛完后Hash，再搜索下一个人 for(rint i=x+1;i&lt;=n;++i) c[i]=a[i]-b[i]; sort(c+x+1,c+n+1);LL key=0; for(rint i=x+1;i&lt;=n;i++) key=key*base+c[i]; if(v.find(key)!=v.end()) return v[key];//0也是有可能的，因此不能用if(v[key]) return v[key]=dfs(x+1,x+2,sum);//注意记录值 } rint res=(n-x-1)*(n-x)/2+(n-y+1);//可行性剪枝2 if(sum+3*res&lt;T||sum+2*res&gt;T) return 0;res=0; if(w&amp;&amp;b[x]+3&lt;=a[x]) --w,b[x]+=3,res+=dfs(x,y+1,sum+3),b[x]-=3,++w;//可行性剪枝3 if(l&amp;&amp;b[x]+1&lt;=a[x]&amp;&amp;b[y]+1&lt;=a[y]) { ++b[x],++b[y],--l; res+=dfs(x,y+1,sum+2); --b[x],--b[y],++l; } if(w&amp;&amp;b[y]+3&lt;=a[y]&amp;&amp;b[y]+3+3*(n-x+1)/*可行性剪枝1*/) --w,b[y]+=3,res+=dfs(x,y+1,sum+3),b[y]-=3,++w; return res%base;//不要忘记取膜 } inline bool cmp(rint x,rint y){return x&gt;y;} int main() { rint i;n=read(); for(i=1;i&lt;=n;i++) T+=a[i]=read(); sort(a+1,a+n+1,cmp),w=T-n*(n-1),l=n*(n-1)/2-w;//算出胜场和平场 printf(&quot;%d&quot;,dfs(1,2,0)); return 0; } 推荐题目emmm 双倍经验 ~强化版 Luogu P3154 [HNOI2013]比赛","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://hovnySiLenCe.github.io/tags/DFS/"},{"name":"Hash","slug":"Hash","permalink":"http://hovnySiLenCe.github.io/tags/Hash/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3230」[HNOI2013]比赛 解题报告","slug":"Luogu_P3230-[HNOI2013]Match-Solution","date":"2019-10-28T13:48:20.000Z","updated":"2020-01-30T09:49:30.771Z","comments":true,"path":"2019/10/28/Luogu_P3230-[HNOI2013]Match-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/28/Luogu_P3230-[HNOI2013]Match-Solution/","excerpt":"","text":"题面思路DFS+剪枝+Hash 分析首先肯定是 $dfs$， 看成是一张 $n\\times n$ 的比赛表，然后一次 $dfs$ 每场比赛的胜负即可， 主要考虑如何剪枝 可行性剪枝1、如果当前人赢了所有比赛仍不能达到他的分数，剪枝 2、如果剩下的所有比赛都平所得的总分大于实际总分或者都赢的总分小于实际总分，剪枝 $code$ 如下： if(b[x]+3*(n-y+1)&lt;a[x]) return 0; rint res=(n-x-1)*(n-x)/2+(n-y+1); if(sum+3*res&lt;T||sum+2*res&gt;T) return 0;//T为总分 3、（重点）设在所有比赛中平局的场数为 $l$，任意一方胜利的场数为 $w$，显然有 \\begin{equation} \\left\\{ \\begin{array}{**lr**} w+l=\\dfrac{n\\times(n-1)} {2}\\\\ 3w+2l=T\\\\ \\end{array} \\right. \\end{equation}既然是一个二元一次方程组，就可以解一下，得 \\begin{equation} \\left\\{ \\begin{array}{**lr**} w=T-n\\times(n-1)\\\\ l=\\dfrac {n\\times(n-1)} 2-w \\end{array} \\right. \\end{equation}这样就可以继续可行性剪枝 当胜利的场数或者平局的场数不足时才做，剪去的时间很客观（但是还是过不了 $code$ 如下： if(w&amp;&amp;b[x]+3&lt;=a[x]) --w,b[x]+=3,res+=dfs(x,y+1,sum+3),b[x]-=3,++w; if(l&amp;&amp;b[x]+1&lt;=a[x]&amp;&amp;b[y]+1&lt;=a[y]) { ++b[x],++b[y],--l; res+=dfs(x,y+1,sum+2); --b[x],--b[y],++l; } if(w&amp;&amp;b[y]+3&lt;=a[y]&amp;&amp;b[y]+3+3*(n-x+1)) --w,b[y]+=3,res+=dfs(x,y+1,sum+3),b[y]-=3,++w; 改变搜索顺序将实际分数按从大到小排序后搜索效率更高 记忆化！！！真·神仙 用 $Hash$ 完成记忆化，用 $map$ 存，每次一个人的所有比赛比完之后，判断一下状态是否已经到达过 $code$ 如下： if(y&gt;n) { for(rint i=x+1;i&lt;=n;++i) c[i]=a[i]-b[i]; sort(c+x+1,c+n+1);LL key=0; for(rint i=x+1;i&lt;=n;i++) key=key*base+c[i]; if(v.find(key)!=v.end()) return v[key]; return v[key]=dfs(x+1,x+2,sum); } 要注意的是： 1、我们 $Hash$ 的是每个人当前分数与实际的分数差 2、$Hash$ 之前排序是因为相同数字是等效的，本质上只不过是将一些数字分成几堆，而如何分，顺序是无关的，因此是等效的 warning1、$Hash$ 判断有没有出现过是不能用 if(v[key])，因为可能这种情况无解，应用 if(v.find(key)!=v.end()). 2、别忘排序，$Hash$ 的是当前与实际分数的差 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} const LL base=1e9+7;//base的取值28也可以 inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,T,a[11],b[11],c[11],w,l; map&lt;LL,int&gt;v;//一开始想用ull自然溢出的，不过貌似没有什么问题 inline int dfs(rint x,rint y,rint sum) { if(x==n) return 1; if(b[x]+3*(n-y+1)&lt;a[x]) return 0;//可行性剪枝1 if(y&gt;n) {//一个人的所有比赛完后Hash，再搜索下一个人 for(rint i=x+1;i&lt;=n;++i) c[i]=a[i]-b[i]; sort(c+x+1,c+n+1);LL key=0; for(rint i=x+1;i&lt;=n;i++) key=key*base+c[i]; if(v.find(key)!=v.end()) return v[key];//0也是有可能的，因此不能用if(v[key]) return v[key]=dfs(x+1,x+2,sum);//注意记录值 } rint res=(n-x-1)*(n-x)/2+(n-y+1);//可行性剪枝2 if(sum+3*res&lt;T||sum+2*res&gt;T) return 0;res=0; if(w&amp;&amp;b[x]+3&lt;=a[x]) --w,b[x]+=3,res+=dfs(x,y+1,sum+3),b[x]-=3,++w;//可行性剪枝3 if(l&amp;&amp;b[x]+1&lt;=a[x]&amp;&amp;b[y]+1&lt;=a[y]) { ++b[x],++b[y],--l; res+=dfs(x,y+1,sum+2); --b[x],--b[y],++l; } if(w&amp;&amp;b[y]+3&lt;=a[y]&amp;&amp;b[y]+3+3*(n-x+1)/*可行性剪枝1*/) --w,b[y]+=3,res+=dfs(x,y+1,sum+3),b[y]-=3,++w; return res%base;//不要忘记取膜 } inline bool cmp(rint x,rint y){return x&gt;y;} int main() { rint i;n=read(); for(i=1;i&lt;=n;i++) T+=a[i]=read(); sort(a+1,a+n+1,cmp),w=T-n*(n-1),l=n*(n-1)/2-w;//算出胜场和平场 printf(&quot;%d&quot;,dfs(1,2,0)); return 0; } 推荐题目emmm 双倍经验 ~弱化版 Luogu P3154 [CQOI2009]循环赛","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://hovnySiLenCe.github.io/tags/DFS/"},{"name":"Hash","slug":"Hash","permalink":"http://hovnySiLenCe.github.io/tags/Hash/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P5596」[XR-4]题 解题报告","slug":"Luogu_P5596-[XR-4]Problem-Solution","date":"2019-10-24T05:54:01.000Z","updated":"2019-12-01T07:28:11.119Z","comments":true,"path":"2019/10/24/Luogu_P5596-[XR-4]Problem-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/24/Luogu_P5596-[XR-4]Problem-Solution/","excerpt":"","text":"题面给定自然数 $a,b$，求满足下列条件的自然数对 $(x,y)$ 的个数： y^2-x^2=ax+b解题思路数学题=瞎搞 分析数据范围已经暗示了一切，这是一道推推推公式的题啊 先考虑无数解的情况： 将 $x^2$ 移到右边 y^2=x^2+ax+b显然当 $x^2+ax+b$ 为完全平方时有无数解，即 $(\\frac a 2)^2=b$ 时有无数解，判断时可以写成 $a^2=4\\times b$ 接下去考虑其他情况 可以将左边因式分解康康有什么奇怪的东西： y^2-x^2=ax+b (y+x)(y-x)=ax+b令 $k=y-x$，则 $y=x+k$，代入： k(2x+k)=ax+b再乘出来： 2kx+k^2=ax+b将所有 $x$ 有关项移至左侧， (2k-a)x=b-k^2分参： x=\\frac {b-k^2} {2k-a}然后就推不下去 可以注意到，$x$ 应是自然数，所以 $\\frac {b-k^2} {2k-a}&gt;0$ 可以解一下上述方程： (b-k^2)(2k-a)>0显然可以看出三根分别为 $k_1=-\\sqrt b,k_2=\\sqrt b,k_3=\\frac a 2$ 而 $k$ 显然是自然数，$k_1=-\\sqrt b$ 就不要管了，那么有效的范围应该是： k\\in (\\frac a 2,\\sqrt b)\\ or\\ (\\sqrt b,\\frac a 2)反正是个奇奇怪怪的东西，幸好范围都不大，直接暴力枚举即可 warning1、记得开 $long\\ long$ 1、记得开 $long\\ long$ （什么是人类的本质 #include&lt;bits/stdc++.h&gt; #define rgt register #define LL long long #define rll rgt LL using namespace std; LL a,b,ans,x,L,R; int main() { rll k=0;scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); if(a*a==4*b){printf(&quot;inf&quot;);return 0;} x=sqrt(b);if(x*x==b) ans=1; while(1) {++k;L=2*k-a,R=b-k*k;//懒得判断区间左右端点大小，直接暴力枚举就好了， if(((L&gt;0&amp;&amp;R&gt;0)||(L&lt;0&amp;&amp;R&lt;0))&amp;&amp;(R%L==0)) ++ans; if(R&lt;0&amp;&amp;L&gt;0) break;//当R&lt;0&amp;&amp;L&gt;0时，再也不可能有解，因为两端始终保持异号状态 } printf(&quot;%lld\\n&quot;,ans);//貌似这里都不用开LL.. return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3569」[POI2014]KAR-Cards 解题报告","slug":"Luogu_P3569-[POI2014]KAR-Cards-Solution","date":"2019-10-23T14:17:56.000Z","updated":"2019-12-01T07:28:28.518Z","comments":true,"path":"2019/10/23/Luogu_P3569-[POI2014]KAR-Cards-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/23/Luogu_P3569-[POI2014]KAR-Cards-Solution/","excerpt":"","text":"题面前言又是毒瘤翻译题，看了半天没看懂 贴上翻译 有 $n$ 张卡牌，每张卡牌正反两面都有数字。现进行 $m$ 次操作，每次操作会将两张卡牌的位置互换，问每次操作后能否通过翻转任意数量的卡牌，使得正面数字构成的序列不下降。 解题思路线段树 分析显然，$n$ 和 $m$ 的范围分别在 $2\\times 10^5$ 和 $1\\times 10^6$ 的级别，因此肯定能用线段树维护 考虑如何维护 令当前区间为 $[l,r]$，中点为 $m$，显然只有 $[l,m]$ 和 $[m+1,r]$ 单调不降，且 $m$ 号位上的树小于 $m+1$ 号位上的数，$[l,r]$ 区间才能是单调区间，因此可以开三维数组 $f[k][0/1][0/1]$ 表示区间左端点和右端点是否翻转的情况，然后分别从四种中间情况转移过来 贴个 Update inline void Update(rint k,rint ls,rint m) { f[k][0][0]=(f[ls][0][0]&amp;&amp;b[m].fr&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][0])|| (f[ls][0][0]&amp;&amp;b[m].fr&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][0])|| (f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][0])|| (f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][0]); f[k][0][1]=(f[ls][0][0]&amp;&amp;b[m].fr&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1])|| (f[ls][0][0]&amp;&amp;b[m].fr&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][1])|| (f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1])|| (f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][1]); f[k][1][0]=(f[ls][1][0]&amp;&amp;b[m].fr&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][0])|| (f[ls][1][0]&amp;&amp;b[m].fr&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][0])|| (f[ls][1][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][0])|| (f[ls][1][1]&amp;&amp;b[m].bc&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][0]); f[k][1][1]=(f[ls][1][0]&amp;&amp;b[m].fr&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1])|| (f[ls][1][0]&amp;&amp;b[m].fr&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][1])|| (f[ls][1][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1])|| (f[ls][1][1]&amp;&amp;b[m].bc&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][1]); } 以 f[k][0][1] 为例 f[k][0][1] 表示该区间左端点不翻转，右端点翻转， 然后枚举分出来的两段区间的左右端情况，即可转移 f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1] 表示两段区间首尾分别不翻和翻，两段分别单调且连接后仍单调，则 f[k][0][1] 可构成单调不降序列 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 200003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,T,l,pos; struct node{ int fr,bc; inline void input() {fr=read(),bc=read();} }b[N],x,y; bool f[N&lt;&lt;2][2][2]; inline void Update(rint k,rint ls,rint m) {//转移，分4种情况，可以写成for f[k][0][0]=(f[ls][0][0]&amp;&amp;b[m].fr&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][0])|| (f[ls][0][0]&amp;&amp;b[m].fr&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][0])|| (f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][0])|| (f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][0]); f[k][0][1]=(f[ls][0][0]&amp;&amp;b[m].fr&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1])|| (f[ls][0][0]&amp;&amp;b[m].fr&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][1])|| (f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1])|| (f[ls][0][1]&amp;&amp;b[m].bc&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][1]); f[k][1][0]=(f[ls][1][0]&amp;&amp;b[m].fr&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][0])|| (f[ls][1][0]&amp;&amp;b[m].fr&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][0])|| (f[ls][1][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][0])|| (f[ls][1][1]&amp;&amp;b[m].bc&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][0]); f[k][1][1]=(f[ls][1][0]&amp;&amp;b[m].fr&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1])|| (f[ls][1][0]&amp;&amp;b[m].fr&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][1])|| (f[ls][1][1]&amp;&amp;b[m].bc&lt;=b[m+1].fr&amp;&amp;f[ls|1][0][1])|| (f[ls][1][1]&amp;&amp;b[m].bc&lt;=b[m+1].bc&amp;&amp;f[ls|1][1][1]); } inline void built(rint k,rint l,rint r) {//初始化 if(l==r) return f[k][0][0]=f[k][1][1]=1,void(); rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; built(ls,l,m),built(ls|1,m+1,r),Update(k,ls,m); } inline void Modify(rint k,rint l,rint r) {//修改 if(l==r) return b[l]=y,void(); rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; (pos&lt;=m)?Modify(ls,l,m):Modify(ls|1,m+1,r);Update(k,ls,m); } int main() { rint i,j;n=read(); for(i=1;i&lt;=n;i++) b[i].input(); built(1,1,n),T=read(); while(T--) { x=b[pos=read()],y=b[l=read()];//交换当成两次修改操作... Modify(1,1,n),y=x,pos=l,Modify(1,1,n); if(f[1][0][0]||f[1][0][1]||f[1][1][0]||f[1][1][1]) printf(&quot;TAK\\n&quot;); else printf(&quot;NIE\\n&quot;);//对整个区间首尾讨论一下 } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「算法导论」渐进记号&主定理 学习笔记 (咕)","slug":"A-IntroductiontoAlgorithms-MasterTheorem-Notes","date":"2019-10-18T12:48:38.000Z","updated":"2019-11-14T00:11:06.777Z","comments":true,"path":"2019/10/18/A-IntroductiontoAlgorithms-MasterTheorem-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/18/A-IntroductiontoAlgorithms-MasterTheorem-Notes/","excerpt":"","text":"引入有一天， $author$ 看到一个神奇的式子： \\large T(n)=9T(\\frac n 3)+n现求：上式的时间复杂度 可怜的 $author$ 做不出来，于是就进行一番神奇的操作，最后在某本厚得可以拿来防身的黑书上找了这神奇的解法——主定理 主定理：用渐进符号表示许多由分治法得到的递推关系式的方法 渐进记号要求：对于渐进记号中所有函数，均是渐进非负，也就是所谓的渐进正函数（对足够大的 $n$ 均为正的函数） 渐进记号一览： 渐进紧确记号：$\\Theta$ 渐进上界记号：$O$ 渐进下界记号：$\\Omega$ 非渐进紧确上界记号：$o$ 非渐进紧确下界记号：$\\omega$ $\\Theta$ 记号读作：$/‘θi:tə/$，$LaTeX$ 语法：\\Theta 对一个给定的函数 $g(n)$，用 $\\Theta(g(n))$ 来表示一下函数的集合： $\\Theta(g(n))={\\ f(n)$：存在正常量 $c_1$、$c_2$ 和 $n_0$，使得对所有 $n\\ge n_0$，有 $0\\le c_1g(n)\\le f(n)\\le c_2g(n)\\ }$ 我们称 $g(n)$ 是 $f(n)$ 的一个渐进紧确界 $(asymptotically\\ tight\\ bound)$ $O$ 记号读作：$/əu/$，$LaTeX$ 语法：O （别看了，就是字母O 对一个给定的函数 $g(n)$，用 $O(g(n))$ (读作”大 $Og(n)$ “，有时仅读作”$Og(n)$ “)来表示一下函数的集合： $O(g(n))=${ $f(n)$：存在正常量 $c$ 和 $n_0$，使得对所有 $n\\ge n_0$，有 $0\\le f(n)\\le cg(n)$ } $O$ 记号提供了渐进上界 $\\Omega$ 记号读作：$/oʊ’meɡə/$，$LaTeX$ 语法：\\Omega 对一个给定的函数 $g(n)$，用 $\\Omega(g(n))$ 来表示一下函数的集合： $\\Omega(g(n))=${ $f(n)$：存在正常量 $c$ 和 $n_0$，使得对所有 $n\\ge n_0$，有 $0\\le cg(n)\\le f(n)$ } $\\Omega$ 记号提供了渐进下界 主定理令 $a\\ge 1$ 和 $b&gt;1$ 是常数，$f(n)$ 是一个函数，$T(n)$ 是定义在非负整数上的递归式： \\large T(n)=aT(\\frac n b)+f(n)其中我们将 $\\frac n b$ 解释为 $\\lfloor \\frac n b \\rfloor$ 或 $\\lceil \\frac n b \\rceil$。那么 $T(n)$ 有如下渐进界： 若对某个函数 $\\epsilon &gt;0$ 有 $f(n)=O(n^{\\log_b{a-\\epsilon }})$，则 $T(n)=\\Theta(n^{\\log_ba})$。 若 $f(n)=\\Theta(n^{\\log_ba})$，则 $T(n)=\\Theta(n^{\\log_ba}\\lg n)$。 若对某个常数 $\\epsilon&gt;0$ 有 $f(n)=\\Omega(n^{\\log_ba+\\epsilon})$，且对某个函数 $c&lt;1$ 和所有足够大的 $n$ 有 $af(\\frac n b) \\le cf(n)$，则 $T(n)=\\Theta(f(n))$。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}],"tags":[{"name":"主定理","slug":"主定理","permalink":"http://hovnySiLenCe.github.io/tags/主定理/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}]},{"title":"「Author」模板集合 学习笔记 (更新中)","slug":"A-Author-Templates-Notes","date":"2019-10-10T07:59:54.000Z","updated":"2020-07-18T06:50:01.196Z","comments":true,"path":"2019/10/10/A-Author-Templates-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/10/A-Author-Templates-Notes/","excerpt":"","text":"$\\mathtt{Update}\\ \\mathtt{2019.12.3}$ 数据结构莫队选的是我写莫队(假装)顶峰时的代码 $\\mathtt{Link}$ #include&lt;bits/stdc++.h&gt; #define getchar() *(p++) #define rgt register #define rint rgt int #define N 1000007 using namespace std; struct node{ int l,r,i; }b[N]; int n,m,t,l,r,block,pos[N],Ans[N]; int s[N],a[N],d[N],f[N],sum[N],ans; char bf[1&lt;&lt;25],*p=bf; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline bool cmp(rgt node a,rgt node b) {//看似很飘的样子(奇偶性优化 return (pos[a.l]^pos[b.l])?a.l&lt;b.l:(pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r; } inline bool Add(rgt int x) {if(!sum[f[x]]++) ans^=a[x];} inline bool Del(rgt int x) {if(!(--sum[f[x]])) ans^=a[x];} int main() { rint i;bf[fread(bf,1,1&lt;&lt;25,stdin)]=&#39;\\0&#39;,n=read(); for(i=1;i&lt;=n;i++) d[i]=a[i]=read(),s[i]=s[i-1]^a[i]; m=read();sort(d+1,d+1+n),t=unique(d+1,d+1+n)-d-1,block=n/sqrt(m*0.9);//玄学的块的大小 for(i=1;i&lt;=n;i++) f[i]=lower_bound(d+1,d+t+1,a[i])-d,pos[i]=i/block; for(i=1;i&lt;=m;i++) b[i].l=read(),b[i].r=read(),b[i].i=i; sort(b+1,b+1+m,cmp),l=1; for(i=1;i&lt;=m;i++) {//尽量先Add再Del,否则可能会出现一些不必要的问题 while(r&lt;b[i].r) Add(++r); while(l&gt;b[i].l) Add(--l); while(r&gt;b[i].r) Del(r--); while(l&lt;b[i].l) Del(l++); Ans[b[i].i]=ans^s[b[i].l-1]^s[b[i].r]; } for(i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,Ans[i]); return 0; } 树链剖分树链剖分的理论复杂度是 $m\\log^2n$，但是有其优秀的常数，一般跑不满 $\\mathtt{Link}$ 其分为重链和长链剖分，这里写的是重链剖分，据某神仙说，树链剖分虽长但是吼打，是 $OIer$ $\\times \\times$ 的首选… #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100007 using namespace std; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int head[N],ver[N&lt;&lt;1],nxt[N&lt;&lt;1],in[N],a[N],out[N]; int fa[N],size[N],dep[N],son[N]; int seg[N],rev[N],top[N],num; LL f[N&lt;&lt;2],tag[N&lt;&lt;2],ans,p; int n,T,L,R,t,x,y,w,root; inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t, ver[++t]=x,nxt[t]=head[y],head[y]=t; } inline LL dec(rll x){return(x&gt;=p)?x-p:x;} inline void dfs1(rint k) { rint i,to; dep[k]=dep[fa[k]]+1,size[k]=1; for(i=head[k];i;i=nxt[i]) { to=ver[i];if(to==fa[k]) continue; fa[to]=k,dfs1(to),size[k]+=size[to]; if(size[to]&gt;size[son[k]])//重儿子 son[k]=to; } } inline void dfs2(rint k) { in[k]=num;//子树的其实可以不用这么维护，但是我懒的改了，in[k]=seg[k] if(son[k]) {//out[k]=seg[k]+size[k]-1 seg[son[k]]=++num, top[son[k]]=top[k], rev[num]=son[k], dfs2(son[k]); } rint i,to; for(i=head[k];i;i=nxt[i]) { to=ver[i];if(top[to]) continue; seg[to]=++num,rev[num]=top[to]=to; dfs2(to);//rev表示序号所对原来的位置 }out[k]=num; } inline void built(rint k,rint l,rint r) { if(l==r){f[k]=a[rev[l]];return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; built(ls,l,m),built(ls|1,m+1,r); f[k]=dec(f[ls]+f[ls|1]); } inline void push(rint k,rint l,rint r) { f[k]=(f[k]+tag[k]*(r-l+1))%p; if(l!=r) { rint ls=k&lt;&lt;1; tag[ls]=dec(tag[ls]+tag[k]), tag[ls|1]=dec(tag[ls|1]+tag[k]); }tag[k]=0; } inline void Modify(rint k,rint l,rint r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {tag[k]=w;return push(k,l,r);} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,m),Modify(ls|1,m+1,r); f[k]=dec(f[ls]+f[ls|1]); } inline void Query(rint k,rint l,rint r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {ans=dec(ans+f[k]);return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Query(ls,l,m),Query(ls|1,m+1,r); } #define fx top[x] #define fy top[y] inline void Add(rint x,rint y) { w=read()%p; while(fx!=fy) { if(dep[fx]&lt;dep[fy]) swap(x,y);//保证跳的是深度较小的点 L=seg[fx],R=seg[x], Modify(1,1,n),x=fa[fx];//跳轻边 } if(dep[x]&lt;dep[y]) swap(x,y); L=seg[y],R=seg[x],Modify(1,1,n); } inline void Ask(rint x,rint y) { while(fx!=fy) { if(dep[fx]&lt;dep[fy]) swap(x,y); L=seg[fx],R=seg[x], Query(1,1,n),x=fa[fx]; } if(dep[x]&lt;dep[y]) swap(x,y); L=seg[y],R=seg[x],Query(1,1,n); } int main() { rint i,op; n=read(),T=read(),root=read(),p=read(); for(i=1;i&lt;=n;i++) a[i]=read()%p; for(i=1;i&lt;n;i++) add(read(),read()); num=seg[root]=1,rev[1]=top[root]=root;//注意root不同 dfs1(root),dfs2(root),built(1,1,n);//建树 while(T--) { op=read(); if(op==1||op==3) { if(op==3) { x=read(),w=read()%p, L=in[x],R=out[x],Modify(1,1,n); } else Add(read(),read()); } else { ans=0; if(op==2) Ask(read(),read()); else x=read(),L=in[x],R=out[x],Query(1,1,n); printf(&quot;%lld\\n&quot;,ans); } } return 0; } 可持久化线段树第一次打可持久线段树（标记永久化），来自某道由 $\\color{red}{\\mathtt{b}}\\color{black}{\\mathtt{ztMinamoto}}\\%\\%\\%$ 翻译的题 $\\mathtt{Link}$ #include&lt;bits/stdc++.h&gt;//大致上和主席树类似，emmm...貌似主席树就是可持久化线段树... #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 100003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline LL read() { rll s=0,p=0; rgt char c=getchar(); while(!isdigit(c)) p=(c==&#39;-&#39;),c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return p?-s:s; } inline void getc(char&amp;c) { c=getchar();while(c&lt;&#39;A&#39;||c&gt;&#39;Z&#39;) c=getchar(); } struct node{ int ls,rs; LL sum,tag; }T[N*160]; int n,m,L,R,t,res,a[N],root[N];LL w,ans; inline void built(rint k,rint l,rint r) { cmax(t,k); if(l==r) {T[k].sum=a[l];return;} rint m=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; built(T[k].ls=ls,l,m),built(T[k].rs=ls|1,m+1,r), T[k].sum=T[ls].sum+T[ls|1].sum; } inline void Modify(rint l,rint r,rint &amp;x,rint y) { if(r&lt;L||R&lt;l) return; x=++t,T[t]=T[y]; if(L&lt;=l&amp;&amp;r&lt;=R) {T[x].tag+=w;return;} T[t].sum+=w*(min(r,R)-max(l,L)+1);//划重点，标记永久化的影响 rint m=(l+r)&gt;&gt;1; Modify(l,m,T[x].ls,T[y].ls), Modify(m+1,r,T[x].rs,T[y].rs); } inline void push(rll tag,rint l,rint r) { ans+=(min(R,r)-max(L,l)+1)*tag; } inline void Query(rint l,rint r,rint root) { if(r&lt;L||R&lt;l) return; if(T[root].tag) push(T[root].tag,l,r);//划重点，标记永久化的影响 if(L&lt;=l&amp;&amp;r&lt;=R) {ans+=T[root].sum;return;} rint m=(l+r)&gt;&gt;1; Query(l,m,T[root].ls),Query(m+1,r,T[root].rs); } int main() { rint i;char op; n=read(),m=read(); for(i=1;i&lt;=n;i++) a[i]=read(); built(1,1,n),root[0]=1; while(m--) { getc(op); if(op==&#39;C&#39;) { L=read(),R=read(),w=read(),++res; Modify(1,n,root[res],root[res-1]); } else if(op==&#39;Q&#39;) ans=0,L=read(),R=read(),Query(1,n,root[res]),printf(&quot;%lld\\n&quot;,ans); else if(op==&#39;H&#39;) ans=0,L=read(),R=read(),Query(1,n,root[read()]),printf(&quot;%lld\\n&quot;,ans); else res=read(); } return 0; } Link Cut Tree$LCT$ 还是比较好理解的，只是想当初为了 $LCT$ 学 $Splay$ 学的头大 $\\mathtt{Link}$ #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define N 300007 using namespace std; int fa[N],v[N],f[N],son[N][2]; int n,T,St[N],top;bool r[N]; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline bool Ide(rint x) {return son[fa[x]][1]==x;}//判断是左还是右儿子 inline bool Tol(rint x) {return (son[fa[x]][0]==x)||(son[fa[x]][1]==x);}//判断是否有实边相连 inline void Flip(rint x) {swap(son[x][0],son[x][1]),r[x]^=1;}//翻转 inline void push(rint x) {//下传翻转标记 if(!r[x]) return;r[x]=0; if(son[x][0]) Flip(son[x][0]); if(son[x][1]) Flip(son[x][1]); } inline void Update(rint x) { f[x]=f[son[x][0]]^f[son[x][1]]^v[x]; } inline void rotate(rgt int x) { rint y=fa[x],z=fa[y]; rint ys=Ide(x),zs=Ide(y),v=son[x][ys^1]; if(Tol(y)) son[z][zs]=x;fa[x]=z;//y连的是不是虚边 son[x][ys^1]=y,fa[y]=x; if(v) fa[v]=y;son[y][ys]=v; Update(y),Update(x);//Updata } inline void Splay(rint x) { rint y=x,z;St[top=1]=y; while(Tol(y)) St[++top]=y=fa[y];//这里用于下传标记再翻转 while(top) push(St[top--]); while(Tol(x)) { y=fa[x],z=fa[y]; if(Tol(y))//仍然判虚边 rotate((son[y][0]==x)^(son[z][0]==y)?x:y);//如果在一条链上就先rotate父亲 rotate(x);//这样能使期望树高为log } } inline void Access(rint x) {//将x和root连成一条链 for(rint y=0;x;x=fa[y=x]) Splay(x),son[x][1]=y,Update(x); } inline void Catch(rint x) {//使x成为root Access(x),Splay(x),Flip(x); } inline int Search(rint x) {//寻找最浅的点，Link和Cut专用 Access(x),Splay(x); while(son[x][0]) push(x),x=son[x][0]; Splay(x);return x; } inline void Link(rint x,rint y) { Catch(x); if(Search(y)!=x) fa[x]=y;//直接连虚边即可 } inline void Cut(rint x,rint y) { Catch(x); if(Search(y)==x&amp;&amp;fa[y]==x&amp;&amp;!son[y][0])//要判断一系列复杂的东西 fa[y]=son[x][1]=0,Update(x); } inline void Query(rint x,rint y) { Catch(x),Access(y),Splay(y); printf(&quot;%d\\n&quot;,f[y]); } int main() { rint i,p,x,y; n=read(),T=read(); for(i=1;i&lt;=n;i++) v[i]=read(); while(T--) { p=read(),x=read(),y=read(); if(p==0) Query(x,y); else if(p==1) Link(x,y); else if(p==2) Cut(x,y); else Splay(x),v[x]=y,Update(x); } return 0; } 貌似也是 $LCT$ 教会我卡常和压行（毒瘤码风 动态规划数位 DP数位 $DP$ 还是比较好理解的，需要注意的就是一些初始化和 $status$ 模板题 [SCOI2009]windy数 #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 13 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int l,r,t,num[N],f[N][N],ans; inline int dfs(rint k,rint st,rint op) { if(!k) return 1; if(!op&amp;&amp;~f[k][st]) return f[k][st];//对没有达到上限的一般情况记忆化 rint i,t=op?num[k]:9,res=0;//t表示的是当前枚举的上限 for(i=0;i&lt;=t;i++) { if(abs(st-i)&lt;2) continue; if(st==11&amp;&amp;i==0) res+=dfs(k-1,11,op&amp;(i==t)); else res+=dfs(k-1,i,op&amp;(i==t)); } if(!op) f[k][st]=res; return res; } inline int solve(rint x) { memset(f,-1,sizeof(f)),t=0;//个人感觉这里第二次不用memset while(x) num[++t]=x%10,x/=10; // do num[++t]=x%10,x/=10; while(x);这样就可以把0算进去，有些题目会要求，但是问题不大 return dfs(t,11,1); } int main() { l=read()-1,r=read();//对询问求见进行差分 printf(&quot;%d&quot;,solve(r)-solve(l)); return 0; } SAC#1 - 萌数 #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define p 1000000007 #define N 1003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int top,num[N],sum[N],bi[N]; int ans,f[N][11][11][2]; char a[N],b[N]; inline int dec(rint x){return(x&gt;=p)?x-p:x;} inline int dfs(rint k,rint sec,rint fir,rint st,rint zt,rint op) {//六维状态 if(st) return f[k][sec][fir][st]=op?sum[k]+1:bi[k+1]; if(!k) return st; if(!op&amp;&amp;~f[k][sec][fir][st]) return f[k][sec][fir][st]; rint i,t=op?num[k]:9;rll res=0; for(i=0;i&lt;=t;i++) res=dec(res+dfs(k-1,fir,(i==0&amp;&amp;zt)?-1:i,st|(i==sec||i==fir),zt&amp;(i==0),op&amp;(i==t))); if(!op) f[k][sec][fir][st]=res; return res; } int main() { rint i,j;bi[1]=1; for(i=2;i&lt;N;i++) bi[i]=(LL)bi[i-1]*10%p; scanf(&quot;%s%s&quot;,a+1,b+1),top=strlen(a+1); for(i=1;i&lt;=top;i++) num[i]=a[top-i+1]-&#39;0&#39;;--num[1]; i=1;while(num[i]&lt;0) --num[i+1],num[i]+=10,++i; if(!num[top]) --top;memset(f,-1,sizeof(f)); for(i=1;i&lt;=top;i++) sum[i]=(sum[i-1]+(LL)num[i]*bi[i])%p; ans=-dfs(top,-1,-1,0,1,1),top=strlen(b+1); for(i=1;i&lt;=top;i++) num[i]=b[top-i+1]-&#39;0&#39;; for(i=1;i&lt;=top;i++) sum[i]=(sum[i-1]+(LL)num[i]*bi[i])%p; // memset(f,-1,sizeof(f));第二次真不用memset ans+=dfs(top,-1,-1,0,1,1),printf(&quot;%d&quot;,(ans%p+p)%p); return 0; } 求每位数的和 SP17247 PR003004 - Digit Sum #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} int num[19],t,nm,T; LL f[19][191][2],l,r; inline LL dfs(rint k,rint st,rint op) { if(!k) return st; if(~f[k][st][op]) return f[k][st][op]; rint i,t=op?num[k]:9;rll res=0; for(i=0;i&lt;=t;i++) res+=dfs(k-1,st+i,op&amp;(i==t)); return f[k][st][op]=res; } inline LL solve(rll c) { t=0;while(c) num[++t]=c%10,c/=10; memset(f,-1,sizeof(f));//记得初始化为0 return dfs(t,0,1); } int main() { scanf(&quot;%d&quot;,&amp;T); while(T--) scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r),l=max(l-1,0ll),//不能为-1 printf(&quot;%lld\\n&quot;,solve(r)-solve(l));//差分 return 0; } 求数字出现的次数 Luogu P2602 [ZJOI2010]数字计数 对于这题我也不知道为什么开结构体所有一起算会炸，发现问题的联系我跪谢 最恐怖的是稍微改点地方答案就不同，$IDE$ 上跑的结果也不同 $Wrong\\ Answer\\ version$ #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 11 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} struct node{ LL s[11];int p; inline node operator+ (const node a) const{ node c; for(rint i=0;i&lt;=9;i++) c.s[i]=s[i]+a.s[i]; return c; } inline node operator- (const node a) const{ node c; for(rint i=0;i&lt;=9;i++) c.s[i]=s[i]-a.s[i]; return c; } }f[13][11],ans,init; int num[13],top; LL l,r,a[11],sum[13],b[15]; inline node dfs(rint k,rint st,rint zt,rint op) { node res=init; if(!zt) res.s[st]+=op?sum[k]+1:b[k+1]; if(!k) return res; if(!op&amp;&amp;f[k][st].p) return f[k][st]; rint i,t=op?num[k]:9; for(i=0;i&lt;=t;i++) res=res+dfs(k-1,i,zt&amp;(i==0),op&amp;(i==t)); if(!op) f[k][st]=res; return res; } inline void solve(rll l,rll r) { top=0;do num[++top]=r%10,sum[top]=num[top]*b[top]+sum[top-1],r/=10; while(r);ans=dfs(top,0,1,1); top=0;do num[++top]=l%10,sum[top]=num[top]*b[top]+sum[top-1],l/=10; while(l);ans=ans-dfs(top,0,1,1); } int main() { rint i;b[1]=init.p=1; for(i=2;i&lt;13;i++) b[i]=b[i-1]*10; scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r),solve(l-1,r); for(i=0;i&lt;=9;++i) printf(&quot;%lld &quot;,ans.s[i]); return 0; } $Accepted\\ version$ #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return (a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return (a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int t,num[15]; LL l,r,f[15][15][2][2]; inline LL dfs(rint k,rint st,rint zt,rint op,rint nm) { if(!k) return st; if(~f[k][st][zt][op]) return f[k][st][zt][op]; rint i,t=op?num[k]:9;rll res=0; for(i=0;i&lt;=t;i++) res+=dfs(k-1,st+((!zt||i)&amp;&amp;i==nm),zt&amp;(i==0),op&amp;(i==t),nm);//前导0的特判 f[k][st][zt][op]=res; return res; } inline LL solve(rll x,rint nm) { t=0;while(x) num[++t]=x%10,x/=10; memset(f,-1,sizeof(f));return dfs(t,0,1,1,nm); } int main() { scanf(&quot;%lld%lld&quot;,&amp;l,&amp;r),--l; for(rint i=0;i&lt;=9;i++) printf(&quot;%lld &quot;,solve(r,i)-solve(l,i));//对每位一次计数 return 0; } 图论缩点没想到缩点代码居然还有小长 $\\mathtt{Link}$ #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define M 200007 #define N 10007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} int head[N],h[N],ver[M],nxt[M]; int dfn[N],low[N],bl[N],res; int a[N],f[N],d[N]; int n,m,num,ans,t; int St[N],top; bool vis[N]; inline int read() { rint s,p;s=p=0; rgt char c=getchar(); while(!isdigit(c)) p=(c==&#39;-&#39;),c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return p?-s:s; } inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t; } inline void Add(rint x,rint y) { ver[++t]=y,nxt[t]=h[x],h[x]=t; } inline void tarjan(rint k) { dfn[k]=low[k]=++num,St[++top]=k; for(rint i=head[k],to;i;i=nxt[i]) { to=ver[i]; if(!dfn[to]) tarjan(to),cmin(low[k],low[to]); else if(!bl[to]) cmin(low[k],dfn[to]);//这个特判很重要！ } if(dfn[k]==low[k]) { bl[k]=++res,f[res]=a[k]; while(St[top]!=k) bl[St[top]]=res,f[res]+=a[St[top--]]; top--; } } inline void solve() { rint i,to,cur; queue&lt;int&gt;p; for(i=1;i&lt;=res;i++) if(!d[i]) cmax(ans,f[i]),p.push(i); while(!p.empty()) { cur=p.front(),p.pop(); for(i=h[cur];i;i=nxt[i]) { to=ver[i],d[to]--, cmax(f[to],a[to]+f[cur]), cmax(ans,f[to]); if(!d[to]) p.push(to); } } } int main() { rint i,j,to,x,y; n=read(),m=read(); for(i=1;i&lt;=n;i++) a[i]=read(); for(i=1;i&lt;=m;i++) x=read(),add(x,read()); for(i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i);//每个都要做一下 for(i=1;i&lt;=res;i++) a[i]=f[i]; for(i=1;i&lt;=n;i++)//二次加点有点复杂 for(j=head[i];j;j=nxt[j]) { to=ver[j]; if(bl[i]==bl[to]) continue; Add(bl[i],bl[to]),++d[bl[to]]; }solve(); printf(&quot;%d&quot;,ans); return 0; } 网络最大流网络流背板子，只是建边较难，卡Dinic是违法的 $\\mathtt{Link}$ #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define M 100007 #define N 10007 using namespace std; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct node{ int to,nxt,cap; node(int a,int b,int c):to(a),nxt(b),cap(c){ } node(){ } }b[M&lt;&lt;1]; int head[N],dep[N]; int n,m,S,T,t=1,Maxflow; inline void add(rint x,rint y,rint cap) {//正边流量为cap，反边流量为0 b[++t]=node(y,head[x],cap),head[x]=t, b[++t]=node(x,head[y],0),head[y]=t; } inline bool BFS() { rint i,c,to;queue&lt;int&gt;p; memset(dep,0,sizeof(dep)); dep[S]=1,p.push(S);//dep[S]一定要赋为0 while(!p.empty()) { c=p.front(),p.pop(); for(i=head[c];i;i=b[i].nxt) { to=b[i].to; if(b[i].cap&amp;&amp;!dep[to]) { dep[to]=dep[c]+1;//一定要先标记 if(to==T) return 1; p.push(to); } } }return 0; } inline int Dinic(rint k,rint flow) { if(k==T) return flow; rint i,to,cap,res,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].nxt) {//rest的条件不要忘记 to=b[i].to,cap=b[i].cap;//可以用上当前弧优化 if(cap&amp;&amp;dep[to]==dep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) dep[to]=0; b[i].cap-=res, b[i^1].cap+=res, rest-=res; } }return flow-rest; } int main() { rint i,x,y,flow=0; n=read(),m=read(),S=read(),T=read(); for(i=1;i&lt;=m;i++) x=read(),y=read(),add(x,y,read()); while(BFS()) while((flow=Dinic(S,inf)))//这里还可以用上当前弧优化 Maxflow+=flow; printf(&quot;%d&quot;,Maxflow); return 0; } 后续还会贴上最大流的一些优化 字符串manacher 算法Luogu P3805 【模板】manacher算法 #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define N 11000007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,m,len,mx,id,p[N&lt;&lt;1],ans; char s[N&lt;&lt;1],st[N]; inline void init() { rint i;len=strlen(st+1); s[0]=&#39;!&#39;,s[1]=&#39;#&#39;, n=(len&lt;&lt;1|1)+1; for(i=1;i&lt;=len;i++)//扩展为 !#st_1#st_2...#? 形式 s[i&lt;&lt;1]=st[i],s[i&lt;&lt;1|1]=&#39;#&#39;; s[n]=&#39;?&#39;;return; } inline void manacher() { rint i;init(); for(i=1;i&lt;=n;i++) { if(i&lt;mx) p[i]=min(p[(id&lt;&lt;1)-i],mx-i);//合理利用已处理部分 else p[i]=1; while(s[i-p[i]]==s[i+p[i]]) ++p[i]; if(i+p[i]&gt;mx) mx=i+p[i],id=i; } } int main() { rint i;scanf(&quot;%s&quot;,st+1); manacher();for(i=1;i&lt;n;i++) cmax(ans,p[i]); printf(&quot;%d&quot;,ans-1);return 0; } KMP 算法Luogu P3375 【模板】KMP字符串匹配 #include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define N 1000003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int n,A,B,p[N]; char a[N],b[N]; int main() { rint i,j; scanf(&quot;%s&quot;,a+1),scanf(&quot;%s&quot;,b+1); A=strlen(a+1),B=strlen(b+1); for(i=2,j=0;i&lt;=B;i++) {//求next因此从i=2开始 while(j&amp;&amp;b[i]!=b[j+1]) j=p[j]; if(b[i]==b[j+1]) ++j;p[i]=j; } for(i=1,j=0;i&lt;=A&amp;&amp;j&lt;=B;i++) { while(j&amp;&amp;(j==B||a[i]!=b[j+1])) j=p[j]; if(a[i]==b[j+1]) ++j; if(j==B) printf(&quot;%d\\n&quot;,i-B+1);//出现的位置 } for(i=1;i&lt;=B;i++) printf(&quot;%d &quot;,p[i]); return 0; } 后缀数组Luogu P3809 【模板】后缀排序 (SA) #include&lt;bits/stdc++.h&gt; #define N 1000010 using namespace std; int n,m,x[N],y[N],c[N],sa[N],p; char s[N]; int main() { int i,k; scanf(&quot;%s&quot;,s); n=strlen(s);m=125; for(i=0;i&lt;n;i++) c[x[i]=s[i]]++; for(i=1;i&lt;m;i++) c[i]+=c[i-1]; for(i=0;i&lt;n;i++) sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1) { p=0; for(i=n-k;i&lt;n;i++) y[p++]=i; for(i=0;i&lt;n;i++) if(sa[i]&gt;=k) y[p++]=sa[i]-k; for(i=0;i&lt;m;i++) c[i]=0; for(i=0;i&lt;n;i++) c[x[y[i]]]++; for(i=1;i&lt;m;i++) c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--) sa[--c[x[y[i]]]]=y[i]; swap(x,y);p=1;x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k])?p-1:p++; if(p&gt;=n) break; m=p; } for(i=0;i&lt;n;i++) printf(&quot;%d &quot;,sa[i]+1); return 0; }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}],"tags":[{"name":"模板","slug":"模板","permalink":"http://hovnySiLenCe.github.io/tags/模板/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}]},{"title":"「Contest」2019.09.15 Cx Solution (咕)","slug":"A-Contest-2019_09_15_Cx-Solution","date":"2019-10-10T07:47:08.000Z","updated":"2019-11-02T10:03:39.158Z","comments":true,"path":"2019/10/10/A-Contest-2019_09_15_Cx-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/10/A-Contest-2019_09_15_Cx-Solution/","excerpt":"","text":"Source T1","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"http://hovnySiLenCe.github.io/tags/模拟赛/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2599」[ZJOI2009]取石子游戏 解题报告","slug":"Luogu_P2599-[ZJOI2009]PebbleGame-Solution","date":"2019-10-08T07:59:42.000Z","updated":"2019-12-01T07:28:32.268Z","comments":true,"path":"2019/10/08/Luogu_P2599-[ZJOI2009]PebbleGame-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/08/Luogu_P2599-[ZJOI2009]PebbleGame-Solution/","excerpt":"","text":"题面前言非常神仙的动态规划 解题思路动态鬼规划 分析感觉这道题还是比较看技巧的，（是谁想出来的，太妙了呀！推出去打 用 $L[i][j]$ 表示在 $[i,j]$ 这个区间左侧（也就是 $i-1$ 的位置）放多少石子可以保证先手必败 同上，用 $R[i][j]$ 表示在 $[i,j]$ 这个区间右侧放多少石子可以保证先手必败 接下去，我们要证明一下 $L[i][j]$ 和 $R[i][j]$ 的唯一（存在）性 $L[i][j]$ 和 $R[i][j]$ 的唯一性以 $L[i][j]$ 为例（$R[i][j]$ 同理）， 1、若 $L[i][j]$ 不唯一，设其中两个值分别为 $L_1,L_2$ （$L_1 &lt; L_2$），显然 $L_2$ 可以经过先手取一次变成 $L_1$ 的状态，与此时与先手必败矛盾，所以 $L[i][j]$ 唯一存在 2、若 $L[i][j]$ 不存在，也就是说在 $[i,j]$ 区间石子左侧无论放多少，先手都是必胜态，那么也就是说从右侧拿石子就会达到一个必败态，但是由于，左侧的石子数可以任意，那么就变成了$L[i][j]$ 不唯一的情况（除左侧一堆石子数是不一样外，其他都一样），这与我们在 1 中得出的结论矛盾，一次 $L[i][j]$ 必定存在 考虑 $L[i][j]$ 和 $R[i][j]$ 的初始化边界即为：$i=j$ 时， $L[i][i]$ 与 $R[i][i]$ 的状态，这个时候就是个 $Nim$ 游戏，显然 $L[i][i]=R[i][i]=a[i]$ 即可 考虑 $L[i][j]$ 和 $R[i][j]$ 的转移以 $L[i][j]$ 为例，分类讨论 0、显然 $L[i][j]$ 的转移与 $L[i][j-1]$ 以及 $R[i][j-1]$ 有关，与 $L[i+1][j]$ 以及 $R[i+1][j]$ 无关 那么，令 $x=a[j]$ （第 $j$ 堆石子数），$l=L[i][j-1]$，$r=R[i][j-1]$ 1、当 $r=x$ 时，$L[i][j]=0$ 此时 $[i,j]$ 已是先手必败态，因此 $L[i][j]=0$ 即可 2、当 $x&lt;l$ 且 $x&lt;r$ 时，$L[i][j]=x$ 也就是说此时两侧的石子数一致，无论先手怎么取，后手只要模仿先手在另一侧取相同的数量，这样就能保证先手先取完，此时左侧或右侧肯定仍有一堆没有取完，此时可以等价认为当前状态是 先手从 $l$ 或 $r$ 的状态取一定数量的石子转移而来 3、当 $l&lt;x&lt;r$ 时，$L[i][j]=x+1$ 若先手在左侧取，剩下石子数为 $rest$ ， 当 $rest=0$ 时，等价于 先手在 $r$ 的状态下，在右侧取了一定数量的石子转移而来 当 $rest&lt;l$ 时，后手只要将右侧的石头取到和 $rest$ 相同的数目，即可转移到 2 的情况 当 $rest=l$ 时，后手将右侧取完就可以让先手达到必败态 当 $rest&gt;l$ 时，后手只要将右侧石子取到 $rest-1$ 即可重新回到当前状态 若先手在右侧取，剩下石子数为 $rest$ ， 当 $rest=0$ 时，后手把左侧石子取到 $l$ 即可 当 $rest&lt;l$ 时，同上，取左侧，可以转移到 2 的情况 当 $rest&gt;=l$ 时，后手通过在左侧或右侧取，使 左侧石子数=右侧石子数+1 即可 4、当 $l&gt;x&gt;r$ 时，$L[i][j]=x-1$ 这种情况与 3 一致，可以认为只是互换了一下左右两侧而已 5、当 $x&gt;l$ 且 $x&gt;r$ 时，$L[i][j]=x$ 若先手在左侧取，剩下石子数为 $rest$， 当 $rest=0$ 时，后手将右侧石子取至 $r$ 即可 当 $l&lt;rest$ 时，可转移至 2 当 $l=rest$ 时，右侧直接取完 当 $rest \\in [l,r]$ 或 $rest\\in[r,l]$ 时，可转移至 3 或 4 当 $l&lt;rest$ 且 $r&lt;rest$ 时，保持当前状态即可 判断由于左侧和右侧是等价的，因此最后只需判断 $L[2][n]$ 是否等于 $a[1]$ Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rLL rgt LL #define inf 0x7f7f7f7f #define N 1003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} int n,T,a[N],L[N][N],R[N][N]; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int main() { int i,j,l,r,k,x; T=read(); while(T--) { n=read(); for(i=1;i&lt;=n;i++) L[i][i]=R[i][i]=a[i]=read();//初始化 for(k=2;k&lt;n;k++) {//枚举区间长度 for(i=1,j=i+k-1;j&lt;=n;i++,j++) {//枚举左右端点 x=a[j],l=L[i][j-1],r=R[i][j-1]; if(x==r) L[i][j]=0;//情况1 else if((x&gt;l&amp;&amp;x&gt;r)||(x&lt;l&amp;&amp;x&lt;r)) L[i][j]=x;//情况2、5 else if(r&lt;x&amp;&amp;x&lt;l) L[i][j]=x-1;//情况4 else L[i][j]=x+1;//情况3 x=a[i],l=L[i+1][j],r=R[i+1][j];//同理可得 if(x==l) R[i][j]=0; else if((x&gt;l&amp;&amp;x&gt;r)||(x&lt;l&amp;&amp;x&lt;r)) R[i][j]=x; else if(l&lt;x&amp;&amp;x&lt;r) R[i][j]=x-1; else R[i][j]=x+1; } } putchar(a[1]==L[2][n]?&#39;0&#39;:&#39;1&#39;),putchar(&#39;\\n&#39;); } return 0; } 参考&amp;鸣谢@Jason_Yvan(Luogu) @yybyyb(Luogu)","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Contest」[JudgeOI]Homer·VS·Judge 解题报告 (咕)","slug":"A-Contest-JudgeOI2019-HomerVSJudge-Solution","date":"2019-10-04T07:56:21.000Z","updated":"2019-11-02T10:03:38.717Z","comments":true,"path":"2019/10/04/A-Contest-JudgeOI2019-HomerVSJudge-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/04/A-Contest-JudgeOI2019-HomerVSJudge-Solution/","excerpt":"","text":"Source T1","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"http://hovnySiLenCe.github.io/tags/模拟赛/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Contest」SCPFoundation 解题报告 (咕)","slug":"A-Contest-SCPFoundation-Solution","date":"2019-10-03T07:06:29.000Z","updated":"2019-11-02T10:03:38.317Z","comments":true,"path":"2019/10/03/A-Contest-SCPFoundation-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/10/03/A-Contest-SCPFoundation-Solution/","excerpt":"","text":"Source T1Sol","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"http://hovnySiLenCe.github.io/tags/模拟赛/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3554」[POI2013]LUK-Triumphal arch 解题报告 (咕)","slug":"A-Luogu_P3554-[POI2013]LUK-Triumphal_arch-Solution","date":"2019-09-29T14:20:01.000Z","updated":"2019-12-01T07:28:45.363Z","comments":true,"path":"2019/09/29/A-Luogu_P3554-[POI2013]LUK-Triumphal_arch-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/09/29/A-Luogu_P3554-[POI2013]LUK-Triumphal_arch-Solution/","excerpt":"","text":"题面前言一开始疯狂看不懂题意，然后就发现了神奇的东西 $Link$ $Ps:$ 题号 $3420$ 解题思路二分、树形DP 分析显然，答案存在单调性，因此可以二分 二分之后就是如何 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rLL rgt LL #define inf 0x7f7f7f7f #define N 300007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} int n,t,ver[N&lt;&lt;1],nxt[N&lt;&lt;1],head[N],ans,m,f[N]; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t, ver[++t]=x,nxt[t]=head[y],head[y]=t; } inline void dfs(rint k,rint fa) { rint i,to; for(i=head[k];i;i=nxt[i]) { to=ver[i];if(to==fa) continue; dfs(to,k),f[k]+=f[to]+1; }f[k]-=m,cmax(f[k],0); } int main() { rint i,l,r;r=n=read(),l=0; for(i=1;i&lt;n;i++) add(read(),read()); while(l&lt;=r) { memset(f,0,sizeof(f)), m=(l+r)&gt;&gt;1,dfs(1,0); if(!f[1]) ans=m,r=m-1; else l=m+1; }printf(&quot;%d&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://hovnySiLenCe.github.io/tags/二分/"},{"name":"树形DP","slug":"树形DP","permalink":"http://hovnySiLenCe.github.io/tags/树形DP/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P1210」[HNOI2003]消防局的设立 解题报告","slug":"Luogu_P2279-[HNOI2003]FireStation-Solution","date":"2019-09-26T04:57:49.000Z","updated":"2019-12-01T07:28:34.365Z","comments":true,"path":"2019/09/26/Luogu_P2279-[HNOI2003]FireStation-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/09/26/Luogu_P2279-[HNOI2003]FireStation-Solution/","excerpt":"","text":"题面即用半径为 $2$ 的圆覆盖一棵树的最少圆个数 解题思路树形 $DP$ $/$ 神仙贪心 分析一个点的状态比较少，因此可以 食 用动态规划 但是状态并不是只有选这个点和不选这个点两种，因为半径变大之后 状态就会复杂一点，变成： 设该点为 $k$，则 1、选 $k$ 这个点 2、不选 $k$，但 $k$ 距其子树中被选结点的最短距离为 $1$ 3、不选 $k$，但 $k$ 距其子树中被选结点的最短距离为 $2$ 4、不选 $k$，但 $k$ 距其子树中被选结点的最短距离为 $3$ 5、不选 $k$，但 $k$ 距其子树中被选结点的最短距离为 $4$ 也就是分五种情况讨论 f[k][0]: 选该点的最小花费 f[k][1]: 该点距其子树中被选结点的最短距离为1的最小花费 f[k][2]: 该点距其子树中被选结点的最短距离为2的最小花费 f[k][3]: 该点距其子树中被选结点的最短距离为3的最小花费 f[k][4]: 该点距其子树中被选结点的最短距离为4的最小花费 显然，（$to$ 为 $k$ 的子结点） 1、f[k][0] 至 f[k][4] 所需满足的条件越来越少，也就是说，f[k][i-1] 的值可以更新 f[k][i],i belong to {1,2,3,4} 2、f[k][3] 和 f[k][4] 分别可以由其子结点的 f[to][2] 和 f[to][3] 直接更新 3、f[k][0] 可以由 f[to][4] 直接更新 这样之后，我们再讨论下 f[k][1] 和 f[k][2] 的情况即可 f[k][1] 由 f[to][0] 转移而来，显然只需要一个子结点能覆盖到即可，也就是说可以枚举每个 $to$ ，然后用 f[to][0] + 其他子结点的 f[_][3] 更新答案 f[k][2] 由 f[to][1] 转移而来，同理，可以枚举每个子结点，然后 f[to][1] + 其他子结点的 f[_][2] 更新答案 转移代码： inline void dfs(rint k) { rint i,to,sum=0,res=0;f[k][1]=f[k][2]=inf; for(i=head[k];i;i=nxt[i]) { to=ver[i],dfs(to); if(f[k][0]&lt;inf) f[k][0]+=f[to][4]; if(sum&lt;inf) sum+=f[to][2]; if(res&lt;inf) res+=f[to][3]; if(f[k][3]&lt;inf) f[k][3]+=f[to][2]; if(f[k][4]&lt;inf) f[k][4]+=f[to][3]; } for(i=head[k];i;i=nxt[i]) { to=ver[i]; if(f[to][3]&lt;inf) cmin(f[k][1],res-f[to][3]+f[to][0]); if(f[to][2]&lt;inf) cmin(f[k][2],sum-f[to][2]+f[to][1]); } for(i=1;i&lt;5;i++) cmin(f[k][i],f[k][i-1]); } warning1、间接计算的状态要赋初值为 inf 2、如果累加的时候大于 inf，应停止更新，因为这种情况必定不满足 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rLL rgt LL #define inf 0x3f3f3f3f #define N 1003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K b){return(a&gt;b)?a=b,1:0;} int n,t,ver[N],nxt[N],head[N],f[N][5]; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(rint x,rint y) { ver[++t]=y,nxt[t]=head[x],head[x]=t; } inline void dfs(rint k) { rint i,to,sum=0,res=0;f[k][1]=f[k][2]=inf;//注意两种间接计算的状态要计算初值 for(i=head[k];i;i=nxt[i]) { to=ver[i],dfs(to); if(f[k][0]&lt;inf) f[k][0]+=f[to][4]; if(sum&lt;inf) sum+=f[to][2]; if(res&lt;inf) res+=f[to][3];//处理总和间接转移 if(f[k][3]&lt;inf) f[k][3]+=f[to][2]; if(f[k][4]&lt;inf) f[k][4]+=f[to][3];//直接转移 } for(i=head[k];i;i=nxt[i]) { to=ver[i]; if(f[to][3]&lt;inf) cmin(f[k][1],res-f[to][3]+f[to][0]); if(f[to][2]&lt;inf) cmin(f[k][2],sum-f[to][2]+f[to][1]);//间接转移 } for(i=1;i&lt;5;i++) cmin(f[k][i],f[k][i-1]);//更新 } int main() { rint i;n=read(); for(i=2;i&lt;=n;i++) add(read(),i); dfs(1),printf(&quot;%d\\n&quot;,f[1][2]); return 0; } 另一种解法神仙贪心，Link 先将整棵树的结点按深度排序，记录一个 o[_] 表示到最近能被覆盖的点的距离 然后如果这个点超出了范围，也就是 o[_]&gt;2 那么在选择这个点，改变其 一到四 辈祖先的 o[_] 值即可 Code#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define N 2020 #define FOR(i,a,b) for(int i=a;i&lt;=b;i++) using namespace std; int n,b[N],f[N],d[N],o[N],ans,u,v,w; bool cmp(int x,int y){return d[x]&gt;d[y];} int main(){ scanf(&quot;%d&quot;,&amp;n);b[1]=1,o[1]=o[0]=N; FOR(i,2,n) scanf(&quot;%d&quot;,&amp;f[i]),d[i]=d[f[i]]+1,b[i]=i,o[i]=N; sort(b+1,b+n+1,cmp); FOR(i,1,n){ v=b[i],w=f[v],u=f[f[v]]; o[v]=min(o[v],min(o[w]+1,o[u]+2)); if(o[v]&gt;2){ o[u]=0,ans++; o[f[u]]=min(o[f[u]],1),o[f[f[u]]]=min(o[f[f[u]]],2); } }printf(&quot;%d&quot;,ans); }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://hovnySiLenCe.github.io/tags/树形DP/"},{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「OI-wiki」 Lucas&ExLucas定理 学习笔记 (咕)","slug":"A-Oiwiki-Lucas&ExLucas-Notes","date":"2019-09-22T06:50:23.000Z","updated":"2019-11-02T10:03:35.550Z","comments":true,"path":"2019/09/22/A-Oiwiki-Lucas&ExLucas-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/09/22/A-Oiwiki-Lucas&ExLucas-Notes/","excerpt":"","text":"写在前面原文 $Link$ 引首众所周知，组合数是个很恶心重要的东西 \\large C_n^m=\\binom{n}{m}关于组合数和杨辉三 $jio$ 的关系： 同样的递推方式 \\large C_n^m=C_{n-1}^m+C_{n-1}^{m-1}","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://hovnySiLenCe.github.io/tags/数学/"},{"name":"Lucas定理","slug":"Lucas定理","permalink":"http://hovnySiLenCe.github.io/tags/Lucas定理/"},{"name":"扩展Lucas定理","slug":"扩展Lucas定理","permalink":"http://hovnySiLenCe.github.io/tags/扩展Lucas定理/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}]},{"title":"「某讲稿」 点分治 学习笔记 (咕)","slug":"A-LectureNotes-TreeDivide-Notes","date":"2019-09-20T13:46:14.000Z","updated":"2019-11-02T10:03:37.501Z","comments":true,"path":"2019/09/20/A-LectureNotes-TreeDivide-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/09/20/A-LectureNotes-TreeDivide-Notes/","excerpt":"","text":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"http://hovnySiLenCe.github.io/tags/点分治/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}]},{"title":"「Contest」2019.09.08 Cx Solution (咕)","slug":"A-Contest-2019_09_08_Cx-Solution","date":"2019-09-15T07:46:53.000Z","updated":"2019-11-02T10:03:39.573Z","comments":true,"path":"2019/09/15/A-Contest-2019_09_08_Cx-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/09/15/A-Contest-2019_09_08_Cx-Solution/","excerpt":"","text":"Source T1","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"http://hovnySiLenCe.github.io/tags/模拟赛/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4449」于神之怒加强版 解题报告 (咕)","slug":"Luogu_P4449-God'sBlaze-Solution","date":"2019-08-30T01:02:33.000Z","updated":"2019-12-01T07:28:23.730Z","comments":true,"path":"2019/08/30/Luogu_P4449-God'sBlaze-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/08/30/Luogu_P4449-God'sBlaze-Solution/","excerpt":"","text":"$Link$Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rLL rgt LL #define inf 0x7f7f7f7f #define p 1000000007 #define N 5000000 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} int n,m,T,t,k,mu[N+3],f[N+3],pr[N],res,ans; bool v[N+3]; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline int Pow(rLL a) { rint b=k;rLL res=1; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1) res=res*a%p;return res; } inline void init() { rint i,j,c;mu[1]=1; for(i=2;i&lt;=N;i++) { if(!v[i]) pr[++t]=i,mu[i]=-1; for(j=1;j&lt;=t;++j) { c=i*pr[j];if(c&gt;N) break;v[c]=1; if(i%pr[j]) mu[c]=-mu[i]; else break; } } for(i=1;i&lt;=N;i++) { c=Pow(i); for(j=i;j&lt;=N;j+=i) f[j]=(f[j]+c*mu[j/i])%p; } for(i=2;i&lt;=N;i++) f[i]=(f[i]+f[i-1])%p; } inline void solve() { if(n&gt;m) n^=m^=n^=m;ans=0; for(rint l=1,r;l&lt;=n;l=r+1) { r=min(n/(n/l),m/(m/l)), ans=(ans+1ll*(n/l)*(m/l)%p*(f[r]-f[l-1])%p)%p; }printf(&quot;%d\\n&quot;,(ans+p)%p); } int main() { T=read(),k=read(),init(); while(T--) n=read(),m=read(),solve(); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://hovnySiLenCe.github.io/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://hovnySiLenCe.github.io/tags/莫比乌斯反演/"},{"name":"数论分块","slug":"数论分块","permalink":"http://hovnySiLenCe.github.io/tags/数论分块/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3172」[CQOI2015]选数 解题报告","slug":"Luogu_P3172-[CQOI2015]SelectNumber-Solution","date":"2019-08-30T00:59:06.000Z","updated":"2019-12-01T07:28:30.988Z","comments":true,"path":"2019/08/30/Luogu_P3172-[CQOI2015]SelectNumber-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/08/30/Luogu_P3172-[CQOI2015]SelectNumber-Solution/","excerpt":"","text":"$Link$求 \\large \\sum_{a_1=L}^H\\sum_{a_2=L}^H\\cdots\\sum_{a_n=L}^H[\\gcd\\limits_{i=1}^n(a_i)=k]解题思路莫比乌斯反演 （都是套路 分析先把 $H$ 用 $R$ 代替，（太难看了 然后就珂以大力推柿子了 先根据套路，把 $k$ 除掉 \\large \\sum_{a_1=\\lceil \\frac L k \\rceil }^{\\lfloor \\frac R k \\rfloor}\\cdots\\sum_{a_n=\\lceil \\frac L k \\rceil }^{\\lfloor \\frac R k \\rfloor}[\\gcd\\limits_{i=1}^n(a_i)=1]之后运用反演结论，（还是套路 \\large \\sum_{a_1=\\lceil \\frac L k \\rceil }^{\\lfloor \\frac R k \\rfloor}\\cdots\\sum_{a_n=\\lceil \\frac L k \\rceil }^{\\lfloor \\frac R k \\rfloor}\\sum_{d|\\gcd\\limits_{i=1}^n(a_i)}\\mu(d)改变枚举顺序 \\large \\sum_{d=1}^{\\lfloor\\frac R k\\rfloor}\\mu(d)\\sum_{a_1=\\lceil \\frac L k \\rceil }^{\\lfloor \\frac R k \\rfloor}d|a_i\\cdots\\sum_{a_n=\\lceil \\frac L k \\rceil }^{\\lfloor \\frac R k \\rfloor}d|a_n也就是 \\large \\sum_{d=1}^{\\lfloor\\frac R k\\rfloor}\\mu(d)\\cdot\\left(\\lfloor\\frac{\\lfloor \\frac R k \\rfloor} d \\rfloor-\\lfloor \\frac {\\lceil \\frac L k \\rceil-1} d\\rfloor\\right)^n于是现在就珂以数论分块求啦 只不过 $\\mu(n)$ 貌似线性筛不出来，没关系，杜教筛大法好 时间复杂度O(能过) $O(n^{\\frac 2 3}+\\sqrt nlog_2(n))$ Warning1、杜教筛记得从 $2$ 开始筛 2、数论分块求解时注意 l&gt;L 的情况，此时不能使用 min(L/(L/l),R/(R/L)) 3、注意过程中 int 类型的溢出 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rLL rgt LL #define inf 0x7f7f7f7f #define p 1000000007 #define N 1000000 #define M 98573 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} int nxt[N],key[N],val[N],head[M]; int L,R,n,t,k,mu[N+3],pr[N],ans,res; bool v[N+3]; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void Insert(rint k,rint v) {//写了个hash表 rint c=k%M;key[++t]=k,val[t]=v,nxt[t]=head[c],head[c]=t; } inline int Search(rint k) { rint c=k%M,i; for(i=head[c];i;i=nxt[i]) if(key[i]==k) return val[i]; return -1; } inline void init() {//预处理杜教筛的前n^{2/3} rint i,j,c;mu[1]=1; for(i=2;i&lt;=N;++i) { if(!v[i]) pr[++t]=i,mu[i]=-1; for(j=1;j&lt;=t;++j) { c=i*pr[j];if(c&gt;N) break;v[c]=1; if(i%pr[j]) mu[c]=-mu[i]; else break; } } for(i=2;i&lt;=N;++i) mu[i]=(mu[i-1]+mu[i])%p; } inline int getmu(rint n) {//杜教筛搞一搞 if(n&lt;=N) return mu[n]; rint res=Search(n); if(~res) return res;res=1; for(rint l=2,r;l&lt;=n;l=r+1) { r=n/(n/l); res=(res-1ll*(r-l+1)*getmu(n/l))%p; }res%=p,Insert(n,res); return res; } inline int Pow(rLL a) { rint b=n;rLL res=1; for(;b;a=a*a%p,b&gt;&gt;=1) if(b&amp;1) res=res*a%p;return res; } inline void solve() { if(L%k) L=L/k;//预先除去k else L=L/k-1;R/=k;rint x=0,y;//x,y分别记录上次r和本次r的mu函数的前缀和 for(rint l=1,r;l&lt;=R;l=r+1) { if(l&lt;=L) r=min(R/(R/l),L/(L/l)); else r=R/(R/l);//特判情况 y=getmu(r),res=Pow(R/l-L/l); ans=(ans+1ll*(y-x)*res%p)%p,x=y; }printf(&quot;%d\\n&quot;,(ans+p)%p);//可能为负 } int main() { init(),n=read(),k=read(), L=read(),R=read(),solve(); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://hovnySiLenCe.github.io/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://hovnySiLenCe.github.io/tags/莫比乌斯反演/"},{"name":"数论分块","slug":"数论分块","permalink":"http://hovnySiLenCe.github.io/tags/数论分块/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2221」[HAOI2012]高速公路 解题报告","slug":"Luogu_P2221-[HAOI2012]Freeway-Solution","date":"2019-08-15T10:26:02.000Z","updated":"2019-12-01T07:28:35.210Z","comments":true,"path":"2019/08/15/Luogu_P2221-[HAOI2012]Freeway-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/08/15/Luogu_P2221-[HAOI2012]Freeway-Solution/","excerpt":"","text":"题面解题思路线段树 分析用一条路左端点的编号表示它的编号，实际上所求即为： \\large \\frac {1} {\\tbinom{R-L+1}{2}} \\cdot \\sum_{i=L}^{R-1}\\sum_{j=i}^{R-1}\\sum_{k=i}^j v_i设 $\\large sum(i,j)=\\sum_{k=i}^jv_i$ 区间修改，貌似线段树可以维护，于是就考虑在已知一段区间答案的情况下，怎么合并 1、如何合并区间 考虑两个区间合并增加的信息的值即可 在左区间中的 $i$ 和右区间中的 $j$ 的 $sum(i,j)$ 会对答案产生贡献，贡献为： \\large \\sum_{i=l}^{mid}\\sum_{j=mid+1}^rsum(i,j)跑个暴力的代码： for(i=l;i&lt;=mid;++i) for(j=mid+1;j&lt;=r;++j) for(k=i;k&lt;=j;++k) ans+=v[i]; 真·暴力 不过可以发现 $\\large \\sum_{i=l}^{mid}v[i]$ 这一段，每次必对答案造成贡献，也就是说会贡献 $r-mid$ 次，那么我们可以对左边整个区间记录一个从右开始的前缀和，但是由于每次更新时乘上的都是 $r-mid$ 次，所以可以再对从右开始的前缀和记录一个总和 $sumR$，表示这一段区间内所有从右开始的前缀和的总和，即： \\large sumR=\\sum_{i=l}^{mid}sum(i,mid)同理，可以用 $sumL$ 来维护一个区间左端前缀和的总和 但是 $sumL$ 和 $sumR$ 有应该如何维护？ 以 $sumL$ 为例，仍然像上面那样考虑，合并之后会多出 $r-mid$ 段 $sum(i,mid)$ ，加入答案即可，因此我们还要维护一个 $sum$ 表示区间和 于是合并两个区间即可写成： inline void Update(rint k,rint ls,rint rs) {//原有的值加上新增的贡献 f[k]=f[ls]+f[rs]+sumR[ls]*len[rs]+len[ls]*sumL[rs], sumR[k]=sumR[rs]+sumR[ls]+sum[rs]*len[ls], sumL[k]=sumL[ls]+sumL[rs]+sum[ls]*len[rs], sum[k]=sum[ls]+sum[rs]; } 2、如何更新答案/下传标记 在一个区间加上一个值 $v$，其对答案产生贡献的形式是一定的，总是那个暴力的式子，于是我们可以预处理出区间 $+1$ 的情况，加 $v$ 修改时，直接乘以预处理值即可，预处理的过程可以理解为上述合并过程，不过长度和 $sumR$ 和 $sumL$ 都可以通过 $l$ 和 $r$ 体现出来，不需要开数组额外记录 初始化过程如下： inline void Init(rint k,rint ls,rint rs) { len[k]=len[ls]+len[rs],//原本是不用记录len的，但是每次求len有点小长，就写成这样了 frc[k]=frc[ls]+frc[rs]+len[rs]*len[ls]*(len[ls]+1)/2+len[ls]*len[rs]*(len[rs]+1)/2; }//和上述合并区间是一致的 inline void built(rint k,rint l,rint r) { if(l==r) {len[k]=frc[k]=1;return;} rint mid=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; built(ls,l,mid),built(ls|1,mid+1,r); Init(k,ls,ls|1); } 3、查询 查询时和合并区间一致 warning计算 $(R-L+1)\\times(R-L)$ 时一定开 $long\\ long$，如果你事先将 $R$ 减了 $1$，概率就应改为 $(R-L+1)\\times(R-L+2)$ Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define inf 0x7f7f7f7f #define N 100003 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} int n,T,L,R; LL ans,res,Sum,v,d,len[N&lt;&lt;2],frc[N&lt;&lt;2],sum[N&lt;&lt;2]; LL f[N&lt;&lt;2],tag[N&lt;&lt;2],sumL[N&lt;&lt;2],sumR[N&lt;&lt;2]; inline int read() { rint s=0,p=1; rgt char c=getchar(); while(!isdigit(c)) {if(c==&#39;-&#39;) p=-1;c=getchar();} while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s*p; } inline char get() { rgt char c=getchar(); while(c&lt;&#39;A&#39;||c&gt;&#39;Z&#39;) c=getchar(); return c; } inline void Init(rint k,rint ls,rint rs) { len[k]=len[ls]+len[rs], frc[k]=frc[ls]+frc[rs]+len[rs]*len[ls]*(len[ls]+1)/2+len[ls]*len[rs]*(len[rs]+1)/2; } inline void built(rint k,rint l,rint r) { if(l==r) {len[k]=frc[k]=1;return;} rint mid=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; built(ls,l,mid),built(ls|1,mid+1,r); Init(k,ls,ls|1); } inline void push(rint k,rint l,rint r) {//下传标记 f[k]+=frc[k]*tag[k], sum[k]+=tag[k]*len[k]; sumL[k]+=tag[k]*len[k]*(len[k]+1)/2; sumR[k]+=tag[k]*len[k]*(len[k]+1)/2; if(l!=r) { rint ls=k&lt;&lt;1; tag[ls]+=tag[k], tag[ls|1]+=tag[k]; } tag[k]=0; } inline void Update(rint k,rint ls,rint rs) { f[k]=f[ls]+f[rs]+sumR[ls]*len[rs]+len[ls]*sumL[rs], sumR[k]=sumR[rs]+sumR[ls]+sum[rs]*len[ls], sumL[k]=sumL[ls]+sumL[rs]+sum[ls]*len[rs], sum[k]=sum[ls]+sum[rs]; } inline void Modify(rint k,rint l,rint r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {tag[k]=v;return push(k,l,r);} rint mid=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,mid),Modify(ls|1,mid+1,r); Update(k,ls,ls|1); } inline void Add(rint k,rint L) { ans+=f[k]+L*sumL[k]+Sum*len[k], Sum+=L*sum[k]+sumR[k]; } inline void Query(rint k,rint l,rint r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) return Add(k,l-L);//计算答案和合并区间已知 rint mid=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Query(ls,l,mid),Query(ls|1,mid+1,r); } inline LL gcd(rgt LL a,rgt LL b) { return b?gcd(b,a%b):a;//处理gcd是也需要LL } int main() { int i,op; n=read()-1,T=read(),built(1,1,n); while(T--) { op=get(),L=read(),R=read()-1,res=1ll*(R-L+1)*(R-L+2); if(op==&#39;C&#39;) v=read(),Modify(1,1,n); else { ans=Sum=0; Query(1,1,n),ans*=2; d=gcd(ans,res); printf(&quot;%lld/%lld\\n&quot;,ans/d,res/d); } } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2619」[国家集训队2]Tree I 解题报告","slug":"Luogu_P2619-[NationalTeam2]Tree_I-Solution","date":"2019-08-14T00:23:23.000Z","updated":"2019-12-01T07:28:31.836Z","comments":true,"path":"2019/08/14/Luogu_P2619-[NationalTeam2]Tree_I-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/08/14/Luogu_P2619-[NationalTeam2]Tree_I-Solution/","excerpt":"","text":"题面解题思路某种叫作 $wqs$ （忘情水）二分的神奇算法，具体的算法内容等详见学习笔记 分析$Kruskal$ 算法只能求解最小生成树，但是由于要求的白边数是一定的，这将导致最后的生成树并不是最小生成树 于是考虑怎么消除白边的影响，不难想到，如果白边的边权越小，最后求出的最小生成树中的白边数肯定越多，于是就可以二分白边改变的值，表示白边的边权减小 $mid$ ，然后再跑一遍生成树，如果生成树中白边数大于 $K$ 说明修改的值过大，则将右边界减小，否则将左边界增大 这样满足最后得出的答案，一定是满足有 $K$ 条白边的情况，因为题目中保证有解，且如果不满足 $K$ 条边的情况，二分都会将对左或右边界做出调整 最后答案即为求出最小生成树的边权加上 $K \\times$ 白边改变的值 warning1、由于可能存在白边和黑边的边权一样的情况，所以在 $Kruskal$ 对边进行排序时，要把边权作为第一关键字，颜色作为第二关键字 2、排序可以用归并排序优化（白边边权改变后按边权排序的排名并没有变化 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define inf 0x7f7f7f7f #define M 100007 #define N 50007 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} struct node{ int x,y,w,c; }b[M],p[M]; int n,m,k,res,sum,ans,f[N],block,l,r,mid; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline bool cmp(rgt node a,rgt node b) {return (a.w!=b.w)?a.w&lt;b.w:a.c&lt;b.c;}//排序 inline int get(rint x) {return (f[x]!=x)?f[x]=get(f[x]):x;} inline int Kruskal(rint k) { rint i,fx,fy; for(i=1;i&lt;=m;i++) { b[i]=p[i]; if(!p[i].c) b[i].w-=k;//改变白边的边权 }sort(b+1,b+1+m,cmp),block=sum=0;//可以用归并复杂度较优 for(i=1;i&lt;=n;i++) f[i]=i;//初始化并查集 for(i=1;i&lt;=m;i++) { fx=get(b[i].x),fy=get(b[i].y); if(fx==fy) continue; f[fy]=fx; sum+=!b[i].c;//记录白边数 if(block==n-1) break; } return sum; } inline void solve(rint k) {//最后用来求最小生成树用 rint i,fx,fy; for(i=1;i&lt;=m;i++) { b[i]=p[i]; if(!p[i].c) b[i].w-=k; }sort(b+1,b+1+m,cmp),block=ans=0; for(i=1;i&lt;=n;i++) f[i]=i; for(i=1;i&lt;=m;i++) { fx=get(b[i].x),fy=get(b[i].y); if(fx==fy) continue; f[fy]=fx; ans+=b[i].w; if(block==n-1) break; } } int main() { int i; n=read(),m=read(),k=read(); for(i=1;i&lt;=m;i++) p[i].x=read()+1,p[i].y=read()+1, cmax(r,p[i].w=read()),p[i].c=read(); l=-r;//可以增大，可以减小 while(l&lt;=r) {//二分白边的改变值 mid=(l+r)&gt;&gt;1; if(Kruskal(mid)&gt;=k)//满足条件说明还可以将改变值边的更小 res=mid,r=mid-1; else l=mid+1; } solve(res); printf(&quot;%d&quot;,ans+res*k);//答案要加上边数×改变的值 return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://hovnySiLenCe.github.io/tags/二分/"},{"name":"wqs二分/带权二分","slug":"wqs二分-带权二分","permalink":"http://hovnySiLenCe.github.io/tags/wqs二分-带权二分/"},{"name":"Kruskal","slug":"Kruskal","permalink":"http://hovnySiLenCe.github.io/tags/Kruskal/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF446C」DZY Loves Fibonacci Numbers 解题报告","slug":"CF446C-DZY_Loves_Fibonacci_Numbers-Solution","date":"2019-08-13T13:13:11.000Z","updated":"2019-12-01T07:28:40.588Z","comments":true,"path":"2019/08/13/CF446C-DZY_Loves_Fibonacci_Numbers-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/08/13/CF446C-DZY_Loves_Fibonacci_Numbers-Solution/","excerpt":"","text":"题面解题思路线段树 题目中涉及了区间加、区间修改，因此定是线段树的题 但是明显，就算区间转移，但是由于斐波那契数列在累加，可能一个区间内的斐波那契数列的第一、二项的不会仅仅是普通斐波那契数列中的任意一样，也就是出现广义斐波那契数列的情况 设普通斐波那契数列为 $\\large {F_n}$，广义斐波那契数列为 $\\large {S_n}$ 1、$\\large \\forall $ 任一广义斐波那契数列有： \\large \\sum_{i=1}^nS_i=S_{n+2}-S_2证明： $\\large S_3=S_2+S_1$ $\\large S_4=S_3+S_2=S_2+S_1+S_2$ $\\large S_5=S_4+S_3=S_3+S_2+S_1+S_2$ $\\large S_6=S_5+S_4=S_4+S_3+S_2+S_1+S_2$ $\\large S_7=S_6+S_5=S_5+S_4+S_3+S_2+S_1+S_2$ $\\large \\dots$ 移项可得： $\\large S_4-S_2=S_2+S_1$ $\\large S_5-S_2=S_3+S_2+S_1$ $\\large S_6-S_2=S_4+S_3+S_2+S_1$ $\\large S_7-S_2=S_5+S_4+S_3+S_2+S_1$ $\\large \\dots$ 2、$\\large \\forall$ 任一广义斐波那契数列，有 \\large S_n=a \\times F_{n-2}+b \\times F_{n-1},a=S_1,b=S_2于是只要把这两个性质合理地运用一下，写成函数，就可以很快地进行求和和求任一一项的操作，这将在 $push$ 函数里大有用处 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define inf 0x7f7f7f7f #define p 1000000009 #define N 300007 using namespace std; int n,T,L,R,tl[N&lt;&lt;2],tr[N&lt;&lt;2]; int f[N&lt;&lt;2],sum[N],fib[N]; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline int dec(rint x) {return (x&gt;=p)?x-p:x;} inline int rec(rint x) {return (x&lt;0)?x+p:x;}//这两个都是取模函数 inline int calc(rint k,rint l,rint r) {return (k&gt;1)?(1ll*fib[k-2]*l+1ll*fib[k-1]*r)%p:l;}//求第k项 inline int Sum(rint k,rint l,rint r) {return rec((1ll*l*fib[k]+1ll*r*fib[k+1])%p-r);}//前k项和 inline void push(rint k,rint l,rint r) {//下传标记 f[k]=dec(f[k]+Sum(r-l+1,tl[k],tr[k])); if(l!=r) { rint mid=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; tl[ls]=dec(tl[ls]+tl[k]),tl[ls|1]=dec(tl[ls|1]+calc(mid-l+2,tl[k],tr[k])), tr[ls]=dec(tr[ls]+tr[k]),tr[ls|1]=dec(tr[ls|1]+calc(mid-l+3,tl[k],tr[k])); }tl[k]=tr[k]=0; } inline void Modify(rint k,rint l,rint r) { if(tl[k]||tr[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) {tl[k]=fib[l-L+1],tr[k]=fib[l-L+2];return push(k,l,r);} rint mid=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; Modify(ls,l,mid),Modify(ls|1,mid+1,r); f[k]=dec(f[ls]+f[ls|1]); } inline int Query(rint k,rint l,rint r) { if(tl[k]||tr[k]) push(k,l,r); if(r&lt;L||R&lt;l) return 0; if(L&lt;=l&amp;&amp;r&lt;=R) return f[k]; rint mid=(l+r)&gt;&gt;1,ls=k&lt;&lt;1; return dec(Query(ls,l,mid)+Query(ls|1,mid+1,r)); } int main() { int i,op; n=read(),T=read(); for(i=1;i&lt;=n;i++) sum[i]=dec(sum[i-1]+read()); fib[1]=fib[2]=1; for(i=1;i&lt;=n+2;++i) fib[i+2]=dec(fib[i]+fib[i+1]);//预处理出Fib数列 while(T--) { op=read(),L=read(),R=read(); (op&lt;2)?Modify(1,1,n),1:printf(&quot;%d\\n&quot;,dec(Query(1,1,n)+rec(sum[R]-sum[L-1]))); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"},{"name":"数论","slug":"数论","permalink":"http://hovnySiLenCe.github.io/tags/数论/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF519E」A and B and Lecture Rooms 解题报告","slug":"CF519E-A_and_B_and_Lecture_Rooms-Solution","date":"2019-07-29T12:05:14.000Z","updated":"2019-12-01T07:28:40.146Z","comments":true,"path":"2019/07/29/CF519E-A_and_B_and_Lecture_Rooms-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/07/29/CF519E-A_and_B_and_Lecture_Rooms-Solution/","excerpt":"","text":"题面解题思路倍增$Lca$ 分析首先，题目中给的是一颗无根树，将无根树转换为有根树处理，随便选一个点为根即可 到两点距离相等的点，应为两点之间唯一路径上的中点以及其延伸出去的点，如果两没有中点，则必不存在答案，特判即可 然后就是找中点的问题 具体实现起来会和 $Lca$ 的位置有一定关系，所以需要求出 $x$、$y$ 两点的 $Lca$，然后算出中点的距离 这样我们就可以找出两点的中点啦，这样答案即为中点及其延伸出的点的个数 但是仍然要分情况讨论（size[k] 为以 $1$ 为根时 $k$ 的子树大小）： 1、中点为 $Lca$ 时，如询问 $4$、$6$ 结果应该是手动红框框出来的辣些点，仔细研究一下，其实应该是 size[2]-size[3]-size[5] 也就是：中点的子树大小 $-$ 路径上与中点相邻两个点的子树大小 2、中点不为 $Lca$ ，询问的 $x$、$y$ 都不是对方的祖先时，如询问 $5$、$7$ 还是手动框出来的辣个点，ans=size[3]-size[4] 也就是： 中点的子树大小 $-$ 与中点相邻且深度较大的点的子树大小 3、中点不为 $Lca$ ，询问的 $x$、$y$ 一方为对方的祖先时，如询问 $1$、$7$ 不难发现，ans=size[3]-size[4] 和$2$中的结论一致，所以就讨论两种就好了 还要注意中点偏向 $x$ 还是 $y$，操作的对象是不同的 如何求邻近点？ 由于预处理了每个点的祖先情况，因此那些邻近点可以在知道距离的情况下用倍增求 Warning可能存在查询的两点相同的情况，此时答案为 $0$ Code#include&lt;bits/stdc++.h&gt; #define rgt register #define N 100003 using namespace std; struct Edge{ int to,nxt; }b[N&lt;&lt;1]; int head[N],deep[N],size[N]; int n,T,dis,t,f[N][17],rx,ry,root; inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(rgt int x,rgt int y) { b[++t].to=y,b[t].nxt=head[x],head[x]=t; b[++t].to=x,b[t].nxt=head[y],head[y]=t; } inline void built(rgt int k,rgt int fa) {//处理倍增Lca rgt int i,to;size[k]=1; deep[k]=deep[fa]+1; for(i=0;i&lt;16;i++)//预处理出祖先情况 f[k][i+1]=f[f[k][i]][i]; for(i=head[k];i;i=b[i].nxt) { to=b[i].to; if(to==fa) continue; f[to][0]=k,built(to,k),size[k]+=size[to]; } } inline int Lca(rgt int x,rgt int y) {//倍增求Lca if(deep[x]&lt;deep[y]) swap(x,y); rgt int i; for(i=16;i&gt;=0;i--) { if(deep[f[x][i]]&gt;=deep[y]) x=f[x][i]; if(x==y) return x; } for(i=16;i&gt;=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0]; } inline int getanc(rgt int res,rgt int k) {//倍增求res节点的k次祖先 rgt int i,x; for(i=16,x=res;i&gt;=0;i--) if(deep[res]-deep[f[x][i]]&lt;=k) x=f[x][i]; return x; } int main() { int i,x,y; n=read(); for(i=1;i&lt;n;i++) x=read(),y=read(),add(x,y); built(1,0),T=read(); while(T--) { x=read(),y=read(); if(x==y) {printf(&quot;%d\\n&quot;,n);continue;}//特判相等 root=Lca(x,y);//求出Lca dis=deep[x]+deep[y]-deep[root]-deep[root];//就算两点间距离 if(dis&amp;1) {printf(&quot;0\\n&quot;);continue;}//没有中点 dis&gt;&gt;=1;//到路径中点的距离 if(dis==deep[x]-deep[root]) {//Lca为中点的情况 rx=getanc(x,dis-1),ry=getanc(y,dis-1); printf(&quot;%d\\n&quot;,n-size[rx]-size[ry]); } else { if(dis&lt;deep[x]-deep[root]) {//看中点偏向哪一边 root=getanc(x,dis),rx=getanc(x,dis-1); printf(&quot;%d\\n&quot;,size[root]-size[rx]); }//也就是看中点是x还是y的祖先，用dis判断比较方便 else { root=getanc(y,dis),ry=getanc(y,dis-1); printf(&quot;%d\\n&quot;,size[root]-size[ry]); } } } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"Lca","slug":"Lca","permalink":"http://hovnySiLenCe.github.io/tags/Lca/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「USACO12DEC」逃跑的BarnRunning Away From… 解题报告","slug":"USACO12DEC-BarnRunning_Away_From-Solution","date":"2019-07-29T07:35:23.000Z","updated":"2019-12-01T07:28:07.802Z","comments":true,"path":"2019/07/29/USACO12DEC-BarnRunning_Away_From-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/07/29/USACO12DEC-BarnRunning_Away_From-Solution/","excerpt":"","text":"题面解题思路方法很多，比如左偏树、主席树、树上查分 看到数据结构大佬瑟瑟发抖 这里提供一种新的算法 $\\large \\to$ 树状数组+离散化（并不用记录 $dfs$ 序 分析求子树中到根的距离在一定范围内的点，可以对每棵子树用树状数组维护一个所有点到根的距离，查询时查询一定范围即可 但是明显这是不行的，空间和时间都不允许 考虑一下优化，绝对距离是没必要的，可以有相对距离来表示两点间的情况（也就是说，我们只需要知道两者的大小关系），因此可以预处理出每个点到 $root$ 的距离，排序后维护其离散值即可，查询时也可以用离散值来代替 再考虑对每个点维护子树信息的优化，不难发现，$dfs$ 实现时，对于一个点，$dfs$ 其子树前 和 完成后，对答案造成的影响只有子树里的信息，因此可以只开一个树状数组维护信息，每次记录 $dfs$ 前后的结果，两者之差即为答案 实现过程1、先 $dfs$ 跑一遍，预处理出所有点到 $root(1)$ 的 $dis$ 值，用 $p$ 数组记录 2、将 $p$ 数组按升序排序 3、再次 $dfs$，用树状数组 $f$ 记录各点到 $root$ 距离的离散值，每次在访问一个节点的儿子前，查询该点能到最远距离的离散值，然后在树状数组中标记这个点的 $dis$，遍历子树，最后再次查询，两次查询之差即为该点的答案，因为只对该点子树进行的操作，不会产生额外的影响 cur=lower_bound(p+1,p+t+1,dis[k])-p;//当前点的离散值 pos=lower_bound(p+cur,p+t+1,dis[k]+R)-p;//最远能到的点的离散值 if(p[pos]&gt;dis[k]+R) --pos;//要求 小于等于 res=Query(pos),Modify(cur);//先查询，再修改 . . . Ans[k]=Query(pos)-res;//再次查询，记录两次查询的差为答案 warning1、记得开 $long\\ long $ 2、$1$ 到 $root$ 的 $dis$ 值，虽然是 $0$ 也要记录，否则会影响上述过程中 $cur$ 的值，间接影响答案，如下图情况，若题目中的 $L&lt;10$ 则 $root$ 的答案会少 $1$ ，当然，也可以通过特判解决 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define LL long long #define N 200003 using namespace std; struct Edge{ int to,nxt; LL dis; Edge(int a,int b,LL c):to(a),nxt(b),dis(c){} Edge(){} }b[N];//记录边 int head[N],n,t; int f[N],Ans[N]; LL dis[N],p[N],R; inline LL read() { rgt LL s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(rgt int x,rgt int y) { b[++t]=Edge(y,head[x],read()),head[x]=t; } inline void built(rgt int k) {//预处理dis p[++t]=dis[k];//1到root的距离也要加入 rgt int i,to; for(i=head[k];i;i=b[i].nxt) { to=b[i].to, dis[to]=dis[k]+b[i].dis; built(to); } } inline int Query(rgt int x) { int res=0; for(;x;x-=x&amp;(-x)) res+=f[x]; return res; } inline void Modify(rgt int x) { for(;x&lt;=t;x+=x&amp;(-x)) ++f[x]; } inline void solve(rgt int k) { rgt int i,to,cur,res,pos; cur=lower_bound(p+1,p+t+1,dis[k])-p; pos=lower_bound(p+cur,p+t+1,dis[k]+R)-p;//假装从cur开始查能省点时间 if(p[pos]&gt;dis[k]+R) --pos; res=Query(pos),Modify(cur); for(i=head[k];i;i=b[i].nxt) to=b[i].to,solve(to); Ans[k]=Query(pos)-res; } int main() { int i; n=read(),R=read();//n点数，R距离 for(i=2;i&lt;=n;i++) add(read(),i); t=0,built(1),//第一遍dfs sort(p+1,p+t+1),solve(1);//第二遍dfs得出结果 for(i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,Ans[i]); return 0; } 最后如果题目没有 子树中的限制…","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://hovnySiLenCe.github.io/tags/离散化/"},{"name":"树状数组","slug":"树状数组","permalink":"http://hovnySiLenCe.github.io/tags/树状数组/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3964」[TJOI2013]松鼠聚会 解题报告 (咕)","slug":"A-Luogu_P3964-[TJOI2013]SquirrelParty-Solution","date":"2019-06-26T09:58:13.000Z","updated":"2019-12-01T07:28:44.870Z","comments":true,"path":"2019/06/26/A-Luogu_P3964-[TJOI2013]SquirrelParty-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/26/A-Luogu_P3964-[TJOI2013]SquirrelParty-Solution/","excerpt":"","text":"题面Code#include&lt;bits/stdc++.h&gt; #define INF LONG_LONG_MAX #define ll long long #define rgt register #define N 100003 using namespace std; struct node{ int x,y; }b[N]; int n,X[N],Y[N]; ll Sx[N],Sy[N],x,y,ans=INF,res; inline int read() { rgt int s=0,p=1; rgt char c=getchar(); while(!isdigit(c)) {if(c==&#39;-&#39;) p=-1;c=getchar();} while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s*p; } int main() { int i; n=read(); for(i=1;i&lt;=n;i++) { x=read(),y=read(); X[i]=b[i].x=x+y, Y[i]=b[i].y=x-y; } sort(X+1,X+n+1),sort(Y+1,Y+n+1); for(i=1;i&lt;=n;i++) Sx[i]=Sx[i-1]+X[i]; for(i=1;i&lt;=n;i++) Sy[i]=Sy[i-1]+Y[i]; for(i=1;i&lt;=n;i++) { x=lower_bound(X+1,X+n+1,b[i].x)-X; y=lower_bound(Y+1,Y+n+1,b[i].y)-Y; res=b[i].x*x-Sx[x]+Sx[n]-Sx[x]-b[i].x*(n-x); res+=b[i].y*y-Sy[y]+Sy[n]-Sy[y]-b[i].y*(n-y); ans=min(ans,res); } printf(&quot;%lld&quot;,ans&gt;&gt;1); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://hovnySiLenCe.github.io/tags/计算几何/"},{"name":"距离","slug":"距离","permalink":"http://hovnySiLenCe.github.io/tags/距离/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「USACO2004OPEN」Cave Cows 3 解题报告 (咕)","slug":"A-USACO2004OPEN-Cave_Cows_3-Solution","date":"2019-06-25T14:21:54.000Z","updated":"2019-12-01T07:28:42.476Z","comments":true,"path":"2019/06/25/A-USACO2004OPEN-Cave_Cows_3-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/25/A-USACO2004OPEN-Cave_Cows_3-Solution/","excerpt":"","text":"题面Code#include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define rgt register using namespace std; int n,x,y,Xmax,Xmin=INF,Ymax,Ymin=INF; inline int read() { rgt int s=0,p=1; rgt char c=getchar(); while(!isdigit(c)) {if(c==&#39;-&#39;) p=-1;c=getchar();} while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s*p; } int main() { int i; n=read(); for(i=1;i&lt;=n;i++) { x=read(),y=read(); Xmax=max(Xmax,x+y), Xmin=min(Xmin,x+y), Ymax=max(Ymax,x-y), Ymin=min(Ymin,x-y); } printf(&quot;%d&quot;,max(Xmax-Xmin,Ymax-Ymin)); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://hovnySiLenCe.github.io/tags/计算几何/"},{"name":"距离","slug":"距离","permalink":"http://hovnySiLenCe.github.io/tags/距离/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4551」最长异或路径 解题报告 (咕)","slug":"A-Luogu_P4551-TheLongestXORPath-Solution","date":"2019-06-25T14:12:56.000Z","updated":"2019-12-01T07:28:43.352Z","comments":true,"path":"2019/06/25/A-Luogu_P4551-TheLongestXORPath-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/25/A-Luogu_P4551-TheLongestXORPath-Solution/","excerpt":"","text":"题面Code#include&lt;bits/stdc++.h&gt; #define rgt register #define N 100003 using namespace std; struct Edge{ int to,nxt,cost; Edge(int a,int b,int c):to(a),nxt(b),cost(c){} Edge(){} }b[N&lt;&lt;1]; int head[N],f[N],bit[33]; int n,ans,t,T[N*33][2]; inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(rgt int x,rgt int y,rgt int cost) { b[++t]=Edge(y,head[x],cost),head[x]=t; b[++t]=Edge(x,head[y],cost),head[y]=t; } inline void built(rgt int k,rgt int fa) { for(rgt int i=head[k],to;i;i=b[i].nxt) { to=b[i].to; if(to==fa) continue; f[to]=f[k]^b[i].cost,built(to,k); } } inline void Search(int k) { int i,c,p=1,res=0; for(i=30;i&gt;=0;i--) { c=(k&amp;bit[i])?0:1; if(T[p][c]) res+=bit[i],p=T[p][c]; else p=T[p][c^1]; } ans=max(ans,res); } inline void Insert(int k) { int i,c,p=1; for(i=30;i&gt;=0;i--) { c=(k&amp;bit[i])?1:0; if(!T[p][c]) T[p][c]=++t; p=T[p][c]; } } int main() { int i,x,y,cost; n=read(); bit[0]=1;for(i=1;i&lt;31;i++) bit[i]=bit[i-1]&lt;&lt;1; for(i=1;i&lt;n;i++) x=read(),y=read(),cost=read(),add(x,y,cost); built(1,0),t=1; for(i=2;i&lt;=n;i++) ans=max(ans,f[i]),Search(f[i]),Insert(f[i]); printf(&quot;%d\\n&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"字典树","slug":"字典树","permalink":"http://hovnySiLenCe.github.io/tags/字典树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「OI-wiki」 距离 学习笔记 (咕)","slug":"A-Oiwiki-Distance-Notes","date":"2019-06-25T13:52:07.000Z","updated":"2019-11-02T10:03:35.926Z","comments":true,"path":"2019/06/25/A-Oiwiki-Distance-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/25/A-Oiwiki-Distance-Notes/","excerpt":"","text":"欧几里得距离 曼哈顿距离 切比雪夫距离 $L_m$距离 汉明距离","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://hovnySiLenCe.github.io/tags/计算几何/"},{"name":"距离","slug":"距离","permalink":"http://hovnySiLenCe.github.io/tags/距离/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}]},{"title":"「Luogu P2446」 [SDOI2010]大陆争霸 解题报告","slug":"Luogu_P2446-[SDOI2010]MainlandFight-Solution","date":"2019-06-18T11:19:30.000Z","updated":"2019-12-01T07:28:33.949Z","comments":true,"path":"2019/06/18/Luogu_P2446-[SDOI2010]MainlandFight-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/18/Luogu_P2446-[SDOI2010]MainlandFight-Solution/","excerpt":"","text":"题面题目描述幻想历$8012$年$5$月$12$日深夜，斯普林·布拉泽降下神谕：$“Trust\\ me, earn\\ eternal\\ life.”$ 克里斯军团士气大增。作为克里斯军团的主帅，你决定利用这一机会发动奇袭，一举击败杰森国。具体地说，杰森国有 $N$ 个城市，由 $M$ 条单向道路连接。神谕镇是城市 $1$ 而杰森国的首都是城市 $N$。你只需摧毁位于杰森国首都的曾·布拉泽大神殿，杰森国的信仰，军队还有一切就都会土崩瓦解，灰飞烟灭。 为了尽量减小己方的消耗，你决定使用自爆机器人完成这一任务。唯一的困难是，杰森国的一部分城市有结界保护，不破坏掉结界就无法进入城市。而每个城市的结界都是由分布在其他城市中的一些结界发生器维持的，如果想进入某个城市，你就必须破坏掉维持这个城市结界的所有结界发生器。 现在你有无限多的自爆机器人，一旦进入了某个城市，自爆机器人可以瞬间引爆，破坏一个目标（结界发生器，或是杰森国大神殿），当然机器人本身也会一起被破坏。你需要知道：摧毁杰森国所需的最短时间。 输入输出格式输入格式：输入文件的 $landcraft.in$ 的第一行两个正整数 $N, M$。 接下来 $M$ 行，每行三个正整数 $ui, vi, wi$，表示有一条从城市 $ui$ 到城市 $vi$ 的单向道路，自爆机器人通过这条道路需要 $wi$ 的时间。 之后 $N$ 行，每行描述一个城市。首先是一个正整数 $li$，维持这个城市结界所使用的结界发生器数目。之后 $li$ 个 $1~N$ 之间的城市编号，表示每个结界发生器的位置。如果 $li = 0$，则说明该城市没有结界保护，保证 $l1 = 0$。 输出格式：输出文件 $landcraft.out$ 仅包含一个正整数 ，击败杰森国所需的最短时间。 输入输出样例输入样例#1：6 6 1 2 1 1 4 3 2 3 1 2 5 2 4 6 2 5 3 2 0 0 0 1 3 0 2 3 5 输出样例#1：5 说明 对于 $20\\%$的数据，满足 $N\\le15$，$M\\le50$； 对于 $50\\%$ 的数据，满足 $N\\le500$，$M\\le6,000$； 对于 $100\\% $的数据，满足 $N\\le3,000$，$M\\le70,000$，$1\\le wi\\le10^8$。 输入数据保证一定有解，且不会存在维持某个城市结界的结界发生器在这个城市内部。 连接两个城市的道路可能不止一条，也可能存在一个城市自己到自己的道路。 解题思路$Dijksra$，可以说是一道比较好的最短路吧 对于控制其他城市结界这种情况，果断连边，当然啦，这些边是不跑图的 然后怎么处理只有结界破坏后才能跑图呢？ 这就想到了 $Dijskstra$的性质，对于每个点，只拿它更新了一次，并且，我们一同更新结界的情况，这样就可以保证，每次更新结界的时间，肯定是最短的，那么所有结界全部被破坏的情况就可以用一个数组记录了，$lim[i]$ 表示 $i$ 这个点所有结界都被破坏的最短时间，而它又是每个结界被破坏的最短时间的最大值（有点绕，仔细理解一下），那么就取 $max$ 即可 跑图的时候注意：对于结界还没全部被破坏的城市不能跑（但是能更新 $d[i]$，也就是先得出最短路答案，最后再判断这个最短距离所用的时间是否大于结界全部被破坏的时间 总体来说还是比较简单的，但是关于 $long\\ long$类型赋极大值问题这里还是要$\\%$一波 $Judge$ 巨佬 Code#include&lt;bits/stdc++.h&gt; #define INF 1000000000000000000 #define rgt register #define ll long long #define M 70003 #define N 3003 using namespace std; struct Edge{ int to,nxt,cost; Edge(int a,int b):to(a),cost(b){} Edge(){} }b[M&lt;&lt;1]; struct Extent{ int to,nxt; }Ev[M&lt;&lt;1]; struct node{ int to,cost; node(int a,int b):to(a),cost(b){} node(){} inline bool operator&lt; (const node x) const{ return cost&gt;x.cost; } }; int head[N],hv[N],a[N][N]; int n,m,t,tv,In[N]; ll d[N],lim[N],y; bool vis[N]; inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(int x,int y,int cost) { b[++t]=Edge(y,cost),b[t].nxt=head[x],head[x]=t; } inline void Add(int x,int y) { Ev[++tv].to=y,Ev[tv].nxt=hv[x],hv[x]=tv; } inline void Dijkstra() { int i,cur,to;ll cost; priority_queue&lt;node&gt;p;p.push(node(1,0)); memset(d,0x7f,sizeof(d)),d[1]=0; while(!p.empty()) { cur=p.top().to,p.pop(); if(vis[cur]) continue;vis[cur]=1; for(i=hv[cur];i;i=Ev[i].nxt) {//处理结界 to=Ev[i].to,lim[to]=max(lim[to],d[cur]),--In[to]; if(!In[to]) { if(d[to]&lt;INF) {//结界已经炸完了，而且d[to]被跑到过了 d[to]=max(d[to],lim[to]); p.push(node(to,d[to])); } } } for(i=head[cur];i;i=b[i].nxt) {//跑图 to=b[i].to,cost=d[cur]+b[i].cost; if(!In[to]&amp;&amp;lim[to]&gt;cost) cost=lim[to]; if(d[to]&gt;cost) { d[to]=cost; if(!In[to]) p.push(node(to,cost));//结界没炸完的就算了吧 } } } } int main() { int i,j,x,y; n=read(),m=read(); memset(a,0x7f7f7f7f,sizeof(a)); for(i=1;i&lt;=m;i++) x=read(),y=read(),a[x][y]=min(a[x][y],read()); for(i=1;i&lt;=n;i++) {//什么重边，自环都搞定 for(j=1;j&lt;=n;j++) { if(a[i][j]==0x7f7f7f7f||i==j) continue; add(i,j,a[i][j]); } } for(i=1;i&lt;=n;i++) { In[i]=read();//类似用于拓扑排序一样 for(j=1;j&lt;=In[i];j++) x=read(),Add(x,i); } Dijkstra(); printf(&quot;%lld&quot;,d[n]); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://hovnySiLenCe.github.io/tags/最短路/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://hovnySiLenCe.github.io/tags/Dijkstra/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2577」[ZJOI2004]午餐 解题报告","slug":"Luogu_P2577-[ZJOI2004]Lunch-Solution","date":"2019-06-17T13:04:53.000Z","updated":"2019-12-01T07:28:32.700Z","comments":true,"path":"2019/06/17/Luogu_P2577-[ZJOI2004]Lunch-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/17/Luogu_P2577-[ZJOI2004]Lunch-Solution/","excerpt":"","text":"题面题目描述上午的训练结束了，THU ACM小组集体去吃午餐，他们一行$N$人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。 THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。 现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。 假设THU ACM小组在时刻$0$到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。 现在给定$N$个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入输出格式输入格式：第一行一个整数N，代表总共有$N$个人。 以下$N$行，每行两个整数 $Ai$，$Bi$。依次代表第$i$个人的打饭时间和吃饭时间。 输出格式：一个整数$T$，代表所有人吃完饭的最早时刻。 输入输出样例输入样例#1：5 2 2 7 7 1 3 6 4 8 5 输出样例#1：17 说明所有输入数据均为不超过200的正整数。 前言果然，我还是太菜了 解题思路贪心+DP 对于如此小的数据范围，果断想到$DP$，但是我并没有想到 其实本题和这道题，有异曲同工之妙，其实纯属瞎掰，不过$author$都做不来是真的 于是从这道题里就可以总结出一点做题的经验，对于要求分成两组的，而且数据范围不大的题目，我们可以果断使用$DP$（当然啦，还要满足$DP$的前提——没有后效性） 首先来证明贪心，先按照第二关键字从大到小排序，也就是按照吃饭的时间$a[i].b$排序 但是为什么呢？ 为什么贪心是正确的，感性理解一下 用一个序列表示排队的顺序， 假设$i$和$j$分别为俩个人， $i&lt;j$ ，$i$ 在 $j$ 的前面， 且 $a[i].b&lt;a[j].b$ ，即 $i$ 吃饭比 $j$ 慢， 设，整个序列由 $i$ 和 $j$ 两个位置决定，又因为 $i$ 耗的时间肯定比 $j$ 少，所以整个序列的时间由 $j$ 决定 则，如果交换 $i$ 和 $j$ 位置， 那么对于原本 $j$ 的位置来说， 等待时间不变，吃饭时间变短，答案变优， 对于原本的 $i$ 的位置说，$j$ 移到 $i$ 位置之后，等待时间变短，吃饭时间不变，因此答案也变优 综上，吃饭时间 $a[i].b$ 较长的人应该放在前面 证毕！！！ 没那么夸张，但是真的证明完了 $qwq$ 接下去是 $DP$ ，也就是开三维表示一下： $f[i][j][k]$ ：在 $i$ 这个点，$1$ 号窗的等待时间为 $j$，$2$ 号窗的等待时间为 $k$ 时的答案 三维明显会炸 稍微观察一下：$j+k$ 是不是定值啊，就是等于前 $i$ 个人的等待时间总和，于是我们可以维护一下前缀和 $sum[i]$，然后将数组变成两维的 接下去，转移方程就比较好推了： f[i][j]=max\\{f[i-1][j-a[i].a],f[i-1][j],j+a[i].b,sum[i]-j+a[i].b\\}当然啦，$j&lt;a[i].a$ 时，有些转移就无效了 否则RE爽死 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define INF 0x7f7f7f7f #define M 40007 #define N 203 using namespace std; struct node{ int a,b; }a[N]; int n,sum[N],f[N][M],ans=INF; inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline bool cmp(node a,node b) {return a.b&gt;b.b;} int main() { int i,j; n=read(); for(i=1;i&lt;=n;i++) a[i].a=read(),a[i].b=read(); memset(f,INF,sizeof(f));//全都初始化为INF sort(a+1,a+n+1,cmp),f[0][0]=0;//初始状态为啥都没有 for(i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i].a;//处理前缀和 for(i=1;i&lt;=n;i++) { for(j=0;j&lt;a[i].a;j++) if(f[i-1][j]!=INF)//一些不可能的状态就不要转移了 f[i][j]=max(f[i-1][j],sum[i]-j+a[i].b); for(j=a[i].a;j&lt;=sum[i];j++) { if(f[i-1][j]!=INF) f[i][j]=max(f[i-1][j],sum[i]-j+a[i].b); if(f[i-1][j-a[i].a]!=INF) f[i][j]=min(f[i][j],max(f[i-1][j-a[i].a],j+a[i].b)); } } for(i=1;i&lt;=sum[n];i++) ans=min(ans,f[n][i]); printf(&quot;%d&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「SP6517」JOCHEF - Farmer Sepp 解题报告","slug":"SP6517-JOCHEF_FarmerSepp-Solution","date":"2019-06-14T10:00:40.000Z","updated":"2019-11-12T11:33:17.234Z","comments":true,"path":"2019/06/14/SP6517-JOCHEF_FarmerSepp-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/14/SP6517-JOCHEF_FarmerSepp-Solution/","excerpt":"","text":"解题思路悬线法、DP 对于每个位置， 记录 以这个位置为下界的最大矩阵的 左边界 ：$l[i][j]$ 右边界：$r[i][j]$ 高，也就是上下界差：$h[i][j]$ 当然啦，暴力做是会$T$的（废话），于是可以充分利用已经求出的信息 进行$\\to\\ DP$ 递推式： 在每个位置更新答案，当然，在C的位置不能选，直接continue掉 Code：#include&lt;bits/stdc++.h&gt; #define ll long long #define N 4007 using namespace std; int n,m,l[N][N],r[N][N],h[N][N]; char b[N][N]; ll k,ans,L; inline int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int main() { int i,j; char c; while((n=read())) { m=read(),k=read(),ans=0; for(i=1;i&lt;=n;i++) {//读入 c=getchar(); while(c==&#39;\\n&#39;||c==&#39;\\r&#39;) c=getchar(); b[i][1]=c,l[i][1]=r[i][1]=1; for(j=2;j&lt;=m;j++)//初始化 b[i][j]=getchar(),l[i][j]=r[i][j]=j; } for(i=1;i&lt;=n;i++) {//处理出每个位置左右的障碍点 for(j=2;j&lt;=m;j++) if(b[i][j]==b[i][j-1]) l[i][j]=l[i][j-1]; for(j=m-1;j;j--) if(b[i][j]==b[i][j+1]) r[i][j]=r[i][j+1]; } for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=m;j++) { if(b[i][j]==&#39;C&#39;) continue; if(b[i][j]==b[i-1][j]) {//更新可能的矩形 l[i][j]=max(l[i][j],l[i-1][j]); r[i][j]=min(r[i][j],r[i-1][j]); h[i][j]=h[i-1][j]+1; } else h[i][j]=1; L=r[i][j]-l[i][j]+1; ans=max(ans,L*h[i][j]);//用矩形面积公式更新 } } printf(&quot;%lld\\n&quot;,ans*k);//别忘了要乘上单位面积 } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"},{"name":"悬线法","slug":"悬线法","permalink":"http://hovnySiLenCe.github.io/tags/悬线法/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「某讲稿」 极大化思想与最大子矩阵的探究 学习笔记","slug":"LectureNotes-Maximizing&LargestSubmatrix-Notes","date":"2019-06-13T14:10:36.000Z","updated":"2019-12-01T07:28:38.309Z","comments":true,"path":"2019/06/13/LectureNotes-Maximizing&LargestSubmatrix-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/13/LectureNotes-Maximizing&LargestSubmatrix-Notes/","excerpt":"","text":"写在前面这应该算是 $author$ 的第一篇知识笔记吧 $qwq$ 题目引入先来康康一道题吧， 「Luogu P1578」 奶牛浴场题目描述由于 $John$ 建造了牛场围栏，激起了奶牛的愤怒，奶牛的产奶量急剧减少。为了讨好奶牛，$John$ 决定在牛场中建造一个大型浴场。但是 $John$ 的奶牛有一个奇怪的习惯，每头奶牛都必须在牛场中的一个固定的位置产奶，而奶牛显然不能在浴场中产奶，于是，$John$ 希望所建造的浴场不覆盖这些产奶点。这回，他又要求助于 $Clevow$ 了。你还能帮助 $Clevow$ 吗？ $John$ 的牛场和规划的浴场都是矩形。浴场要完全位于牛场之内，并且浴场的轮廓要与牛场的轮廓平行或者重合。浴场不能覆盖任何产奶点，但是产奶点可以位于浴场的轮廓上。 $Clevow$ 当然希望浴场的面积尽可能大了，所以你的任务就是帮她计算浴场的最大面积。 输入输出格式输入格式：输入文件的第一行包含两个整数 $L$ 和 $W$，分别表示牛场的长和宽。文件的第二行包含一个整数 $n$，表示产奶点的数量。以下n行每行包含两个整数 $x$ 和 $y$，表示一个产奶点的坐标。所有产奶点都位于牛场内，即：$0\\le x\\le L$，$0\\le y\\le W$。 输出格式：输出文件仅一行，包含一个整数 $S$，表示浴场的最大面积。 输入输出样例输入样例 #1：10 10 4 1 1 9 1 1 9 9 9 输出样例 #1：80 /这行是为了前面有标号 说明$0\\le n\\le 5000$ $1\\le L,W\\le 30000$ $Winter\\ Camp\\ 2002$ 又比如，这道题： 「Luogu P1169」 [ZJOI2007]棋盘制作题目描述国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \\times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。 而我们的主人公小Q，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友小W决定将棋盘扩大以适应他们的新规则。 小Q找到了一张由 $N \\times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小Q想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。 不过小Q还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。 于是小Q找到了即将参加全国信息学竞赛的你，你能帮助他么？ 输入输出格式输入格式：包含两个整数 $N$ 和 $M$ ，分别表示矩形纸片的长和宽。接下来的$N$行包含一个 $N \\times M$ 的 $01$ 矩阵，表示这张矩形纸片的颜色（ $0$ 表示白色，$1$ 表示黑色）。 输出格式：包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。 输入输出样例输入样例 #1：3 3 1 0 1 0 1 0 1 0 0 输出样例 #1：4 6 说明对于 $20\\%$ 的数据，$N, M \\le 80$ 对于 $40\\%$ 的数据，$N, M ≤ 400$ 对于 $100\\%$ 的数据，$N, M ≤ 2000$ 正文求解矩阵中最大子矩阵问题，可以用极大化思想 先来看一些定义： 有效子矩形：顾名思义，即满足条件的矩形 极大子矩形：原矩阵中无法再拓展（即向四周都无法拓展）的子矩形 最大子矩形：字面意思，我们要求的答案 极大化思想可以证明，最大子矩形一定是极大子矩形 于是，我们就可设计一个算法，即枚举所有极大子矩阵，然后求解 但是暴力出奇迹暴力总不是最好的解法，我们可以高效利用我们处理出来的信息，将算法的复杂度降到$O(n^2)$ 不同的题型，不同的解法对于给出的第一道题，肯定不能基于矩形的大小做，于是就可以设计一个基于障碍点数的算法 由于极大化思想，一个极大子矩阵的边缘上一定有障碍点，所以可以枚举每个障碍点，再从障碍点扩展 这叫也不知道叫什么的算法 如图： 这是一个矩阵，为了方便处理，我们引入了矩阵的四个顶点 然后枚举每个点，比如我们做到这点，只向一个方向更新，令 $U$ 为以 $i$ 点为左边的矩形最大可能的上界编号，$D$ 则为相对应的最大可能的下界编号 此时：$U=7\\ \\ D=0$ 可以看出，还可以向右拓展，于是做到 $j$ 点 此时：$U=7\\ \\ D=0$ 虽然说，现在的答案已经是最大了（程序又不是人，但是我们还要拓展 既然要求 $i$ 点一定要在矩形的边缘上且矩形内不能有障碍点，所以就改变 $U$ 或 $D$ 的值 此时：$U=7\\ \\ D=3$ 然后继续往右拓展，直到 $U==D$ 或者所有点都拓展完，前者不能拓展的原因是因为无法形成矩形——已经是一条线了 然后将 $i$ 点右移，继续做，不断更新答案 但是，这样就足够了嘛？ 样例过了啊，样例是真水 我们在样例的基础上加两个点 是不是就忘记了这两种情况，而实际上，这两种情况就都是要竖着做一遍，但是由于嫌烦 还是特判一下好了，前者排序后特判，后者再从右往左扫一遍（一开始我们是从右往左更新 Code：#include&lt;bits/stdc++.h&gt; #define M b[i].y #define N 5007//由于坐标系和文中所描述的方法对x和y的定义有点不同 using namespace std;//造成的小差异读者可以自行思考 struct node{ int x,y; node(int a,int b):x(a),y(b){} node(){} }b[N]; int n,m,t,ans,D,U; inline int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline bool cmp(node a,node b) {return a.y&lt;b.y;} inline bool Cmp(node a,node b) {return a.x&lt;b.x;} int main() { int i,j; n=read(),m=read(),t=read(); for(i=1;i&lt;=t;++i) b[i].x=read(),b[i].y=read(); b[++t]=node(0,m),b[++t]=node(n,0), b[++t]=node(0,0),b[++t]=node(n,m); sort(b+1,b+1+t,cmp);//按y排序 for(i=1;i&lt;t;++i) ans=max(ans,(b[i+1].y-b[i].y)*n);//对于第一种情况的特判 sort(b+1,b+1+t,Cmp); for(i=2;i&lt;t;++i) { D=0,U=m; for(j=i+1;j&lt;=t;++j) { ans=max(ans,(b[j].x-b[i].x)*(U-D)); if(D&lt;=b[j].y&amp;&amp;b[j].y&lt;=U) { if(b[j].y==M) break; if(M&lt;b[j].y&amp;&amp;b[j].y&lt;U) U=b[j].y; if(D&lt;b[j].y&amp;&amp;b[j].y&lt;M) D=b[j].y; } } D=0,U=m; for(j=i-1;j;--j) { ans=max(ans,(b[i].x-b[j].x)*(U-D)); if(D&lt;=b[j].y&amp;&amp;b[j].y&lt;=U) { if(b[j].y==M) break; if(M&lt;b[j].y&amp;&amp;b[j].y&lt;U) U=b[j].y; if(D&lt;b[j].y&amp;&amp;b[j].y&lt;M) D=b[j].y; } } } printf(&quot;%d&quot;,ans); return 0; } 悬线法当障碍点变得密集，上文所述的方法就不适用了，于是就引出了新算法——悬线法 这是一个基于矩阵大小的算法 对于每个点处理： l[i][j]：以(i,j)点为下界的半极大有效子矩形(因为可能还能向下拓展)的左边界(障碍点的j值) r[i][j]：以(i,j)点为下界的半极大有效子矩形的右边界 h[i][j]：以(i,j)点为下界的半极大有效子矩形的高，上界到下界的距离 递推式： $(i,j)$ 位置左右最近的障碍点可以用一次 $DP$ 处理 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)//一开始l[i][j]和r[i][j]都是j b[i][j]=read(),l[i][j]=r[i][j]=j; for(i=1;i&lt;=n;i++) { for(j=2;j&lt;=m;j++) if(b[i][j]^b[i][j-1]) l[i][j]=l[i][j-1]; for(j=m-1;j;j--) if(b[i][j]^b[i][j+1]) r[i][j]=r[i][j+1]; } 然后在每个点更新答案 Code：#include&lt;bits/stdc++.h&gt; #define rgt register #define N 2007 using namespace std; int n,m,l[N][N],r[N][N],h[N][N],L,a,res,ans; bool b[N][N]; inline bool read() { rgt char c=getchar(); while(!isdigit(c)) c=getchar(); return c-&#39;0&#39;; } int main() { int i,j; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) b[i][j]=read(),l[i][j]=r[i][j]=j; for(i=1;i&lt;=n;i++) { for(j=2;j&lt;=m;j++) if(b[i][j]^b[i][j-1])//稍微变换一下，和左右同色的就是障碍点 l[i][j]=l[i][j-1]; for(j=m-1;j;j--) if(b[i][j]^b[i][j+1]) r[i][j]=r[i][j+1]; } for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=m;j++) { if(i&gt;1&amp;&amp;b[i][j]^b[i-1][j]) { l[i][j]=max(l[i][j],l[i-1][j]); r[i][j]=min(r[i][j],r[i-1][j]); h[i][j]=h[i-1][j]+1; } else h[i][j]=1; L=r[i][j]-l[i][j]+1,a=min(L,h[i][j]); res=max(res,a*a); ans=max(ans,L*h[i][j]); } } printf(&quot;%d\\n%d&quot;,res,ans); return 0; } 推荐题目SP6517 JOCHEF - Farmer SeppLuogu P4147 玉蟾宫","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"},{"name":"悬线法","slug":"悬线法","permalink":"http://hovnySiLenCe.github.io/tags/悬线法/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}]},{"title":"「Luogu P4802」[CCO 2015]路短最 解题报告","slug":"Luogu_P4802-[CCO 2015]PathShortestMost-Solution","date":"2019-06-11T12:57:31.000Z","updated":"2019-11-10T11:55:21.237Z","comments":true,"path":"2019/06/11/Luogu_P4802-[CCO 2015]PathShortestMost-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/11/Luogu_P4802-[CCO 2015]PathShortestMost-Solution/","excerpt":"","text":"解题思路其实这就是Hamilton路径的模板题 $\\to ​$ 根本做法其实是状压DP 用b数组存边，然后f数组用来跑$DP$ 用$i$表示 状压后，已经走过的点有哪些（当然啦，包含下面的$j$点），为f数组的第一维 用$j$表示 最后到的是哪个点，为f数组的第二维 然后对于每种情况，可以从其他状态转移过来，这里就不详述了，具体的见代码 Code#include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define N 19 using namespace std; int n,m,Max,res,ans;//Max表示每一位都取的状压值（也就是范围） int b[N][N],f[1&lt;&lt;19][N]; inline int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } int main() { int i,j,k,x,y; n=read(),m=read(); for(i=1;i&lt;=m;i++)//单向边 x=read(),y=read(),b[x][y]=read(); Max=(1&lt;&lt;n)-1;//求范围，f[1][0]=0 for(i=2;i&lt;=Max;i++) {//因为必经过0号点，所以直接从状态2开始，虽然2无意义，但是你要赋初值啊 for(j=0;j&lt;n;j++) {//就是枚举，判断可以 以哪些点为终点 f[i][j]=-INF;//赋初值 if((i&gt;&gt;j)&amp;1) {//判断 res=i^(1&lt;&lt;j);//除去为结尾的这个点，可以从哪些状态转移过来 for(k=0;k&lt;n;k++)//再枚举 if((res&gt;&gt;k)&amp;1&amp;&amp;b[k][j])//再判断，要注意有边才能走 f[i][j]=max(f[i][j],f[res][k]+b[k][j]);//求较大值 } } } --n; for(i=1+(1&lt;&lt;n);i&lt;=Max;i++)//以n为结尾的各种情况，i赋的初值是为了保证n-1这个点能取到 ans=max(ans,f[i][n]); printf(&quot;%d&quot;,ans); return 0; } 一点小问题可以自行思考一下时间复杂度 这里是不会超的，但是将$n$改为$20$时，仍不会$T$，暴力就是这么优秀","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://hovnySiLenCe.github.io/tags/状压DP/"},{"name":"Hamilton路径","slug":"Hamilton路径","permalink":"http://hovnySiLenCe.github.io/tags/Hamilton路径/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P1772」[ZJOI2006]物流运输 解题报告","slug":"Luogu_P1772-[ZJOI2006]LogisticsTransportation-Solution","date":"2019-06-10T14:25:46.000Z","updated":"2019-11-10T11:56:10.579Z","comments":true,"path":"2019/06/10/Luogu_P1772-[ZJOI2006]LogisticsTransportation-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/06/10/Luogu_P1772-[ZJOI2006]LogisticsTransportation-Solution/","excerpt":"","text":"前言震惊！这种非主流的方法居然$A$了 解题思路介绍一种不一样的思路，也就是不是DP的写法， 纯粹的最短路 数据范围比较小，然后又不同的天数 于是就可以搞分层图 改变路径的情况只要在一层的 $n$ 号点与下一层 $1$ 号点之间连一条边权为 $K$ 的边 不改变路径的情况这种情况比较复杂，但还是由于数据范围比较小，我们就可以愉快地暴力了 把每一种路径不改变的情况（称为阶段）求出来 先枚举 $i$，表示这一阶段的开始时间（即分层图上的第 $i$ 层）， 再枚举 $j$，表示这一阶段的结束时间（即分层图上的第 $j$ 层）， 期间，能用的点，应该在这阶段内的每一天都可以通过， 也就是只能走没标记过的点 对于每个阶段，也可以很愉快地跑最短路 跑完最短路的结果就是一次（跑一层）的费用，再乘上 层数，在第 $i$ 层的 $1$ 号点和第 $j$ 层的 $n$ 号点之间连边，也就是表示可以直接略过中间部分 最后再整体跑个图就好了 怎么可能没有坑 坑点就是，为了防止我们连在 $1$ 号点和 $n$ 号点的边更新 $n$ 号点所在层的其他节点的答案（毕竟你略过了中间部分就不能往回走了），所以在建图的时候，与 $n$ 号点相连的边由双向边改为单向边即可 Code#include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define rgt register #define M 10407 #define Mn 107 #define N 23 using namespace std; struct Edge{ int to,cost,nxt; Edge(int a,int b):to(a),cost(b) {} Edge(){ } }b[M&lt;&lt;1]; struct node{ int p,t,cost; node(int a,int b,int c):p(a),t(b),cost(c){} node(){} inline bool operator&lt; (const node x) const{ return cost&gt;x.cost; } }; int head[N],hed[Mn];//分别存点和时间 int n,m,t,T,K,D,d[N],s[N][Mn];//d数组是一层的最短路，s是分层图上最短路 bool vis[N],usd[N],gg[N][Mn];//usd记录一个阶段不能选的点有哪些 inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void Add(int x,int y,int cost) { b[++t]=Edge(y,cost),b[t].nxt=head[x],head[x]=t; } inline void add(int x,int y,int cost) { b[++t]=Edge(y,cost),b[t].nxt=hed[x],hed[x]=t; } inline void Spfa() {//求一层的最短路 int i,to,cur,cost; queue&lt;int&gt;p;p.push(1); memset(d,INF,sizeof(d)),d[1]=0,vis[1]=1; while(!p.empty()) { cur=p.front(),p.pop(),vis[cur]=0; for(i=head[cur];i;i=b[i].nxt) { to=b[i].to; if(usd[to]) continue; cost=d[cur]+b[i].cost; if(d[to]&gt;cost) { d[to]=cost; if(!vis[to]) vis[to]=1, p.push(to); } } } } inline void Dijstra() {//求整体的最短路 int i,to,p,t,cost; bool vis[N][Mn]; priority_queue&lt;node&gt;Q;Q.push(node(1,1,0)); memset(s,INF,sizeof(s));s[1][1]=0; memset(vis,0,sizeof(vis)); while(!Q.empty()) { p=Q.top().p,t=Q.top().t,Q.pop(); if(vis[p][t]||t&gt;T) continue;vis[p][t]=1; for(i=head[p];i;i=b[i].nxt) { to=b[i].to;if(gg[to][t]) continue; cost=b[i].cost+s[p][t]; if(s[to][t]&gt;cost) { s[to][t]=cost; Q.push(node(to,t,cost)); } } if(p==1) {//特别的操作，其实就是为了减少连边数（有俩个关键字太烦了 for(i=hed[t];i;i=b[i].nxt) { to=b[i].to,cost=b[i].cost+s[p][t]; if(s[n][to]&gt;cost) { s[n][to]=cost; Q.push(node(n,to,cost)); } } } else if(p==n) {//这种情况直接特判，不用连边（因为太烦了 if(s[1][t+1]&gt;s[n][t]+K) { s[1][t+1]=s[n][t]+K; Q.push(node(1,t+1,s[1][t+1])); } } } } int main() { int i,j,k,l,r,x,y,cost; T=read(),n=read(),K=read(),m=read(); for(i=1;i&lt;=m;i++) { x=read(),y=read(),cost=read(); if(x==n) swap(x,y);//建图的时候n点连的是单向边 if(y!=n) Add(y,x,cost); Add(x,y,cost); } D=read(); while(D--) { x=read(),l=read(),r=read(); for(i=l;i&lt;=r;i++) gg[x][i]=1;//gg就是不能用 } for(i=1;i&lt;T;i++) {//枚举i for(k=1;k&lt;=n;k++) usd[k]=gg[k][i];// for(j=i+1;j&lt;=T;j++) { for(k=1;k&lt;=n;k++) usd[k]|=gg[k][j]; Spfa();if(d[n]!=INF) add(i,j,d[n]*(j-i+1));//如果不连通，就不能连，否则就会嘿嘿嘿 } }Dijstra(); printf(&quot;%d&quot;,s[n][T]); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://hovnySiLenCe.github.io/tags/最短路/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3365」改造二叉树 解题报告","slug":"Luogu_P3365-TransformationBinaryTree-Solution","date":"2019-05-12T12:26:07.000Z","updated":"2019-12-01T07:28:29.305Z","comments":true,"path":"2019/05/12/Luogu_P3365-TransformationBinaryTree-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/05/12/Luogu_P3365-TransformationBinaryTree-Solution/","excerpt":"","text":"题面前言在打模拟赛的时候好像$sha$了一样想不出来，（肯定是我太菜了 解题思路题目中描述的是一棵二叉搜索树，但是实际上题目不要求改变树的形态，所以我们就把树形结构转化为线性结构，这应该是一个比较有用的小$tip$吧 转化为线性的数组之后，就变成了这样的问题： 求 使数组 严格上升 最少 要改变的元素个数 一开始想不出来，那就可以先打打暴力找灵感 for(i=1;i&lt;=n;++i) {//DP，f数组表示在保留i这个元素的情况下， for(j=i-1;j&gt;=0;--j)//最多可以保留多少元素 if(b[i]-b[j]&gt;=i-j) f[i]=max(f[i],f[j]+1); ans=max(f[i],ans); } 其实还是有点像$LIS$的感觉的 那从哪里入手呢？ $b[i]-b[j]&gt;=i-j$ 好像这个式子可以移项啊 然后就变成 $b[i]-i&gt;=b[j]-j$！！ 这下真的可以用最长不下降子序列那套东西了 将$O(n^2)$优化成$O(nlogn)$ 就是这么优秀 Code献上极短丑陋的代码 #include&lt;bits/stdc++.h&gt; #define getchar() *(p++) #define INF 0x7f7f7f7f #define rgt register #define N 100007//有巨佬说这里开奇数的数组能快一点 using namespace std; int son[N][2],n,t,a[N],b[N]; char bf[1&lt;&lt;23],*p; inline int read() {//快读不管 rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void built(rgt int x) { if(son[x][0]) built(son[x][0]);a[++t]=b[x]; if(son[x][1]) built(son[x][1]); } int main() { int i; bf[fread(bf,1,1&lt;&lt;23,stdin)]=&#39;\\0&#39;,p=bf;//快读一部分不管 n=read(); for(i=1;i&lt;=n;i++) b[i]=read();//读入每个原宿 for(i=2;i&lt;=n;i++) son[read()][read()]=i;//偷懒读入边 built(1),b[t=0]=-INF;//因为b[i]-i之后可能为负数，保险就赋一个极小值 for(i=1;i&lt;=n;++i) { a[i]-=i;//处理一下 if(b[t]&lt;=a[i]) b[++t]=a[i];//最长不下降子序列板子 else *upper_bound(b+1,b+t+1,a[i])=a[i];//直接指针 } printf(&quot;%d&quot;,n-t); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「USACO18OPEN」 Disruption 解题报告","slug":"USACO18OPEN-Disruption-Solution","date":"2019-04-21T10:49:39.000Z","updated":"2019-12-01T07:28:06.740Z","comments":true,"path":"2019/04/21/USACO18OPEN-Disruption-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/04/21/USACO18OPEN-Disruption-Solution/","excerpt":"","text":"题目描述题目描述$Farmer\\ John$自豪于他所经营的交通发达的的农场。这个农场是由$N$块牧场（$2 \\leq N \\leq 50,000$）组成的，$N-1$条双向道路将它们连接起来，每一条道路的都为一单位长度。$Farmer\\ John$注意到，从任何一块牧场到另一块牧场，都能通过一组合适的道路到达。 尽管$FJ$的农场现在是连通的，他担心如果有一条道路被阻断会发生什么，因为这事实上会将他的农场分为两个不相交的牧场集合，奶牛们只能够在每一个集合内移动但不能在集合间移动。于是$FJ$又建造了$M$条额外的双向道路（$1 \\leq M \\leq 50,000$），每一条的长度都是一个至多为$10^9$的正整数。奶牛们仍然可以使用原有的道路进行移动，除非其中的某些被阻断了。 如果某条原有的道路被阻断了，农场就会被分为两块不相交的区域，那么$FJ$就会从他的额外修建的道路中选择一条能够重建这两块区域的连通性的，取代原来那条，从而奶牛们又可以从任何一块牧场去往另一块牧场。 对于农场上每一条原有的道路，帮助$FJ$选出最短的替代用的道路。 输入输出格式输入格式：输入的第一行包含$N$和$M$。接下来的$N-1$行，每行用整数$p$和$q$描述了一条原有的道路，其中$p \\ne q$是这条道路连接的两块牧场（在$1 \\ldots N$范围内）。剩下的$M$行，每行用三个整数$p$、$q$和$r$描述了一条额外的道路，其中$r$是这条道路的长度。任何两块牧场之间至多只有一条道路。 输出格式：对原有的$N−1$条道路的每一条，按照它们在输入中出现的顺序，输出如果这条道路被阻断的话，能够重新连接农场的最短的替代用道路的长度。如果不存在合适的替代用的道路，输出$-1$。 输入输出样例输入样例#1：6 3 1 2 1 3 4 1 4 5 6 5 2 3 7 3 6 8 6 4 5 输出样例#1：7 7 8 5 5 解题思路树链剖分 经过比较仔细的分析，还是可以得出一条变删掉之后，加入的那条边必能使树重新联通，那么加入的这条边的两端点，在原树上的路径必经过那条删掉的边，$RT \\downarrow$ Code#include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define rgt register #define N 50010 using namespace std; struct node{ int to,nxt; }b[N&lt;&lt;1]; int head[N],seg[N],top[N],f[N&lt;&lt;2]; int deep[N],Sz[N],son[N],fa[N]; int n,m,t,x,y,num,L,R,res,ans; inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(rgt int x,rgt int y) { b[++t].to=y,b[t].nxt=head[x],head[x]=t; b[++t].to=x,b[t].nxt=head[y],head[y]=t; } inline void dfs1(rgt int k) { rgt int i,to; deep[k]=deep[fa[k]]+1,Sz[k]=1; for(i=head[k];i;i=b[i].nxt) { to=b[i].to; if(to==fa[k]) continue; fa[to]=k,dfs1(to); Sz[k]+=Sz[to]; if(Sz[to]&gt;Sz[son[k]]) son[k]=to; } } inline void dfs2(rgt int k) { if(son[k]) { seg[son[k]]=++num; top[son[k]]=top[k]; dfs2(son[k]); } rgt int i,to; for(i=head[k];i;i=b[i].nxt) { to=b[i].to; if(top[to]) continue; seg[to]=++num; top[to]=to; dfs2(to); } } inline void push(rgt int k) {//其实一个数组就够了，就是特判有点复杂 int cur=k&lt;&lt;1; f[cur]=min(f[cur],f[k]); f[cur|1]=min(f[cur|1],f[k]); f[k]=INF;//下传后初值要变成INF } inline void Modify(rgt int k,rgt int l,rgt int r) { if(f[k]!=INF&amp;&amp;l!=r) push(k); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) { f[k]=min(f[k],res); if(l!=r) push(k); return; } rgt int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; Modify(cur,l,mid); Modify(cur|1,mid+1,r); } #define fx top[x] #define fy top[y] inline void Add(int x,int y) { while(fx!=fy) { if(deep[fx]&lt;deep[fy]) swap(x,y); L=seg[fx],R=seg[x]; Modify(1,1,n); x=fa[fx]; } if(deep[x]&lt;deep[y]) swap(x,y); L=seg[y]+1,R=seg[x]; Modify(1,1,n); return; } inline void Query(rgt int k,rgt int l,rgt int r) { if(f[k]!=INF&amp;&amp;l!=r) push(k); if(l==r&amp;&amp;l==L) {ans=f[k];return;} rgt int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; if(L&lt;=mid) Query(cur,l,mid); else Query(cur|1,mid+1,r); } int main() { int i; n=read(),m=read(); for(i=1;i&lt;n;i++) x=read(),y=read(),add(x,y); num=seg[1]=top[1]=1; dfs1(1),dfs2(1); memset(f,INF,sizeof(f));//注意一开始的初始化 for(i=1;i&lt;=m;i++) { x=read(),y=read(),res=read(); Add(x,y); } for(i=1;i&lt;t;i+=2) { x=b[i+1].to,y=b[i].to; if(deep[x]&gt;deep[y]) L=seg[x]; else L=seg[y]; Query(1,1,n); if(ans!=INF) printf(&quot;%d\\n&quot;,ans); else printf(&quot;-1\\n&quot;); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://hovnySiLenCe.github.io/tags/树链剖分/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3306」[SDOI2013]随机数生成器 解题报告","slug":"Luogu_P3306-[SDOI2013]RandomMachine-Solution","date":"2019-04-21T06:45:12.000Z","updated":"2019-12-01T07:28:29.804Z","comments":true,"path":"2019/04/21/Luogu_P3306-[SDOI2013]RandomMachine-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/04/21/Luogu_P3306-[SDOI2013]RandomMachine-Solution/","excerpt":"","text":"题目描述小$W$喜欢读书，尤其喜欢读《约翰克里斯朵夫》。最近小W准备读一本新书，这本书一共有$P$页，页码范围为$0 \\cdots P-1$。 小$W$很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用NOI2012上学习的线性同余法生成一个序列，来决定每天具体读哪一页。 我们用$Xi$来表示通过这种方法生成出来的第$i$个数，也即小$W$第$i$天会读哪一页。这个方法需要设置$3$个参数$a,b,X1$，满足$0\\leq a,b,X1\\leq p-1$，且$a,b,X1$都是整数。按照下面的公式生成出来一系列的整数：$X_{i+1} \\equiv aX_i+b \\pmod p$其中$mod$表示取余操作。 但是这种方法可能导致某两天读的页码一样。 小W要读这本书的第$t$页，所以他想知道最早在哪一天能读到第$T$页，或者指出他永远不会读到第$t$页。 输入输出格式输入格式：输入含有多组数据，第一行一个正整数$T$，表示这个测试点内的数据组数。 接下来$T$行，每行有五个整数$p$，$a$，$b$，$X1$，$t$，表示一组数据。保证$X1$和$t$都是合法的页码。 注意：$P$一定为质数 输出格式：共$T$行，每行一个整数表示他最早读到第$t$页是哪一天。如果他永远不会读到第$t$页，输出$-1$。 输入输出样例输入样例#1：37 1 1 3 37 2 2 2 07 2 2 2 1输出样例#1：13-1 说明$0≤a≤P−1,0≤b≤P−1,2≤P≤10^9$ 前言致敬自己的$16$次提交，漏洞百出 解题思路这种题目，当然就是找规律套路题啊 有经验就会知道这是一道BSGS的题 找BSGS找到的不是BSGS是什么 最复杂的就是颓推公式了 先随便从$x_1$开始写几组 $x_1=x_1$ 题目已经给出了 $x_2=ax_1+b$ $x_3=a^2x_1+ab+b$ $x_4=a^3x_1+a^2b+ab+b$ 好像就可以得出结论了 x_i=a^{i-1}x_1+a^{i-1}b+a^{i-2}b+…+b对于后面这一串东东，如果上过小学学过等比数列求和公式的巨蛤都知道 x_i=a^{i-1}x_1+\\frac{b(1-a^{i-1})} {1-a}那么是不是可以开始狂颓公式了 1、换元（这绝对不是高中数学课 x_i \\equiv t(mod\\ p)然后把上面那个代入 a^{i-1}x_1+\\frac {b(1-a^{i-1})} {1-a} \\equiv t疯狂搞一搞，把$a^{i-1}$搞出来 （1-a）·a^{i-1}x_1+{b(1-a^{i-1})} \\equiv t-t·a (x_1-x_1·a)·a^{i-1}+b-b·a^{i-1} \\equiv t-t·a (x_1-x_1·a-b)·a^{i-1}\\equiv t-t·a-b a^{i-1}\\equiv \\frac {t-t·a-b} {x_1-x_1·a-b}这样我们就可以按照普通的$BSGS$求，把结果$+1$即可 然后就很OK了 然鹅并没完，（不要问为什么，否则我也不会提交16次了 考虑几种特殊情况： $1、x_1=t$ 第一天就可以读到，输出1，其实也没是什么影响，因为结果还是一样的 $2、a=1$ 这就变成了$x_1+k·b \\equiv t(mod\\ p)$，费马小定理求一下就好了，注意无解的情况——也就是$b=0$ $3、a=0$ 傻子都知道和$x_1$无关了，这时只要判断一下$b==t$，则第二天就能读到$t$，否则读一辈子都读不完（那就别读了 Code：#include&lt;bits/stdc++.h&gt;//这里原题中的t用r表示 #define rgt register #define ll long long #define N 100007 using namespace std; int head[N],nxt[N],val[N],num[N];//用hash表存会快一点，虽然可以用unordered_map int T,t,ans; ll a,b,r,p,x,Mol,Den,res;//Mol是分子，Den是分母，（鬼畜的变量名 inline int read() { rgt int s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void Insert(rgt int x,rgt int y) {//插入，链式前向星 nxt[++t]=head[x%N],head[x%N]=t; val[t]=x,num[t]=y; } inline int Search(rgt int x) {//查询，理论上是挺快的 for(rgt int i=head[x%N];i;i=nxt[i]) if(val[i]==x) return num[i]; return -1; } inline ll Pow(rgt ll a,rgt int b) {//快速幂 rgt ll res=1; while(b) { if(b&amp;1) res=res*a%p; a=a*a%p,b&gt;&gt;=1; } return res; } inline void Init() {//初始化 memset(head,0,sizeof(head)),t=0;//t用于链式前向星，原来的t代码中用r表示 Mol=((r-r*a-b)%p+p)%p,Den=Pow(((x-a*x-b)%p+p)%p,p-2);//求出右边那一大串东东 b=Mol*Den%p;//现在就变成了a^x≡b(mod p) } inline int BSGS() { Init(); if(b==1) return 0;//有这个下文x==r的特判就可以省去 rgt int i,j,t; t=sqrt(p)+1,res=b; for(i=0;i&lt;t;i++) Insert(res,i),res=res*a%p; a=Pow(a,t),res=1; if(!a) return (!b)?1:-1; for(i=0;i&lt;=t;i++) { j=Search(res); if(j&gt;=0&amp;&amp;i*t-j&gt;=0) return i*t-j; res=res*a%p; } return -1; } int main() { T=read(); while(T--) { p=read(),a=read(),b=read(),x=read(),r=read(); if(x==r) {printf(&quot;1\\n&quot;);continue;} if(a==1) { if(!b) printf(&quot;-1\\n&quot;); else { r=((r-x)%p+p)%p; printf(&quot;%lld\\n&quot;,r*Pow(b,p-2)%p+1); } continue; } if(!a) { if(b==r) printf(&quot;2\\n&quot;); else printf(&quot;-1\\n&quot;); continue; } ans=BSGS(); if(~ans) printf(&quot;%d\\n&quot;,ans+1);//答案记得+1 else printf(&quot;-1\\n&quot;); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"BSGS","slug":"BSGS","permalink":"http://hovnySiLenCe.github.io/tags/BSGS/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2486」[SDOI2011]染色 解题报告","slug":"Luogu_P2486-[SDOI2011]Dye-Solution","date":"2019-04-02T14:21:33.000Z","updated":"2019-12-01T07:28:33.603Z","comments":true,"path":"2019/04/02/Luogu_P2486-[SDOI2011]Dye-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/04/02/Luogu_P2486-[SDOI2011]Dye-Solution/","excerpt":"","text":"前言这是屯了一道很久的题目，昨天做完今天补一下题解，其实也并不是很难，只要想清楚一些细节就好了 题面树上区间覆盖，区间查询颜色段数 解题思路由易到难是我们数学老师经常说的一句话，所以我们这里也来乱搞应用一下 0、预备首先，这当然是一道树剖的题，然后加一个线段树维护区间颜色段数，考虑到合并时候最多就是中间会少去一段 $1\\ 3\\ 4$ 和 $4\\ 2 \\ 1$合并时，中间的$4$会多算一遍，所以要减去 也就是说，我们需要记录三个值 $l$和$r$是当前区间的左右端点，用$k$表示当前区间的编号 $f[k]\\ =\\ l$到$r$这段区间中颜色段数 $fl[k]\\ =\\ $最左边节点的颜色，也就是$l$的颜色 $fr[k]\\ =\\ $最右边节点的颜色，即$r$的颜色 于是$built$就可以这样写： inline void Upd(register int k,register int cur) { f[k]=f[cur]+f[cur|1]-(fr[cur]==fl[cur|1]); fl[k]=fl[cur],fr[k]=fr[cur|1]; } void built(register int k,register int l,register int r) { if(l&gt;r) return; if(l==r) {fl[k]=fr[k]=a[rev[l]];f[k]=1;return;}//不要忘记rev数组 register int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; built(cur,l,mid); built(cur|1,mid+1,r); Upd(k,cur); } 1、对于不在树上的修改&amp;查询修改区间覆盖，肯定是直接覆盖不用说的，区间修改注意打标记的方式，然后再和$built$的时候一样$Upd$一下就好了，感性理解这样是对的 对于查询，线段树的查询方式是将$[L,R]$这个区间分成$Log$块，然后依次查询$[L,R]$的每一块，很明显，查询的顺序是从左到右的，那么和$built$的时候一样，$Upd$把左右节点相同颜色的情况减掉即可 $Las\\ =\\ $上一次查询的块 最右节点的颜色（$Las$的初始值为一个不可能在序列中出现的数，比如$0$） 然后就可以这样写查询： void Query(register int k,register int l,register int r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) { if(Las==fl[k]) --ans; ans+=f[k];Las=fr[k]; if(l==L) Lres=fl[k]; if(r==R) Rres=fr[k]; return; } register int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; Query(cur,l,mid); Query(cur|1,mid+1,r); } 2、对于在树上的修改虽然会分成很多链，但实际上人的本质是不变的，只要对于每条重链$Modify$一下就好了 3、对于在树上的查询现在不仅是块了，还有很多条链相连，所以还要考虑链的影响，但其实链的本质和上文所述块是一样的，也只要记录一下相邻的两个点就好了，为了方便，我直接全部记录在数组里，最后再一起遍历了，不要这种写法也是可以的，开几个变量然后在过程中判断就好了 附上超多的代码： #define fx top[x] #define fy top[y] inline void Uni() { register int i; for(i=2;i&lt;p[0][0];i+=2) ans-=(p[i][0]==p[i+1][0]); for(i=2;i&lt;p[0][1];i+=2) ans-=(p[i][1]==p[i+1][1]); if(p[p[0][0]][0]==p[p[0][1]][1]) --ans; printf(&quot;%d\\n&quot;,ans); } inline void Ask() { p[0][0]=p[0][1]=ans=0;//表示的是公共祖先左边这条链和右边这条链的键值个数 register int l=0;//表示当前的x是在公共祖先的哪一边，初始的时候默认x一侧为0 while(fx!=fy) { if(deep[fx]&lt;deep[fy]) swap(x,y),l^=1; L=seg[fx],R=seg[x],Las=0; Query(1,1,num); p[++p[0][l]][l]=Rres,p[++p[0][l]][l]=Lres;//就是把键值记录进去 x=fa[fx]; } if(deep[x]&lt;deep[y]) swap(x,y),l^=1; L=seg[y],R=seg[x],Las=0; Query(1,1,num); p[++p[0][l]][l]=Rres,p[++p[0][l]][l]=Lres; Uni();//最后再一起搞 return; } Code#include&lt;bits/stdc++.h&gt; #define getchar() *(pos++) #define fx top[x] #define fy top[y] #define N 100010 using namespace std; struct node{ int to,nxt; }b[N&lt;&lt;1]; int head[N],seg[N],top[N],rev[N],tag[N&lt;&lt;2],f[N&lt;&lt;2]; int deep[N],Sz[N],son[N],fa[N],fl[N&lt;&lt;2],fr[N&lt;&lt;2]; int n,T,C,t,num,x,y,a[N],p[N&lt;&lt;1][2],L,R,Lres,Rres,ans,Las; char bf[1&lt;&lt;25],*pos; inline int read() { register int s=0; register char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(register int x,register int y) { b[++t].to=y,b[t].nxt=head[x],head[x]=t; b[++t].to=x,b[t].nxt=head[y],head[y]=t; } void dfs1(int k) { int i,to; deep[k]=deep[fa[k]]+1;Sz[k]=1; for(i=head[k];i;i=b[i].nxt) { to=b[i].to; if(to==fa[k]) continue; fa[to]=k,dfs1(to); Sz[k]+=Sz[to]; if(Sz[to]&gt;Sz[son[k]]) son[k]=to; } } void dfs2(int k) { if(son[k]) { seg[son[k]]=++num; top[son[k]]=top[k]; rev[num]=son[k]; dfs2(son[k]); } int i,to; for(i=head[k];i;i=b[i].nxt) { to=b[i].to; if(top[to]) continue; seg[to]=++num; rev[num]=to; top[to]=to; dfs2(to); } } inline void Upd(register int k,register int cur) { f[k]=f[cur]+f[cur|1]-(fr[cur]==fl[cur|1]); fl[k]=fl[cur],fr[k]=fr[cur|1]; } void built(register int k,register int l,register int r) { if(l&gt;r) return; if(l==r) {fl[k]=fr[k]=a[rev[l]];f[k]=1;return;} register int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; built(cur,l,mid); built(cur|1,mid+1,r); Upd(k,cur); } inline void push(register int k,register int l,register int r) { f[k]=1; fl[k]=fr[k]=tag[k]; if(l!=r) { register int cur=k&lt;&lt;1; tag[cur]=tag[cur|1]=tag[k]; } tag[k]=0; } void Modify(register int k,register int l,register int r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) { tag[k]=C; push(k,l,r); return; } register int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; Modify(cur,l,mid); Modify(cur|1,mid+1,r); Upd(k,cur); } void Query(register int k,register int l,register int r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) { if(Las==fl[k]) --ans; ans+=f[k];Las=fr[k]; if(l==L) Lres=fl[k]; if(r==R) Rres=fr[k]; return; } register int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; Query(cur,l,mid); Query(cur|1,mid+1,r); } inline void Add() {//修改就放一起了，直接模板式改就好了 C=read(); while(fx!=fy) { if(deep[fx]&lt;deep[fy]) swap(x,y); L=seg[fx],R=seg[x]; Modify(1,1,num); x=fa[fx]; } if(deep[x]&lt;deep[y]) swap(x,y); L=seg[y],R=seg[x]; Modify(1,1,num); return; } inline void Uni() { register int i; for(i=2;i&lt;p[0][0];i+=2)//首先要理解每条重链的键值成对出现，而两条链之间的键值才是有用的 ans-=(p[i][0]==p[i+1][0]); for(i=2;i&lt;p[0][1];i+=2) ans-=(p[i][1]==p[i+1][1]); if(p[p[0][0]][0]==p[p[0][1]][1]) --ans;//最后尾连接的时候也要判断一下 printf(&quot;%d\\n&quot;,ans); } inline void Ask() { p[0][0]=p[0][1]=ans=0; register int l=0; while(fx!=fy) { if(deep[fx]&lt;deep[fy]) swap(x,y),l^=1; L=seg[fx],R=seg[x],Las=0; Query(1,1,num); p[++p[0][l]][l]=Rres,p[++p[0][l]][l]=Lres; x=fa[fx]; } if(deep[x]&lt;deep[y]) swap(x,y),l^=1; L=seg[y],R=seg[x],Las=0; Query(1,1,num); p[++p[0][l]][l]=Rres,p[++p[0][l]][l]=Lres; Uni(); return; } int main() { int i; char c; bf[fread(bf,1,1&lt;&lt;25,stdin)]=&#39;\\0&#39;,pos=bf; n=read();T=read(); for(i=1;i&lt;=n;i++) a[i]=read(); for(i=1;i&lt;n;i++) x=read(),y=read(),add(x,y); num=seg[1]=rev[1]=top[1]=1; dfs1(1),dfs2(1),built(1,1,num); while(T--) { c=getchar(); while(c!=&#39;C&#39;&amp;&amp;c!=&#39;Q&#39;) c=getchar(); x=read(),y=read(); if(c==&#39;C&#39;) Add(); else Ask(); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://hovnySiLenCe.github.io/tags/树链剖分/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「UVA10444」Multi-peg Towers of Hanoi 解题报告","slug":"UVA10444-Multi-peg_Towers_of_Hanoi-Solution","date":"2019-03-29T14:48:27.000Z","updated":"2019-12-01T07:28:05.644Z","comments":true,"path":"2019/03/29/UVA10444-Multi-peg_Towers_of_Hanoi-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/29/UVA10444-Multi-peg_Towers_of_Hanoi-Solution/","excerpt":"","text":"题面求 $p(3&lt; p \\le 20)$ 根杆子，$n(0\\le n \\le200)$ 个圆盘的最优解（规则和普通汉诺塔一样） 解题思路$DP$ 分析设 $f[k][i]$ 表示 $k$ 根杆子和 $i$ 个圆盘时的状态，则： f[k][i]=min\\{2\\times f[k][j]+f[k-1][i-j]\\},1\\le j < i表示的意思是： 先把 $j$ 个圆盘在 $k$ 根杆子的情况下转移，再将剩下的 $i-j$ 个圆盘在 $k-1$ 根杆子的情况下转移 这样读懂了之后代码就很好写了 Warning$ n\\le 200 $，所以……高精或者py​ Code#include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define ll long long #define N 200 using namespace std; struct node{ int a[110],l; node operator+ (const node x) const{//其实重载个加法就非常方便了 int L=max(l,x.l);node y;//L表示长度 y.a[1]=0; for(int i=1;i&lt;=L;i++) { y.a[i]+=a[i]+x.a[i]; y.a[i+1]=y.a[i]/10; y.a[i]%=10; } if(y.a[L+1]) ++L;y.l=L; return y; } }f[25][N+7],init;//init是一个单位的数，也就是1 int n,p,t; inline node Min(register node a,register node b) {//比较大小 if(a.l!=b.l) return (a.l&lt;b.l)?a:b; register int t=a.l; while(a.a[t]==b.a[t]&amp;&amp;t) --t; return (a.a[t]&lt;b.a[t])?a:b; } inline void Init() {//预处理一下 int i,j,k;init.a[1]=1,init.l=1;f[3][1]=init; for(i=2;i&lt;=N;i++) f[3][i]=(f[3][i-1]+f[3][i-1])+init; for(k=4;k&lt;=20;k++) { f[k][1]=init; for(i=2;i&lt;=N;i++) { f[k][i].l=INF; for(j=1;j&lt;i;j++) f[k][i]=Min(f[k][i],(f[k][j]+f[k][j])+f[k-1][i-j]); } } } inline void Print(register int n,register int p) { int i; printf(&quot;Case %d: &quot;,++t); if(!f[p][n].l) {puts(&quot;0&quot;);return;} for(i=f[p][n].l;i;i--) printf(&quot;%d&quot;,f[p][n].a[i]); puts(&quot;&quot;); } int main() { Init(); while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;p)&amp;&amp;p!=0) Print(n,p);//输出就好了 return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://hovnySiLenCe.github.io/tags/动态规划/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「算法竞赛进阶指南」0x01 最短Hamilton路径 解题报告","slug":"AlgorithmGuide-0x01_ShortHamiltonPath-Solution","date":"2019-03-27T13:59:31.000Z","updated":"2019-11-09T07:13:28.213Z","comments":true,"path":"2019/03/27/AlgorithmGuide-0x01_ShortHamiltonPath-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/AlgorithmGuide-0x01_ShortHamiltonPath-Solution/","excerpt":"","text":"题目在这里啊题目在这里~ Hamilton路径：将所有点都遍历刚好一次的路径 思路：数据范围比较小（1~20），所以我们可以考虑暴力中的枚举 数组f[i][j] i的二进制表示选取了哪些点 j表示以哪个点结尾 然后就是状态压缩 由于求的是最小值，所以一开始的时候要赋初值INF 为了有解，f[1][0]应该赋值为0. #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define Max (1&lt;&lt;n) using namespace std; int n; int a[20][20]; int f[1&lt;&lt;20][20]; int res; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void Hamilton() { int i,j,k; f[1][0]=0; for(i=2;i&lt;Max;i++) { for(j=0;j&lt;n;j++) { f[i][j]=INF; if((i&gt;&gt;j)&amp;1) { res=i^(1&lt;&lt;j); for(k=0;k&lt;n;k++) if((res&gt;&gt;k)&amp;1) f[i][j]=min(f[i][j],f[res][k]+a[k][j]); } } } return; } int main() { int i,j; n=read(); for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) a[i][j]=read(); Hamilton(); printf(&quot;%d\\n&quot;,f[Max-1][n-1]); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"Hamilton路径","slug":"Hamilton路径","permalink":"http://hovnySiLenCe.github.io/tags/Hamilton路径/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「算法竞赛进阶指南」0x01 位运算 学习笔记","slug":"AlgorithmGuide-0x01_bit-Notes","date":"2019-03-27T13:58:30.000Z","updated":"2019-11-02T10:03:34.806Z","comments":true,"path":"2019/03/27/AlgorithmGuide-0x01_bit-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/AlgorithmGuide-0x01_bit-Notes/","excerpt":"","text":"只是一些抄来的trick而已 int lowbit(int x) { return x&amp;(-x);//x&amp;(~x+1),~x=-1-x; } int __builtin_ctz(unsigned int x) int __builtin_ctzll(unsigned long long x) 返回x的二进制表示下最低位的1后面有多少个0 int __builtin_popcount(unsigned int x) int __builtin_popcountll(unsigned long long x) 返回x的二进制表示下有多少位为1","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://hovnySiLenCe.github.io/tags/位运算/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://hovnySiLenCe.github.io/categories/学习笔记/"}]},{"title":"「USACO11NOV」牛的障碍Cow Steeplechase 解题报告","slug":"USACO11NOV-Cow_Steeplechase-Solution","date":"2019-03-27T13:58:25.000Z","updated":"2019-12-01T07:28:07.992Z","comments":true,"path":"2019/03/27/USACO11NOV-Cow_Steeplechase-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/USACO11NOV-Cow_Steeplechase-Solution/","excerpt":"","text":"$\\mathtt{Updata\\ 2019.11.13}$ 今天膜你赛做到了原题，不得不来修一下 $blog$ 题面有 $n$ 条平行于坐标轴线段，取的线段要求不相交，最大化所取线段数目 解题思路二分图匹配 分析把平行于 $x$ 轴和平行于 $y$ 轴的线段分别看成两个集合，这样就和二分图有关了 从最小割的方面想，要想所选的数目尽量多，那么就是不能选的尽量少 显然，如果两条线段有相交的部分，则有一条必不能取，因此以是否相交为依据建边，再跑一个最小割，或者说就是二分图的最大匹配，答案即为 $n-Maxflow$ 可以用 $Dinic$ 或者匈牙利算法实现 warning个人认为最大的坑点是所给的线段的端点不是有序的，比如平行于 $x$ 轴的线段的两个端点可能并不是按照两点 $x$ 坐标的大小给出，要特别判断，否则，判断相交的时候就 $GG$ 了，当然不要忘记网络流建边开四十倍 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define inf 0x7f7f7f7f #define M 3000003 #define N 257 using namespace std; template&lt;class K&gt;inline bool cmax(K&amp;a,const K&amp;b){return(a&lt;b)?a=b,1:0;} template&lt;class K&gt;inline bool cmin(K&amp;a,const K&amp;b){return(a&gt;b)?a=b,1:0;} inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } struct Edge{ int to,nxt,cap; Edge(int a,int b,int c):to(a),nxt(b),cap(c){} Edge(){} }b[M]; struct segment{ int lx,ly,rx,ry; inline void in() { lx=read(),ly=read(), rx=read(),ry=read(); if(lx&gt;rx) lx^=rx^=lx^=rx;//可能不是有序的 if(ly&gt;ry) ly^=ry^=ly^=ry; } }A[N],B[N],c; int n,la,lb,t=1,S,T,head[N],dep[N],Maxflow; inline void add(rint x,rint y) { b[++t]=Edge(y,head[x],1),head[x]=t, b[++t]=Edge(x,head[y],0),head[y]=t; } inline bool cross(rgt segment a,rgt segment b) {//判断相交 return b.lx&lt;=a.lx&amp;&amp;a.lx&lt;=b.rx&amp;&amp;a.ly&lt;=b.ly&amp;&amp;b.ly&lt;=a.ry; } inline bool BFS() { rint i,to,cur,cap; queue&lt;int&gt;p; memset(dep,0,sizeof(dep)); dep[S]=1,p.push(S); while(!p.empty()) { cur=p.front(),p.pop(); for(i=head[cur];i;i=b[i].nxt) { to=b[i].to; if(b[i].cap&amp;&amp;!dep[to]) { dep[to]=dep[cur]+1; if(to==T) return 1; p.push(to); } } }return 0; } inline int Dinic(rint k,rint flow) { if(k==T) return flow; rint i,to,cap,res,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].nxt) { to=b[i].to,cap=b[i].cap; if(cap&amp;&amp;dep[to]==dep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) dep[to]=0; b[i].cap-=res, b[i^1].cap+=res, rest-=res; } } return flow-rest; } int main() { rint i,j,flow;n=read(); for(i=1;i&lt;=n;i++) { c.in(); if(c.lx==c.rx) A[++la]=c;//按照平行的坐标分组 else B[++lb]=c; }T=n+1; for(i=1;i&lt;=la;i++) add(S,i);//超源和超汇 for(i=1;i&lt;=lb;i++) add(i+la,T); for(i=1;i&lt;=la;i++) for(j=1;j&lt;=lb;j++) if(cross(A[i],B[j]))//相交就建边 add(i,j+la); while(BFS())//Dinic大法吼 while((flow=Dinic(S,inf))) Maxflow+=flow; printf(&quot;%d&quot;,n-Maxflow); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://hovnySiLenCe.github.io/tags/网络流/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「SP23776」KQUERYO - K-Query Online 解题报告","slug":"SP23776-KQUERYO_KQueryOnline-Solution","date":"2019-03-27T13:58:12.000Z","updated":"2019-12-01T07:28:09.052Z","comments":true,"path":"2019/03/27/SP23776-KQUERYO_KQueryOnline-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/SP23776-KQUERYO_KQueryOnline-Solution/","excerpt":"","text":"题面$n$个数，$q$次询问，询问$[i,j]$区间大于$k$的数的个数，输入时，输入$a,b,c$ i = a xor last_ans j = b xor last_ans k = c xor last_ans 一开始last_ans为$0$ 思路：主席树 其实是一道模板题 离散化后直接硬上模板 要注意的地方就是—— 最后查询的时候$k$不要离散化，而是在查询函数中改变判断条件 Code： #include&lt;bits/stdc++.h&gt; #define N 30010 using namespace std; struct node{ int l,r,sum; }T[N*30]; int a[N],b[N],root[N],t,n,m,res; int x,y,k,ans; int read(){ int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void built(int l,int r,int &amp;x,int y,int pos) { T[++res]=T[y];T[res].sum++;x=res; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) built(l,mid,T[x].l,T[y].l,pos); else built(mid+1,r,T[x].r,T[y].r,pos); } void query(int l,int r,int x,int y) { if(l==r) { if(b[l]&lt;=k) ans+=T[y].sum-T[x].sum; return; } int mid=(l+r)&gt;&gt;1; int sum=T[T[y].l].sum-T[T[x].l].sum; if(k&lt;=b[mid])//就是在这里加判断 query(l,mid,T[x].l,T[y].l); else ans+=sum,query(mid+1,r,T[x].r,T[y].r);//ans加上左子树的大小，表示有多少个数比k小 }//但是实际上可以把条件改一改，然后加上右子树的大小，这里为了方便理解，就不改了 int main() { int i; n=read(); for(i=1;i&lt;=n;i++) b[i]=a[i]=read(); sort(b+1,b+1+n);t=unique(b+1,b+1+n)-b-1; for(i=1;i&lt;=n;i++) { a[i]=lower_bound(b+1,b+1+t,a[i])-b; built(1,t,root[i],root[i-1],a[i]); } m=read(); for(i=1;i&lt;=m;i++) { x=read()^ans;y=read()^ans;k=read()^ans;ans=0; if(x&lt;1) x=1; if(y&gt;n) y=n; if(x&gt;y) { printf(&quot;%d\\n&quot;,ans); continue; } query(1,t,root[x-1],root[y]); ans=y-x+1-ans; printf(&quot;%d\\n&quot;,ans); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://hovnySiLenCe.github.io/tags/主席树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「SP20644」ZQUERY - Zero Query 解题报告","slug":"SP20644-ZQUERY0_ZeroQuery-Solution","date":"2019-03-27T13:53:16.000Z","updated":"2019-12-01T07:28:09.444Z","comments":true,"path":"2019/03/27/SP20644-ZQUERY0_ZeroQuery-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/SP20644-ZQUERY0_ZeroQuery-Solution/","excerpt":"","text":"题面SPOJ上的题，数据都很坑 大意：长度为$n$的序列，序列中的值为$1$或$-1$ 有$m$个询问，询问在$[L,R]$中区间和为$0$的区间的最大长度 这样会比较好理解吧，翻译的时候没翻好 思路：莫队+multiset对于这种区间乱搞操作的，一般选用莫队(Mo’s algorithm)比较方便 来做这道题的大佬们应该都有学过莫队吧，$Luogu$没有莫队模板确实是一件比较复杂的事情，原本这道题$\\large \\to$HH的项链还是能用莫队水过去，然后结果数据加强了…… 莫队模板题$\\to$小B的询问可以去做一下 求和为$0$的区间，显然是要预处理的，所以读入的时候就记录前缀和 那么题目转化为$\\to$两个相同元素的最大间距 原先的样例为： 1 1 1 -1 -1 -1 转化为前缀和： 1 2 3 2 1 0 求$[1,3]$这个区间，由于前缀和的影响，不应该直接在$[1,3]$这个区间里找相同，而是应该把左端点左移一位，求$[0,3]$这个区间的相同 由于区间的相同元素可能有多个： 1 -1 1 -1 1 -1 这组数据转化后就是： 1 0 1 0 1 0 设元素$x$，在$[l,r]$中最早出现的位置为$Min[x]$，最晚出现的位置为$Max[x]$ 在$[1,6]$中，元素$1$和$0$分别有$3$个，但是实际上第一个$1$（或$0$）和最后一个$1$（或$0$）才是有价值的（也就是$Max[1],min[1],Max[0],Min[0]$，价值为他们之间的距离，即$5-1=4$或$6-2=4$），那么中间的元素就可以省去吗？ 不行！由于莫队算法中$Add$和$Del$操作，要求我们记录这些值，才能在$O(1)$的时间里更新 $[l,r]$这个区间里，由每种元素都有可能构成最优值，因此还要用$multiset$记录每种元素的最优值，当然，如果一个区间中某个元素只出现了一次，那么该元素的价值应该是$Max[x]=Min[x],Max[x]-Min[x]=0$，也可以加入$multiset$中，但是在这里我怕时间无法承受，就特判掉了 那么如何记录这些中间值呢？我只想到了链表，其实双端队列（$deque$应该也可以，如果不怕炸的话） 再说一下前缀和，前缀和可能是负数哦~ 那么就加一个$n+1$就够了（$n$为序列长度，当然保险点加个$n+7$） Code： #include&lt;bits/stdc++.h&gt; #define N 50010 using namespace std; struct node{ int l,r,i; }b[N]; int a[N],n,m,block,pos[N],l,r,num; int Min[N&lt;&lt;1],Max[N&lt;&lt;1],Ans[N],L[N],R[N];//Ans记录答案，其他数组用于存链表，据说STL中与一个list multiset&lt;int&gt;ans; bool cmp(node a,node b){//莫队奇偶划分 return (pos[a.l]==pos[b.l])?(pos[a.l]&amp;1)?a.r&gt;b.r:a.r&lt;b.r:a.l&lt;b.l; } void Add(int x){//添加 num=a[x]+n+1; if(Max[num]&lt;0)//这种情况链表中没有元素 { Max[num]=Min[num]=x; return; } if(Max[num]!=Min[num])//要更新价值，原先的就要删掉，特判掉了价值为0的情况，为0不删 ans.erase(ans.lower_bound(Max[num]-Min[num])); if(Min[num]&gt;x)//加入头 { L[Min[num]]=x; R[x]=Min[num]; Min[num]=x; } else//加入尾 { R[Max[num]]=x; L[x]=Max[num]; Max[num]=x; } ans.insert(Max[num]-Min[num]);//更新最大值 } void Del(int x){//删除 num=a[x]+n+1; if(Min[num]==Max[num]) { Max[num]=-1;Min[num]=(n&lt;&lt;1)+7; return; } ans.erase(ans.lower_bound(Max[num]-Min[num])); if(Min[num]==x) Min[num]=R[x]; else Max[num]=L[x]; if(Max[num]!=Min[num]) ans.insert(Max[num]-Min[num]); } int main() { int i,j; scanf(&quot;%d%d&quot;,&amp;n,&amp;m);block=pow(n,0.54);//玄学优化 for(i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); a[i]+=a[i-1];//前缀和 pos[i]=i/block; } for(i=1;i&lt;=m;i++) scanf(&quot;%d%d&quot;,&amp;b[i].l,&amp;b[i].r),b[i].i=i; sort(b+1,b+1+m,cmp);l=1; for(i=1;i&lt;=(n&lt;&lt;1)+7;i++) Min[i]=(n&lt;&lt;1)+7,Max[i]=-1;//Max[i]赋为-1是为了包容0这个位置 ans.insert(0);//预先输入0，防止RE（可我还是RE了） for(i=1;i&lt;=m;i++) { while(r&lt;b[i].r) Add(++r); while(l&gt;b[i].l-1) Add(--l);//如果RE了，就把Add往前挪吧，千万要注意顺序！ while(r&gt;b[i].r) Del(r--);//否则Del(r--)后，r的值可能小于l，然后就爆炸 while(l&lt;b[i].l-1) Del(l++); Ans[b[i].i]=*(--ans.end());//最大的价值 } for(i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,Ans[i]); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://hovnySiLenCe.github.io/tags/莫队/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「SP1487」PT07J - Query on a tree III 解题报告","slug":"SP1487-PT07J_QueryOnATreeIII-Solution","date":"2019-03-27T13:53:05.000Z","updated":"2019-12-01T07:28:09.859Z","comments":true,"path":"2019/03/27/SP1487-PT07J_QueryOnATreeIII-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/SP1487-PT07J_QueryOnATreeIII-Solution/","excerpt":"","text":"戳这里看题面一道挺有意思的题，可以练一下板子 大意：给出$n(1\\le n \\le10^5)$个结点的树，$m$组询问，求 以$x$为根节点的树中 第$k$小的数（从小到大第$k$个） 题目中没翻译清楚，该树树以$1$为根节点 思路：对于树上操作，我已开始想到的是树剖，但是题目中所求的是以$x$为根的树，那么那么就应该想到DFS序 这和树剖一样，是一个能将树形结构转化为线性结构的神奇的东西 确定了使用$DFS$序之后，对于树中第$k$小，由于它是不带修的，所以很容易想到使用主席树 然后就开始乱搞了 注意要点：题目中所求的是第$k$小点的编号！！ 主席树查询出结果后，这个l值不是实际上的编号 因为主席树最后得到l==r的时候，l的值实际上是这个点在权值线段树中的位置 而这个点原先的Id并不一定是l，所以还要记录一下Id然后再对应回去 具体详见代码吧，结合代码说的更清楚 Code： #include&lt;bits/stdc++.h&gt; #define N 100010 using namespace std; struct node{ int to,nxt; }b[N&lt;&lt;1]; struct Node{ int l,r,sum; }T[N*80];//开大点没事，但是算一下，实际上40差不多了 int head[N],in[N],out[N],a[N],p[N],rev[N],root[N],Id[N]; int n,Ts,num,x,y,res,t,ans,k;//rev数组将dfs序对应会原来的编号 int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void add(int x,int y){ b[++t].to=y;b[t].nxt=head[x];head[x]=t; b[++t].to=x;b[t].nxt=head[y];head[y]=t; } void dfs(int k,int fa)//这里求的是dfs序，in[k]表示k这个点的dfs序 {//out[k]表示k这个点的子树中最大dfs序，也就是说，在in[k]~out[k]这个区间，都是以k为根的树 的节点的dfs序 in[k]=++num;//有点绕口 rev[num]=k; int i,to; for(i=head[k];i;i=b[i].nxt) { to=b[i].to; if(to==fa) continue; dfs(to,k); } out[k]=num; } void Modify(int l,int r,int &amp;x,int y,int pos,int i) { T[++res]=T[y];T[res].sum++;x=res; if(l==r) { Id[l]=i;//顺便记录一下这个点原先的编号 return; } int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) Modify(l,mid,T[x].l,T[y].l,pos,i); else Modify(mid+1,r,T[x].r,T[y].r,pos,i); } void query(int l,int r,int x,int y,int k) { if(l==r) { ans=Id[l];//这样就可以直接对应了 return; } int mid=(l+r)&gt;&gt;1; int sum=T[T[y].l].sum-T[T[x].l].sum; if(k&lt;=sum) query(l,mid,T[x].l,T[y].l,k); else query(mid+1,r,T[x].r,T[y].r,k-sum); } int main() { int i; n=read(); for(i=1;i&lt;=n;i++) p[i]=a[i]=read(); for(i=1;i&lt;n;i++) { x=read();y=read(); add(x,y); } dfs(1,0); sort(p+1,p+1+n); for(i=1;i&lt;=n;i++)//i表示的是dfs序 { a[rev[i]]=lower_bound(p+1,p+1+n,a[rev[i]])-p;//离散化 Modify(1,n,root[i],root[i-1],a[rev[i]],rev[i]); } Ts=read(); while(Ts--) { x=read();k=read(); query(1,n,root[in[x]-1],root[out[x]],k); printf(&quot;%d\\n&quot;,ans); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://hovnySiLenCe.github.io/tags/树链剖分/"},{"name":"主席树","slug":"主席树","permalink":"http://hovnySiLenCe.github.io/tags/主席树/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4051」[JSOI2007]字符加密 解题报告","slug":"Luogu_P4051-[JSOI2007]CharPasscode-Solution","date":"2019-03-27T13:52:59.000Z","updated":"2019-12-01T07:28:26.028Z","comments":true,"path":"2019/03/27/Luogu_P4051-[JSOI2007]CharPasscode-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P4051-[JSOI2007]CharPasscode-Solution/","excerpt":"","text":"题面思路：作为一个后缀数组的初学者，当然首先想到的是后缀数组 把$s$这个串首尾相接，扩展为原来的两倍，就能按后缀数组的方法处理 证明：神仙一眼就看出这是后缀的裸题，我这个蒟蒻想了半天想不出来 如果我们只对$s$串进行后缀排序，明显无法处理如下的情况，于是就拿了30分 $s=bnabn$ $bn$会在$bnabn$前面，而实际$bn$对应的应该是$bnbna$，比$bnabn$要大 那么应该这么处理这些缺少的串呢？ 我们可以尝试一下把原来的$s$变成两倍 $s=bnabn+bnabn$ 后缀$bnabnbnabn$在后缀$bnbnabn$前面，而实际上$bnabn$也同样在$bnbna$前面 这样扩展了一倍之后，也就是说题目中变化得到的$len(s)$个串都出现过，但是多出来的部分会不会影响结果呢？ 答案是不会 比如说： $s=abcd$ 扩展后$ \\to s=abcdabcd$ 对于原串的一种变化结果$bcda$ 包含在扩展后的$s$中，而$bcda$对应的后缀就是$bcdabcd$，后缀中多出的$bcd$对于$bcda$来说，它实际上是$bcda$的前缀，也就是说它对$bcda$的影响由$bcda$决定，这不就是没有影响吗 Code： #include&lt;bits/stdc++.h&gt; #define N 1000010 using namespace std; int n,m,x[N],y[N],c[N],sa[N],p,t; char s[N]; int main() { int i,k; scanf(&quot;%s&quot;,s); t=strlen(s);m=300;n=t&lt;&lt;1;//t是原来s的长度，n是扩展后长度，m初始值实际不用300 for(i=t;i&lt;n;i++) s[i]=s[i-t]; for(i=0;i&lt;n;i++) c[x[i]=s[i]]++; for(i=1;i&lt;m;i++) c[i]+=c[i-1]; for(i=0;i&lt;n;i++) sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1) { p=0; for(i=n-k;i&lt;n;i++) y[p++]=i; for(i=0;i&lt;n;i++) if(sa[i]&gt;=k) y[p++]=sa[i]-k; for(i=0;i&lt;m;i++) c[i]=0; for(i=0;i&lt;n;i++) c[x[y[i]]]++; for(i=1;i&lt;m;i++) c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--) sa[--c[x[y[i]]]]=y[i]; swap(x,y);p=1;x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=(y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k])?p-1:p++; if(p&gt;=n) break; m=p; }//都是后缀数组的模板 for(i=0;i&lt;n;i++) if(sa[i]&lt;t) printf(&quot;%c&quot;,s[(sa[i]+t-1)]);//也就是一个后缀开始的前一位 return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://hovnySiLenCe.github.io/tags/后缀数组/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4313」文理分科 解题报告","slug":"Luogu_P4313-DivideSubject-Solution","date":"2019-03-27T13:52:53.000Z","updated":"2019-12-01T07:28:24.402Z","comments":true,"path":"2019/03/27/Luogu_P4313-DivideSubject-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P4313-DivideSubject-Solution/","excerpt":"","text":"题面大意：$n \\times m$ 矩阵上的点，分成两部分，每个点分配后会有一个分数，上下左右以及中间 的五个点分到一起会有额外的分数，可以是0，求分配后最大的分数 解题思路网络流最小割 网络流的模板并不是很难，难在建边 而对于这道题，其实是网络流中的一种标准模型吧 一个点分到A或B两部分中，不同的点组合在一起有加分的情况 用网络流的最小割做 就应该先把问题转化一下： 最优的答案当然是所有分值都加在一起咯 但是，一个点不可能同时出现在两部分，所以导致了一些不可能的情况 现在我们的目标就是去掉尽量少的分数（边权），使一个点只能出现在一个部分 这就非常符合最小割了 一开始可以先考虑把每个点拆成两个点，一个和超级源点S，另一个和超级汇点T相连 在题目中的实际意义就是这个同学是学文还是学理，边权为 他/她 的满意度，记得在这两个点之间连上一条边权为INF的边，因为同一点是不能分割的！ 然后处理组合， 对于每个组合，我们新建一个结点，然后把它当做一个普通的节点处理 1和2是两个普通点，为了表示1和2的组合关系，就引入结点3当做 伪1结点 和 伪2结点，与 $1’$ 和 $2’$ 连边 $3’$ 也做同样的处理 于是就得到了下图 但是其实可以发现，这里拆点是没必要的，因为拆出的两点肯定不会被割去，且去掉中间这些容量为 $inf$ 的边，对题目并没有影响 因此可以不用拆点 建图之后跑一遍Dinic就好了 由于我们求的是最小割 所以结果应该是Ans——所有情况的满意度总和，减去Maxflow——至少删去多少边，才能满足一个同学只能选一科 Warning：新建结点并连边的时候，不要忘记与当前的点相连 Code： #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define M 200010 #define N 40010 #define Mn 110 using namespace std; int Cx[4]={1,0,0,-1};//上下左右 int Cy[4]={0,1,-1,0}; struct node{ int to,cap; int nxt; node(int a,int b):to(a),cap(b){ } node(){ } }b[M&lt;&lt;1]; int head[N],deep[N]; int n,m,S,T,t=1,Ans,Maxflow,Max;//Ans累计满意度之和 bool p[Mn][Mn]; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void add(int x,int y,int cap) { b[++t]=node(y,cap); b[t].nxt=head[x]; head[x]=t; b[++t]=node(x,0); b[t].nxt=head[y]; head[y]=t; return; } int Cag(int x,int y)//二维转化为一维 { return (x-1)*m+y; } bool BFS() { int i,cur; int to,cap; queue&lt;int&gt;p; memset(deep,0,sizeof(deep)); deep[S]=1;p.push(S); while(!p.empty()) { cur=p.front();p.pop(); for(i=head[cur];i;i=b[i].nxt) { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;!deep[to]) { deep[to]=deep[cur]+1; p.push(to); if(to==T) return 1; } } } return 0; } int Dinic(int k,int flow) { if(k==T) return flow; int i,to,cap,res,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].nxt) { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;deep[to]==deep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) deep[to]=0; b[i].cap-=res; b[i^1].cap+=res; rest-=res; } } return flow-rest; } int main() { int i,j,k; int to,cap,flow; int Tx,Ty; n=read();m=read(); Max=n*m;T=4*Max+1; for(i=1;i&lt;=n;i++) p[i][0]=p[i][m+1]=1; for(i=1;i&lt;=m;i++) p[0][i]=p[n+1][i]=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) { Ans+=cap=read(); add(S,Cag(i,j),cap);//选文科 add(Cag(i,j),Cag(i,j)+Max,INF);//自己的两个结点相连 } for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) { Ans+=cap=read(); add(Cag(i,j)+Max,T,cap);//选理科 } for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) { Ans+=cap=read(); to=Cag(i,j)+Max+Max; add(S,to,cap); add(to,Cag(i,j),INF);//别忘了自己 for(k=0;k&lt;4;k++)//组合 { Tx=i+Cx[k];Ty=j+Cy[k]; if(!p[Tx][Ty]) add(to,Cag(Tx,Ty),INF); } } for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) { Ans+=cap=read(); to=Cag(i,j)+Max+Max+Max; add(to,T,cap); add(Cag(i,j)+Max,to,INF); for(k=0;k&lt;4;k++) { Tx=i+Cx[k];Ty=j+Cy[k]; if(!p[Tx][Ty]) add(Cag(Tx,Ty)+Max,to,INF); } } while(BFS()) while((flow=Dinic(S,INF))) Maxflow+=flow; printf(&quot;%d&quot;,Ans-Maxflow);//最后还是挺容易的 return 0; } 推荐题目：Luogu P2057 [SHOI2007]善意的投票","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://hovnySiLenCe.github.io/tags/网络流/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P4987」回文项链 解题报告","slug":"Luogu_P4987-ReverseNecklace-Solution","date":"2019-03-27T13:51:11.000Z","updated":"2019-12-01T07:28:22.044Z","comments":true,"path":"2019/03/27/Luogu_P4987-ReverseNecklace-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P4987-ReverseNecklace-Solution/","excerpt":"","text":"题面求环中的长度为k（k为奇数）且回文中心不同的回文串个数 思路：刚学manacher算法，就送上一道模板题，此题注重对manacher算法的理解 Manacher，但是不用插入其他符号，因为k是奇数，中心一定在字符上不知道Manacher？ 洛谷日报上有讲，但是比较难懂，建议上B站更深入了解下$\\to$ 可以先把代码抄下来，然后一边看讲解一边理解代码含义，这样更能理解 反正我第一遍已经看蒙了 补充和纠正：关于前几篇题解，一些小细节纠正一下 文末的代码更加简洁易懂 1、这是一个环，要做Manacher就应该拆环为链，第一篇题解说：应该重复复制三次（扩展为原来的三倍），但是实际上两次（扩展为原来的两倍）就够了 2、p数组（p[i]）表示的是以i为中心的最长回文串的半径（包括i这个字符），原本的Manacher算法因为加入的额外的#号，而是p[i]表示的是就是原本最长回文串的长度+1，因此求Ans的时候应该用p[i]-1，但是现在我们不加#号了，p[i]表示的就是以i为中心的最长回文串的半径，此时长度就应该表示为p[i]*2-1，意思是半径*2-回文中心重复计算的字符 Code： #include&lt;bits/stdc++.h&gt; #define N 1000010//N&lt;&lt;1表示长度扩展为原来的两倍 using namespace std; int n,k,p[N&lt;&lt;1],ans,res; char s[N&lt;&lt;1]; void manacher()//标准的Manacher算法，就是没有加&#39;#&#39;号，而且起点为1 { s[0]=&#39;?&#39;; s[2*n+1]=&#39;!&#39;; int id=0,mx=0;//id表示目前最长回文串的中心，mx则是右边界 for(int i=1;i&lt;=2*n;i++) { if(i&lt;mx) p[i]=min(p[2*id-i],mx-i);//如果中心在mx范围内，用mx去更新p[i] else p[i]=1; while(s[i-p[i]]==s[i+p[i]])//然后暴力 p[i]++; if(mx&lt;i+p[i])//更新mx和id { id=i; mx=i+p[i]; } } return; } int main() { int i; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,s+1); for(i=1;i&lt;=n;i++)//复制 s[i+n]=s[i]; manacher();//跑一遍Manacher res=(k+1)&gt;&gt;1;//表示起始的中心i的位置，这个位置是第一个有可能长度为k的回文串的中心（串s[1-k]的中心） for(i=res;i&lt;=res+n-1;i++)//对于每一个点遍历一次，所以是res+n-1 if(p[i]*2-1&gt;=k)//真正的长度只要大于等于k就是可以的（大于k的可以把他砍成k啊~） ans++; printf(&quot;%d&quot;,ans); return 0; } 推荐题目：一道有趣的黄题 P1210 回文检测","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"Manacher","slug":"Manacher","permalink":"http://hovnySiLenCe.github.io/tags/Manacher/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3866」[TJOI2009]战争游戏 解题报告","slug":"Luogu_P3866-[TJOI2009]WarGame-Solution","date":"2019-03-27T13:50:41.000Z","updated":"2019-12-01T07:28:27.224Z","comments":true,"path":"2019/03/27/Luogu_P3866-[TJOI2009]WarGame-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P3866-[TJOI2009]WarGame-Solution/","excerpt":"","text":"题面好难表述啊~ 在n*m的矩阵上，有一些大兵（为0），一些空地（一个正整数），障碍物（-1），现在摧毁一些空地，使所有大兵不能走出矩阵去（代价为表示空地的整数），求最小代价 思路：网络流最小割“阻止”，“最小”，看到这样的字眼，肯定就要想到最小割啊 在互相能到达的点之间建边，容量为INF，因为——它不能炸…… 然后把每个点拆成入点和出点，每个兵所在的出点和源点S直接相连，在最外面的点的出点和汇点T直接相连 最后套模板，OK了 最重要的还是建边，能够理解题目的意思，想出对应的策略 Code： #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define M 5010 #define N 2010 #define Mn 31 using namespace std; int Cx[4]={1,0,0,-1};//预处理移动的方向 int Cy[4]={0,1,-1,0}; struct node{ int to,cap; int nxt; node(int a,int b):to(a),cap(b){ } node(){ } }b[M&lt;&lt;1]; int head[N],deep[N],a[Mn][Mn]; int n,m,S,T,Maxflow,Max,t=1; bool p[Mn][Mn]; int read() { int s=0,p=1; char c=getchar(); while(!isdigit(c)) { if(c==&#39;-&#39;) p=-1; c=getchar(); } while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s*p; } int Cag(int x,int y) { return (x-1)*m+y; } void add(int x,int y,int cap) { b[++t]=node(y,cap); b[t].nxt=head[x]; head[x]=t; b[++t]=node(x,0); b[t].nxt=head[y]; head[y]=t; return; } void Add(int x,int y) { int Tx,Ty; for(int i=0;i&lt;4;i++) { Tx=x+Cx[i];Ty=y+Cy[i]; if(p[Tx][Ty])//边框的用处 add(Cag(x,y)+Max,T,INF);//在矩阵外就和汇点T相连 else add(Cag(x,y)+Max,Cag(Tx,Ty),INF);//否则出点和入点相连 } return; } bool BFS() { int i,cur; int to,cap; queue&lt;int&gt;p; memset(deep,0,sizeof(deep)); p.push(S);deep[S]=1; while(!p.empty()) { cur=p.front();p.pop(); for(i=head[cur];i;i=b[i].nxt) { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;!deep[to]) { deep[to]=deep[cur]+1; p.push(to); if(to==T) return 1; } } } return 0; } int Dinic(int k,int flow) { if(k==T) return flow; int i,to,cap,res,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].nxt) { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;deep[to]==deep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) deep[to]=0; b[i].cap-=res; b[i^1].cap+=res; rest-=res; } } return flow-rest; } int main() { int i,j,flow; n=read();m=read(); Max=n*m;T=Max+Max+1;//汇点T for(i=1;i&lt;=n;i++)//裱个框，方便判断 p[i][0]=p[i][m+1]=1; for(i=1;i&lt;=m;i++) p[0][i]=p[n+1][i]=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) a[i][j]=read(); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) { if(a[i][j]==-1)//如果是障碍就不建边 continue; if(a[i][j]==0)//如果是大兵就与源点建边，注意，是出点！否则都要为zero了…… add(S,Cag(i,j)+Max,INF); else//如果是空地，那么在自己的入点和出点之间建边 add(Cag(i,j),Cag(i,j)+Max,a[i][j]);//注意，这里的容量是a[i][j]，就是要炸多少次 Add(i,j);//放个函数里看看能不能和四周相连 } while(BFS())//Dinic模板 while((flow=Dinic(S,INF))) Maxflow+=flow; printf(&quot;%d&quot;,Maxflow); return 0; } 推荐题目Luogu P2472 [SCOI2007]蜥蜴有点类似，但很不相同！","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://hovnySiLenCe.github.io/tags/网络流/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3866」SAC E#1 - 一道难题 Tree 解题报告","slug":"Luogu_P3931-SAC_E#1_-_ADifficultProblem_Tree-Solution","date":"2019-03-27T13:50:41.000Z","updated":"2019-12-01T07:28:26.405Z","comments":true,"path":"2019/03/27/Luogu_P3931-SAC_E#1_-_ADifficultProblem_Tree-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P3931-SAC_E#1_-_ADifficultProblem_Tree-Solution/","excerpt":"","text":"圆原题面我环顾四周，发现大佬们的写法都好高端！ 比较差劲的我，只能交上一份DFS的题解 思路：DFS（当然了，其他算法也行）要想切断叶子节点到根节点的连接 就是在叶子节点和根节点之间砍掉一条边 这明显就很符合DFS的性质，一条路一直走下去，遇到分枝就分开走 于是我们DFS每一条路径，然后求答案 复杂度为O(n) 但是——还没完！我们可以发现DFS有三种情况 1、该节点为叶子节点，此时只能删去连接它和父节点的边 2、该节点为枝节点，有父节点和子节点，需要选择性的删除 3、该节点为根节点，只有子节点，只能删去连接它和子节点的边 Code： #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f using namespace std; struct node{ int to,cost; int nxt; node(int a,int b):to(a),cost(b){ } node(){ } }b[200010]; int n,t,r; int head[100010]; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void add(int x,int y,int cost)//建边 { b[++t]=node(y,cost); b[t].nxt=head[x]; head[x]=t; b[++t]=node(x,cost); b[t].nxt=head[y]; head[y]=t; return; } int Get(int k,int in) { int i; int res=0; for(i=head[k];i;i=b[i].nxt) if(i!=(in^1))//成对变换原理，异或值相同但方向相反的边为一组，避免重复 res+=Get(b[i].to,i); if(!b[head[k]].nxt&amp;&amp;k!=r)//确定是叶子节点 res=b[in].cost; else res=min(res,b[in].cost);//否则两种方法选其一 return res; } int main() { int i; int x,y,cost; n=read();r=read(); t=1;//初始赋1，利于成对变换 for(i=1;i&lt;n;i++) { x=read();y=read();cost=read(); add(x,y,cost); } b[0].cost=INF;//对于根节点的双重保险，防止出什么岔子，比如结果为0 printf(&quot;%d&quot;,Get(r,0)); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://hovnySiLenCe.github.io/tags/网络流/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「USACO15FEB」Censoring (Silver) 审查(银) 解题报告","slug":"USACO15FEB-Censoring (Silver)-Solution","date":"2019-03-27T13:50:30.000Z","updated":"2019-12-01T07:28:07.763Z","comments":true,"path":"2019/03/27/USACO15FEB-Censoring (Silver)-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/USACO15FEB-Censoring (Silver)-Solution/","excerpt":"","text":"$\\mathtt{Update\\ 2019.11.08}$ 题面在字符串 $A$ 中，如果字符串 $B$ 是 $A$ 的子串，那么就删除在 $A$ 中第一个出现的 $B$，然后拼接在一起，一直重复上述步骤直到 $B$ 不再是 $A$ 的子串 |A|$\\le 10^6$ 解题思路KMP+栈 分析1、字符串匹配的问题，想到 $KMP$ 2、在匹配过程中，如果匹配成功了，就将子串 $B$ 删除，可以证明，对之前不会产生影响 3、删了再加入，类似栈的操作，因此用栈维护上述操作过程中的字串即可 过程1、$KMP$ 板子跑一遍 2、在 $KMP$ 过程中，把遍历到的 $i$（不是字符，而是下标）入栈，当匹配上 $B$ 时，就把匹配的部分出栈，然后 $j$ 从栈顶的 $i$ 所能匹配到的最大的位置开始（就是 f[i] 记录的值），继续做 $KMP$ 时间复杂度：$B$ 自身匹配一次 $+A$ 与 $B$ 匹配一次$+A$ 中最多每个字符进出栈一次，为 $O(|A|)$ Code#include&lt;bits/stdc++.h&gt; #define N 1000010 using namespace std; int la,lb,res; char a[N],b[N]; int p[N],f[N];//分别表示B串自身匹配的结果、A串与B串匹配的结果 int St[N],top; int main() { int i,j; scanf(&quot;%s&quot;,a+1); scanf(&quot;%s&quot;,b+1); la=strlen(a+1); lb=strlen(b+1); for(i=2,j=0;i&lt;=lb;i++) {//自身匹配 while(j&amp;&amp;b[i]!=b[j+1]) j=p[j]; if(b[i]==b[j+1]) j++; p[i]=j; } for(i=1,j=0;i&lt;=la;i++) {//A与B匹配 while(j&amp;&amp;a[i]!=b[j+1]) j=p[j]; if(a[i]==b[j+1]) j++; f[i]=j;//记录结果 St[++top]=i;//入栈 if(j==lb)//如果匹配成功，弹出，并更新j值 top-=lb,j=f[St[top]]; } for(i=1;i&lt;=top;i++)//大功率输出 printf(&quot;%c&quot;,a[St[i]]); return 0; } 再扔道题 Luogu P3121 [USACO15FEB]审查（黄金）Censoring (Gold)","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://hovnySiLenCe.github.io/tags/KMP/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「USACO08JAN」电话线Telephone Lines 解题报告","slug":"USACO08JAN-Telephone_Lines-Solution","date":"2019-03-27T13:50:25.000Z","updated":"2019-12-01T07:28:08.333Z","comments":true,"path":"2019/03/27/USACO08JAN-Telephone_Lines-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/USACO08JAN-Telephone_Lines-Solution/","excerpt":"","text":"题面大意：在加权无向图上求出一条从 $1$ 号结点到 $N$ 号结点的路径，使路径上第 $K + 1$ 大的边权尽量小。 思路：由于我们只能直接求最短路，不能记录过程中的具体的边——那样会特别麻烦 所以，我们就尝试着去想更优的办法 题目中所说，能够免去 $K$ 条边的费用，那么对于要建设的边中，肯定免去费用最大 $K $ 条边更优 我们关注的应该是第 $K+1$ 大边的边权，因为其他边权大于这条边边权的边都会被略去 这条边可以枚举吗？似乎不行，枚举的复杂度还要在最短路的基础上，乘上一个 $M$ ，不就TLE（Time Limit Enough）了吗…… 那么——对于这个边的边权，能不能二分呢？首先，二分需要满足单调性 题目中，这条第 $K+1$ 大的边边权越小，能够满足的情况越少，反之亦然 因此我们可以使用二分的方法来查找答案 怎么判断满足或不满足对于边权大于 $mid$ 的边，我们改变它的边权为1，否则为0，然后再跑最短路，这样得出来的结果应该是从 $1$ 号结点到 $N $ 号结点至少要有几条大于 $mid$ 的边，然后与 $K$ 比较，小于 $K$ 则满足，否则不满足 Code： #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define M 10010 #define N 1010 using namespace std; struct node{ int to,cost; int nxt; node(int a,int b):to(a),cost(b){ } node(){ } }b[M&lt;&lt;1]; int head[N],d[N],vis[N]; int n,m,res,t,ans=INF;//初值一样要为INF int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void add(int x,int y,int cost)//建边，正反一起 { b[++t]=node(y,cost); b[t].nxt=head[x]; head[x]=t; b[++t]=node(x,cost); b[t].nxt=head[y]; head[y]=t; return; } bool BFS(int k)//好吧，这里不算严格的最短路，因为边权变成了0和1，可以直接宽搜搞定，但是下面的程序， {//明明是一个真SPFA，假宽搜 int i,to,cur,cost; for(i=1;i&lt;=n;i++) { d[i]=INF; vis[i]=0; } queue&lt;int&gt;p; p.push(1); vis[1]=1; d[1]=0; while(!p.empty()) { cur=p.front();p.pop(); vis[cur]=0; for(i=head[cur];i;i=b[i].nxt) { to=b[i].to; cost=d[cur]+(b[i].cost&gt;k);//处理边权 if(cost&lt;d[to]) { d[to]=cost; if(!vis[to]) { vis[to]=1; p.push(to); } } } } if(d[n]&lt;=res)//判断 return 1; return 0; } int main() { int i; int x,y,cost; int l,r,mid; n=read();m=read();res=read(); l=r=0; for(i=1;i&lt;=m;i++) { x=read();y=read();cost=read(); add(x,y,cost);//建边，注意是双向的 r=max(r,cost);//r的上限，可以自己赋为1e6，这是题目中给的最大值 } while(l&lt;=r) { mid=(l+r)&gt;&gt;1; if(BFS(mid))//判断 { ans=mid; r=mid-1; } else l=mid+1; } if(ans==INF)//初值应该为INF，不能为0，因为有可能电信公司比较大方，免费之类的——给我多好 ans=-1; printf(&quot;%d&quot;,ans); return 0; } 另外提供一个比较high的评测在洛谷过了，这里不一定过哦！","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://hovnySiLenCe.github.io/tags/二分/"},{"name":"最短路","slug":"最短路","permalink":"http://hovnySiLenCe.github.io/tags/最短路/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「USACO4.4」追查坏牛奶Pollutant Control 解题报告","slug":"USACO4.4-Pollutant_Control-Solution","date":"2019-03-27T13:49:25.000Z","updated":"2019-12-01T07:28:06.382Z","comments":true,"path":"2019/03/27/USACO4.4-Pollutant_Control-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/USACO4.4-Pollutant_Control-Solution/","excerpt":"","text":"$update: 2019.08.30$ 题面求最小割，并且在最小割的情况下求出最少要删去几条边 思路：最小割 就是后一问不大好求 或许我们要在模板里改比较困难 那么我们就想办法在边上做学问 比如我们可不可以把边的容量全部加1呢？ 有人问：这样最小割不就是不一样了吗？ 但是细想一下可以发现：其实在加1的情况下，原来的最小割确实变了，但是增大了多少就等于最少要删去的边数 因为对于每条边，容量又多了一个1，在最小割的前提下，肯定是删去越少的边数的情况更优 举个栗子： 上述划去的内容都是有点瑕疵的 比如下图情况，即可将这种做法 $hack$ 也就是，把边的容量 $+1$ 之后，会对最小割产生影响 因此我们需要一种对最小割不产生影响，并且可以计算出最小割边数的修改方法 和上述的方法仍有一点相似，可以将边的容量变成一个 $m+1$ 进制数（$m$ 是边数） 十位为原来的容量，个位为 $1$，表示一条边的代价，这样可以一次性求出最小割和最小割的边数， 由于变成 $m+1$ 进制数后，就算边数再多，可不会对最小割产生影响，因为十位决定的是大前提，个位决定的是细节，也就是边数，不会对最小割产生影响 可以这么极端地想，就算每条边都走了，对最小割产生的影响也只能存在于个位，不会进一到十位 最后答案，最小割即为跑 $Dinic$ 得出的结果在 $m+1$ 进制下的十位，边数则为个位 Code： #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f #define ll long long #define M 1010 #define N 50 using namespace std; struct node{ int to,cap; int nxt; node(int a,int b):to(a),cap(b){ } node(){ } }b[M&lt;&lt;1]; int head[N],deep[N]; int A,n,m,S,T,t=1; ll Maxflow; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void add(int x,int y,int cap) { b[++t]=node(y,cap); b[t].nxt=head[x]; head[x]=t; b[++t]=node(x,0); b[t].nxt=head[y]; head[y]=t; return; } bool BFS() { int i,cur; int to,cap; queue&lt;int&gt;p; memset(deep,0,sizeof(deep)); deep[S]=1;p.push(S); while(!p.empty()) { cur=p.front();p.pop(); for(i=head[cur];i;i=b[i].nxt) { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;!deep[to]) { deep[to]=deep[cur]+1; p.push(to); if(to==T) return 1; } } } return 0; } ll Dinic(int k,ll flow) { if(k==T) return flow; int i,to,res; ll cap,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].nxt) { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;deep[to]==deep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) deep[to]=0; b[i].cap-=res; b[i^1].cap+=res; rest-=res; } } return flow-rest; } int main() { int i,x,y,cap; ll flow; n=read();m=read(); S=1;T=n;A=m+1; for(i=1;i&lt;=m;i++) { x=read();y=read();cap=read(); add(x,y,cap*A+1);//变成m+1进制数 } while(BFS()) while((flow=Dinic(S,INF))) Maxflow+=flow; printf(&quot;%lld %lld&quot;,Maxflow/A,Maxflow%A); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"最小割","slug":"最小割","permalink":"http://hovnySiLenCe.github.io/tags/最小割/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「UVA10810」Ultra-QuickSort 解题报告","slug":"UVA10810-Ultra-QuickSort-Solution","date":"2019-03-27T13:49:12.000Z","updated":"2019-12-01T07:28:05.236Z","comments":true,"path":"2019/03/27/UVA10810-Ultra-QuickSort-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/UVA10810-Ultra-QuickSort-Solution/","excerpt":"","text":"题面看不懂？！ 大概的意思就是：给出一个长度为n的序列，然后每次只能交换相邻的两个数，问最小需要几次使序列严格上升 不断读入n，直到n=0结束 思路：交换相邻的两个数，这不就类似冒泡排序吗？但是n&lt;500000 算了吧，我回去颓A+B 于是我们就发现用冒泡排序直接计算次数是行不通的 但我们要知道： 冒泡排序的交换次数就是序列的逆序对数！！！ 所以——就简单了吧~ 如何求逆序对？较easy版的逆序对 1、归并排序 思想是分治法 不断划分为两小段 然后依次由小序列合并为大序列，同时求出逆序数 2、树状数组 因为树状数组的修改查询是log级的所以可以使用（前缀和的方法），没学的建议先去学习一下，不是很难 Code： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; struct node{ int x,i; }a[500010]; int n; int b[500010]; int f[500010]; ll ans; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void update(int x)//修改 { for(;x&lt;=n;x+=x&amp;(-x)) f[x]++; return; } ll sum(int x)//求前缀和 { ll res=0; for(;x;x-=x&amp;(-x)) res+=f[x]; return res; } bool cmp(node a,node b) { return a.x&gt;b.x; } int main() { int i,j; n=read(); while(n) { ans=0; memset(f,0,sizeof(f)); for(i=1;i&lt;=n;i++) { a[i].x=read(); a[i].i=i; } sort(a+1,a+n+1,cmp); for(i=1;i&lt;=n;i++)//先hash一下,按数值给其标记，方便后面求逆序对 b[a[i].i]=i; for(i=1;i&lt;=n;i++) { update(b[i]);//一步一做 ans+=sum(b[i]-1); } printf(&quot;%lld\\n&quot;,ans); n=read(); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://hovnySiLenCe.github.io/tags/树状数组/"},{"name":"归并排序","slug":"归并排序","permalink":"http://hovnySiLenCe.github.io/tags/归并排序/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3395」路障 解题报告","slug":"Luogu_P3395-Barricades-Solution","date":"2019-03-27T13:48:15.000Z","updated":"2019-12-01T07:28:28.885Z","comments":true,"path":"2019/03/27/Luogu_P3395-Barricades-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P3395-Barricades-Solution/","excerpt":"","text":"题面这D1T1给的很有面子！ 我居然做的来！ 从左上角走到右上角 然后n&lt;=1000 所以果断放弃DFS，选择BFS 思路还是一样的BFS 证明：走到一个点的时间越早越好（因为时间越晚能走到的点越少，路障多了） 所以用BFS，走过的点不用再次走，用 vis数组记录已经是否遍历过 然后为了防止跑出棋盘去（B君看到了棋盘外美铝？！） 我们就给棋盘加一个 ‘1’的边框，这样就不会出去 然后还要记录一个时间t、x、y，可以用一个结构体 构造用 struct node{ ​ int x,y,t; ​ node(int a,int b,int c):x(a),y(b),t(c) { } ​ node(){} }; node(x,y,t)//直接构造 但是本菜还是比较喜欢用两个queue 一个存pair(x,t)，一个存y 贴上： #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f using namespace std; int Cx[4]={1,0,0,-1};//四个方向，八个方向也一样 int Cy[4]={0,1,-1,0};//在下有强迫症，所以用两个数组 int n,T; int x,y; int b[1010][1010]; bool vis[1010][1010]; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } bool BFS() { int i,t; int Tx,Ty; queue&lt;pair&lt;int,int&gt; &gt;px; queue&lt;int&gt;py; while(!py.empty()) px.pop(),py.pop(); px.push(make_pair(1,1)); py.push(1); vis[1][1]=1; while(!px.empty()) { x=px.front().first; t=px.front().second;px.pop(); y=py.front();py.pop(); if(x==n&amp;&amp;y==n)//有了这句就不用特判n=1的情况了 return 1; for(i=0;i&lt;4;i++) { Tx=x+Cx[i]; Ty=y+Cy[i]; if(!vis[Tx][Ty]&amp;&amp;t&lt;=b[Tx][Ty]) { vis[Tx][Ty]=1; px.push(make_pair(Tx,t+1)); py.push(Ty); } } } return 0; } int main() { int i; T=read(); while(T--) { n=read(); memset(vis,0,sizeof(vis)); memset(b,INF,sizeof(b));//一开始赋无穷大比较方便 for(i=1;i&lt;=n;i++)//裱框 vis[i][0]=vis[0][i]=vis[n+1][i]=vis[i][n+1]=1; for(i=1;i&lt;=2*n-2;i++) { x=read();y=read(); b[x][y]=i; } if(BFS())//此处纪念ydk大佬把&quot;Yes&quot;打成&quot;YES&quot;，本蒟瑟瑟发抖 printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"http://hovnySiLenCe.github.io/tags/BFS/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2508」[HAOI2008]圆上的整点 解题报告","slug":"Luogu_P2508-[HAOI2008]CirclePoint-Solution","date":"2019-03-27T13:48:12.000Z","updated":"2019-12-01T07:28:33.116Z","comments":true,"path":"2019/03/27/Luogu_P2508-[HAOI2008]CirclePoint-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P2508-[HAOI2008]CirclePoint-Solution/","excerpt":"","text":"题面给定圆的半径，求圆上整点数 这是一道很 $Nice$ 的数学题！超爱！好吧，由于这道题，我去 $Study$ 了一下复数 $(complex\\ number)$ 复杂的数 有兴趣的戳这里！！！$\\large \\to$ 解题思路高斯素数的原理，将整数分解质因数后，再把每个质因数分解成高斯素数，对于质数 4n+1 ，它可以有效的分解成高斯素数，而质数 4n+3 不能，因为3无法分解为高斯素数，所以当一个数有奇数个3因子时，这个圆上没有整点，而3的个数为偶数时，由于能分成两组配对，所以有整点，但3对Ans的影响为0，因为 $x\\times 1=x$，因此只要不变就行了，当由于 $2$ 的高斯素数表示为 1-i $\\times$ 1+i，所以2的个数对Ans无影响 对于25如下： \\large 25=5 \\times 5 \\large 25=(2-i)(2+i)(2-i)(2+i)所以： Left Right $\\large 1$ $\\large 1$ $\\large 2-i$ $\\large 2+i$ $\\large 2-i$ $\\large 2+i$ $\\large =3-4i$ $\\large =3+4i$ 这是一种情况$\\large (3,-4)$ Left Right $\\large 2-i$ $\\large 2-i$ $\\large 2+i$ $\\large 2+i$ $\\large =5$ $\\large =5$ 这是一种情况$\\large (5,0)$ Left Right $\\large 2+i$ $\\large 2+i$ $\\large 2+i$ $\\large 2+i$ $\\large =3+4i$ $\\large =3-4i$ 这是一种情况$\\large (3,-4)$ 而对于上述 $\\large \\times$ $\\large 3-4i$ $\\large 5$ $\\large 3+4i$ $\\large -1$ $\\large -1+4i$ $-5$ $\\large -3-4i$ $\\large i$ $\\large 4+3i$ $\\large 5i$ $\\large -4+3i$ $\\large -i$ $\\large -4-3i$ $\\large -5i$ $\\large 4-3i$ 所以一共有点对12对 那么高斯素数怎么表示点呢？它只要一个数，就可以表示点的坐标，RT： Code#include&lt;bits/stdc++.h&gt; #define N 10000010 #define ll long long using namespace std; ll n,m,res,ans=4; ll a[N],t,T; ll p[N]; ll s[N]; bool b[N]; int main() { ll i,j; scanf(&quot;%lld&quot;,&amp;n); m=n; for(i=2;i*i&lt;=m;i++) { if(!b[i]) { a[++T]=i; if(m%i==0) { p[++t]=i; while(m%i==0) { m/=i; s[t]++; } } } for(j=1;j&lt;=T;j++) { if(a[j]*i*i*a[j]&gt;m) continue; b[a[j]*i]=1; if(i%a[j]==0) continue; } } if(m&gt;1) { p[++t]=m; s[t]=1; } for(i=1;i&lt;=t;i++) if((p[i]-1)%4==0) ans*=(2*s[i]+1); printf(&quot;%lld&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://hovnySiLenCe.github.io/tags/数论/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P3183」[HAOI2016]食物链 解题报告","slug":"Luogu_P3183-[HAOI2016]FoodLink-Solution","date":"2019-03-27T13:48:12.000Z","updated":"2019-12-01T07:28:30.561Z","comments":true,"path":"2019/03/27/Luogu_P3183-[HAOI2016]FoodLink-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P3183-[HAOI2016]FoodLink-Solution/","excerpt":"","text":"$\\mathtt{Update\\ 2019.11.08}$ 题面求有向图的路径数 解题思路直接在有向图上 $DP$ 即可 要注意的是单独一个点不算一条链 存图后把入度为 $0$ 且出度不为 $0$（即非单独）的点入队，类似拓扑地跑一个 $DP$ 每次对一个出点 $to$ 更新之的答案 f[to]+=f[cur] 即利用加法原理，到 $to$ 点的方案为向它连边点的方案和 当该出点 $to$ 入度为 $0$ 时，分情况视之 倘若该出点出度为0时，累加答案 ans+=f[to] 否则就入队用来更新其他点 Code#include&lt;bits/stdc++.h&gt; #define rgt register #define rint rgt int #define N 100003 using namespace std; struct node{ int to,nxt; }b[N&lt;&lt;1]; int n,t,T,head[N]; int f[N],d[N],ans; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } inline void add(int x,int y) { b[++t].to=y,b[t].nxt=head[x],head[x]=t; } inline void solve() { rint i,cur,to;queue&lt;int&gt;p; for(i=1;i&lt;=n;i++)//初始化入度为0的点（不包括单独的点） if(!d[i]&amp;&amp;head[i])//分别判断入度为0和是否是单独的点 f[i]=1, p.push(i);//初始化路径数，否则全都是0 while(!p.empty()) { cur=p.front(),p.pop(); for(i=head[cur];i;i=b[i].nxt) { to=b[i].to,d[to]--,f[to]+=f[cur]; if(d[to]==0) { if(!head[to]) ans+=f[to]; else p.push(to);//只有入度为0且出度不为0时才入队 } } } } int main() { rint x,y;n=read(),T=read(); while(T--) x=read(),add(x,read()),d[y]++;//入度 solve(),printf(&quot;%d&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"拓扑","slug":"拓扑","permalink":"http://hovnySiLenCe.github.io/tags/拓扑/"},{"name":"BFS","slug":"BFS","permalink":"http://hovnySiLenCe.github.io/tags/BFS/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2278」[HNOI2003]操作系统 解题报告","slug":"Luogu_P2278-[HNOI2003]TheOperatingSystem-Solution","date":"2019-03-27T13:48:11.000Z","updated":"2019-12-01T07:28:34.812Z","comments":true,"path":"2019/03/27/Luogu_P2278-[HNOI2003]TheOperatingSystem-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P2278-[HNOI2003]TheOperatingSystem-Solution/","excerpt":"","text":"题面一道模拟题，模拟CPU的处理过程？！省选模拟题 思路：模拟退火大法+优先队列乱搞要注意的点1、空闲时，CPU要处理进程 2、当队列中没有进程时，要先进行判断，然后访问 3、当优先级高的进程替换掉原进程时，原进程已经处理过的时间要减去 4、结束进程时要更新后面进程的时间 既然是模拟题，那就不讲具体了h^ovny：我懒 Code： #include&lt;bits/stdc++.h&gt; using namespace std; struct node{ int i,S,l,p; node(int a,int b,int c,int d):i(a),S(b),l(c),p(d){ } node(){ } bool operator&lt;(const node X) const{//重载 if(p!=X.p) return p&lt;X.p; return S&gt;X.S; } }Now,cur;//Now表示当前处理的进程 int i,S,l,p; priority_queue&lt;node&gt;P; int main() { int i; scanf(&quot;%d%d%d%d&quot;,&amp;i,&amp;S,&amp;l,&amp;p);//预先读入一组 Now=node(i,S,l,p); while(~scanf(&quot;%d%d%d%d&quot;,&amp;i,&amp;S,&amp;l,&amp;p)) { while(Now.S+Now.l&lt;=S&amp;&amp;!P.empty())//中间空闲时间先处理掉 { printf(&quot;%d %d\\n&quot;,Now.i,Now.S+Now.l); cur=P.top();P.pop(); if(cur.S&lt;Now.S+Now.l)//计算影响 cur.l+=Now.S+Now.l-cur.S; Now=cur; } if(Now.S+Now.l&lt;=S)//如果队列空了，Now就没有输出 { printf(&quot;%d %d\\n&quot;,Now.i,Now.S+Now.l); Now=node(i,S,l,p); continue; } if(p&gt;Now.p)//更高级的任务 { Now.l=Now.l+Now.S-S; P.push(Now); Now=node(i,S,l,p); continue; } P.push(node(i,S,l,p)); } printf(&quot;%d %d\\n&quot;,Now.i,Now.S+Now.l);//队列中还有进程，但Now无法被更新 while(!P.empty())//弹出队列中的进程 { cur=P.top();P.pop(); if(cur.S&lt;Now.S+Now.l)//前面进程对当前的影响 cur.l+=Now.l+Now.S-cur.S; printf(&quot;%d %d\\n&quot;,cur.i,cur.S+cur.l); Now=cur; } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://hovnySiLenCe.github.io/tags/模拟/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2201」数列编辑器 解题报告","slug":"Luogu_P2201-TheArrayEditor-Solution","date":"2019-03-27T13:48:10.000Z","updated":"2019-12-01T07:28:35.644Z","comments":true,"path":"2019/03/27/Luogu_P2201-TheArrayEditor-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P2201-TheArrayEditor-Solution/","excerpt":"","text":"数列编辑器思路：怎么说链表也是可以的吧，虽然比较繁琐 然后涉及到了前缀和和一些优化手段（应该可以说是记忆化吧）？ 用p记录光标的位置 虽然这道题的数据范围挺大的$(1~1,000,000)$ 但是题目中说，k一定在p之前 所以实际上只有p前面的序列是有效的 于是我们就可以写一个半在线半离线的算法 用链表模拟数列 当然了，不用按照顺序，我们只用把数字存一下，然后顺序什么的一切靠链表解决 用 f数组 存i点（这里的i不是数列中的顺序，而是实际读入的顺序，下同，具体见代码）的最大前缀和，这样就可以直接查询 用 s数组 存i点的前缀和，方便更新f数组 然后用 ord数组 记录一下每个数在数列中的编号（不是实际的编号，有点类似hash的样子） 每接受一个操作就做一次更新 代码如下： #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f using namespace std; struct node{ int f,t;//f表示前驱，t表示后继（由于本菜鸟不喜欢front和next……请谅解~） int s; }b[1000010]; int T,t,p,n; int s[1000010]; int f[1000010]; int ord[1000010]; int read()//有负数，快读不要忘记符号的问题 { int s=0,p=1; char c=getchar(); while(!isdigit(c)) { if(c==&#39;-&#39;) p=-1; c=getchar(); } while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s*p; } int main() { char c; T=read(); f[0]=-INF;//因为有负数嘛，所以一开始前缀和的最大值应该是一个极小数 while(T--) { c=getchar(); while(c!=&#39;I&#39;&amp;&amp;c!=&#39;D&#39;&amp;&amp;c!=&#39;L&#39;&amp;&amp;c!=&#39;R&#39;&amp;&amp;c!=&#39;Q&#39;) c=getchar();//getchar()比较快（优化后还有更快的），写c==&#39;\\n&#39;||c==&#39;\\r&#39;||c==&#39; &#39;，关系也不大 if(c==&#39;I&#39;) { b[++t].s=read(); b[t].f=p; b[b[p].t].f=t; b[t].t=b[p].t; b[p].t=t; s[t]=s[p]+b[t].s;//插入节点 f[t]=max(f[p],s[t]);//更新当前的前缀和最大值 p=t;//更新光标位置 ord[++n]=p;//加入有价值的数列，并hash一下编号 } if(c==&#39;D&#39;) { b[b[p].t].f=b[p].f; b[b[p].f].t=b[p].t;//删除节点 p=b[p].f; n--; } if(c==&#39;L&#39;) { p=b[p].f; n--; } if(c==&#39;R&#39;) { s[b[p].t]=s[p]+b[b[p].t].s; f[b[p].t]=max(f[p],s[b[p].t]); p=b[p].t; ord[++n]=p; } if(c==&#39;Q&#39;) printf(&quot;%d\\n&quot;,f[ord[read()]]);//这里可以好好理解一下 }//其实这里的五个操作可以合并起来写，放在函数里，然后可以调用 //比如说在&#39;I&#39;的操作里，可以看成是插入一个节点，然后在右移光标一位 这两步 //比较方便（其实也没方便多少） return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://hovnySiLenCe.github.io/tags/模拟/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P2015」二叉苹果树 解题报告","slug":"Luogu_P2015-BinaryAppleTree-Solution","date":"2019-03-27T13:48:09.000Z","updated":"2019-12-01T07:28:36.070Z","comments":true,"path":"2019/03/27/Luogu_P2015-BinaryAppleTree-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P2015-BinaryAppleTree-Solution/","excerpt":"","text":"题面一个二叉树，边数为n $(2&lt; n\\le 100)​$，每条边有一个权值，求剪枝后剩下 $p(1&lt; p&lt; n)​$ 条边，使 $p$ 条边的权值和最大 还看不懂？…… 2 5 input:5 2 output:21 \\ / 1 3 1 3 4 1 4 10 \\ / 2 3 20 1 3 5 20 能理解了吧！ 解题思路树形DP 很基础的一道树形DP 对于每个点，用f[k][i]记录在以k为根的子树中，取i条枝的最大值 Warning1、要注意叶子节点的判断 2、有可能只取一侧的子树 Code： #include&lt;bits/stdc++.h&gt; #define N 110 using namespace std; int b[N][5],s[N]; int n,p; int a[N][N],f[N][N]; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } void DFS(int k,int fa) { if(s[k]==1)//叶子节点直接返回 return; int i,j; int l,r,value; l=r=0; for(i=1;i&lt;=s[k];i++)//把l儿子和r儿子处理出来，其实不用严格区分l和r，因为效果是一样的 if(b[k][i]!=fa) { if(!l) l=b[k][i]; else r=b[k][i]; } DFS(l,k);DFS(r,k); f[k][1]=max(a[k][l],a[k][r]);// for(i=0;i&lt;=p-2;i++)//由于默认要选左枝和右枝，所以i要-2 { f[k][i+2]=max(f[l][i+1]+a[k][l],f[r][i+1]+a[k][r]);//可能直选一边 for(j=0;j&lt;=i;j++)//分配左子树多少，右子树去多少枝，不用判断是否能够取满，因为取满的总是最优的 {//不会影响 value=f[l][j]+a[k][l]+f[r][i-j]+a[k][r]; f[k][i+2]=max(f[k][i+2],value); } } return; } int main() { int i,x,y; n=read();p=read(); for(i=1;i&lt;n;i++) { x=read(),y=read(),a[x][y]=read();//矩阵存边权 b[x][++s[x]]=y;b[y][++s[y]]=x;//存边，由于边数不多，直接用邻接表存，不用链式前向星 } DFS(1,0);//以1为根遍历数 printf(&quot;%d&quot;,f[1][p]);//输出最后结果 return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://hovnySiLenCe.github.io/tags/树形DP/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P1435」回文字串 解题报告","slug":"Luogu_P1435-ReverseChar-Solution","date":"2019-03-27T13:48:07.000Z","updated":"2019-12-01T07:28:37.420Z","comments":true,"path":"2019/03/27/Luogu_P1435-ReverseChar-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P1435-ReverseChar-Solution/","excerpt":"","text":"题面主要大衣大意： 给定一个字符串，求至少加入多少个字符才能使字符串变成回文字符串 下面就是我一本正经的胡说八道题解 思路：很显然，这应该是一道典型的最长公共子序列的题目 因此，主要思想就是DP 方程式也挺好推的 于是我们就来讲一下为什么这题能用最长公共子序列（LCS）求解 证明：求的是什么？想要使这个字符串加入最少的字符变成一个回文串，那么肯定就是要是字符串中不能回文的部分回文 说起来比较难理解，比如：Ab3bd最少添的字符就是A对应的一个A，最后d对应的一个d 我们可以发现，最少要添的字符就是不能匹配的字符数=原字符串长度len-最长回文串的长度 这就变成了求最长回文串的题目 怎么求？又经验的人肯定就会用最长公共子序列去解，但是一些人可能要问为什么，那么我们这里就来证明一下 由于回文串是回文的（废话)，也就是说，把原来的字符串反转一遍，最长回文串的长度还是不变的 于是我们就变成了求两串的公共子序列的长度——其实思想就是回文串正着和反着的效果是一样的，也就是抓住这个特性，去求公共系序列的长度 转移方程（最好自己去推一下）： if(a[i]==b[j])//目标状态是f[len][len] f[i][j]=f[i-1][j-1]+1;//表示i，j两位置相等，那么就由i-1，j-1的状态（最优解）+1得到 else f[i][j]=max(f[i-1][j],f[i][j-1]);//否则去掉i或j，转移最优解 Code： #include&lt;bits/stdc++.h&gt; #define N 1010 using namespace std; int len; char a[N],b[N]; int f[N][N]; int main() { int i,j; scanf(&quot;%s&quot;,a+1); len=strlen(a+1); for(i=1;i&lt;=len;i++) b[i]=a[len-i+1];//反转 for(i=1;i&lt;=len;i++) for(j=1;j&lt;=len;j++) if(a[i]==b[j]) f[i][j]=f[i-1][j-1]+1; else f[i][j]=max(f[i-1][j],f[i][j-1]); printf(&quot;%d&quot;,len-f[len][len]);//长度减去最长回文串长度 return 0; } 拓展知识：最长上升子序列（LIS） 推荐题目（进阶，就是比较难的意思）：【模板】最长公共子序列","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"Manacher","slug":"Manacher","permalink":"http://hovnySiLenCe.github.io/tags/Manacher/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「Luogu P1210」回文检测 解题报告","slug":"Luogu_P1210-ReverseCheck-Solution","date":"2019-03-27T13:48:06.000Z","updated":"2019-12-01T07:28:37.860Z","comments":true,"path":"2019/03/27/Luogu_P1210-ReverseCheck-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/Luogu_P1210-ReverseCheck-Solution/","excerpt":"","text":"题面这是一道诡异的黄题 居然让你求一串吧啦吧啦的东西中 字母（大小写）最长的回文串的长度，还要输出完整的串 吐血 思路：保持淡定，我们啥都不会，就会Manacher，那就用Manacher大法！ 1、把字符串处理成只有字母（去皮） 2、把字符串中插入#号（掺假） 3、Manacher跑一跑最长回文串长度（市场检查） 4、求出最长长度后再重新代入原来的字符串（打回原形！妖孽！） 然后，就完了~ 就是去皮的时候，顺便记录一下字符的位置，这样重新代入时就比较方便 并且由于字符串有很多行，读入时就要用getchar()，直到EOF为止 似乎Noip2018普及T1有人因为这个WA？ Code： #include&lt;bits/stdc++.h&gt; #define M 20010 using namespace std; struct node{ char c; int id; }a[M&lt;&lt;1]; char st[M],s[M&lt;&lt;1]; int l1,l2,len,ans,res; int p[M&lt;&lt;1]; bool check(char c) { return (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;); } void init() { int i; for(i=0;i&lt;l1;i++) if(check(st[i])) { a[l2].c=(st[i]&gt;=&#39;a&#39;&amp;&amp;st[i]&lt;=&#39;z&#39;)? st[i]:st[i]-&#39;A&#39;+&#39;a&#39;; a[l2++].id=i;//记录编号（位置） } s[0]=&#39;!&#39;; s[1]=&#39;#&#39;; for(i=0;i&lt;l2;i++) { s[i*2+2]=a[i].c; s[i*2+3]=&#39;#&#39;; } len=l2*2+2; s[len]=&#39;?&#39;; return; } void manacher()//大法不解释 { int id=0,mx=0; for(int i=0;i&lt;len;i++) { if(i&lt;mx) p[i]=min(p[id*2-i],mx-i); else p[i]=1; while(s[i-p[i]]==s[i+p[i]]) p[i]++; if(i+p[i]&gt;mx) { id=i; mx=i+p[i]; } } return; } void Print(int l,int r) { if(l&amp;1)//由扩展后的s数组变回a数组 l=(l-3)/2; else l=(l-2)/2; if(r&amp;1) r=(r-3)/2; else r=(r-2)/2; for(int k=a[l].id;k&lt;=a[r].id;k++) printf(&quot;%c&quot;,st[k]); return; } int main() { int i; char c=getchar();//读入 while(c!=EOF) { st[l1++]=c; c=getchar(); } init();//初始化 manacher();//大法 for(i=0;i&lt;len;i++)//求最长 ans=max(ans,p[i]); for(i=0;i&lt;len;i++)//求第一次出现的位置 if(p[i]==ans) break; ans--; printf(&quot;%d\\n&quot;,ans); Print(i-ans+1,i+ans-1);//重新代入 return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"Manacher","slug":"Manacher","permalink":"http://hovnySiLenCe.github.io/tags/Manacher/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF86D」Powerful array 解题报告","slug":"CF86D-Powerful_array-Solution","date":"2019-03-27T13:48:05.000Z","updated":"2019-12-01T07:28:38.822Z","comments":true,"path":"2019/03/27/CF86D-Powerful_array-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/CF86D-Powerful_array-Solution/","excerpt":"","text":"题面给出一个$n$个数组成的数列$a$，有$t$次询问，每次询问为一个$[l,r]$的区间，求区间内每种数字出现次数的平方×数字的值 的和 思路：直接上莫队咯 然后就T了没学过莫队？！我也没办法 这道题的数据范围在$2e5$的级别，有人会问莫队肯定要炸啊 捏~ 时限5000ms，那就可以乱搞了但是！还是要加一些优化 如何优化？1.对于算法本身的优化 由于莫队可以说是一个块状暴力的算法，就是把区间划分为$\\sqrt n$块然后在块内暴力（到头还是暴力） 我们可以把要查询的区间当做点表示在平面直角坐标系上，RT： 就像这样把询问放在平面直角坐标系上，$\\large x$轴为询问该区间的顺序，$\\large y$轴表示该区间的右端点，如果我们忽略区间的$L$值的影响，不难看出，虽然我们已经把区间划分在一个块里了，但是还是有很多冗余的操作，如果要是这些冗余的操作少一点就好了，这当然可以啦！ 我们可以让块内的区间按$\\large R$ 递增，这样能省很多时间，但是在区间过渡的时候，我们还是会做很多多余的操作，因为区间都是递增的，这样改变块的时候就可能有一个很大的落差，就掉了下去，可以自己想象一下 为了避免上述的现象，我们可以让区间像一个波浪一样，这样就很高效了，这样的划分方式叫做奇偶划分应该是这么叫的吧，还有一个是奇偶性剪枝 inline bool cmp(node a,node b){//代码是关键，讲了啥不重要(手动划线) return (pos[a.l]==pos[b.l])?(pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r : a.l&lt;b.l; }//千万不要写if，会T！ 接着就是块的大小，同样影响速度，一般普通的块的大小应该是$\\large \\sqrt n$，但是，根据某奆佬研究，大小为$\\large n^{0.54}$时更快，Orz 2.对于程序本身优化，说人话就是卡卡常 比如： 加点register 非递归函数前加个inline 不用快读用fread 还有！乘法变加法…… 然后就把最大时间卡到了622ms 啊哈哈哈哈哈 Code： #include&lt;bits/stdc++.h&gt; #define getchar() *(p++)//在快读基础上改一点就行了 #define Re register//卡常必备 #define ll long long #define M 1000010 #define N 200010 using namespace std; struct node{ int l,r,i; }b[N];//sum是数的多少，pos表示在哪块 int a[N],pos[N],n,m,sum[M],l,r,block; ll Ans[N],ans; char bf[1&lt;&lt;25],*p; int read(){ Re int s=0; Re char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } inline bool cmp(node a,node b){//奇偶划分 return (pos[a.l]==pos[b.l])?(pos[a.l]&amp;1)?a.r&lt;b.r:a.r&gt;b.r : a.l&lt;b.l; }//注意，这里不要写if语句，会T inline void Add(Re ll x) { sum[x]++;//有些人写在前面，那样的话就应该是+1 ans+=(sum[x]+sum[x]-1)*x;//就是由原来的乘变成了加，手算一小部分也没有关系啦 } inline void Del(Re ll x) { ans-=(sum[x]+sum[x]-1)*x;//这里和上面也是一样的 sum[x]--;//为什么我感觉上面-1会更慢呢~ } int main() { Re int i; bf[fread(bf,1,1&lt;&lt;25,stdin)]=&#39;\\0&#39;;p=bf;//fread大法 n=read();m=read();block=pow(n,0.54);//神奇的块的大小 for(i=1;i&lt;=n;i++) a[i]=read(),pos[i]=i/block; for(i=1;i&lt;=m;i++) b[i].l=read(),b[i].r=read(),b[i].i=i; sort(b+1,b+1+m,cmp);l=1; for(i=1;i&lt;=m;i++)//然后上莫队 { while(r&lt;b[i].r) Add(a[++r]); while(r&gt;b[i].r) Del(a[r--]); while(l&lt;b[i].l) Del(a[l++]); while(l&gt;b[i].l) Add(a[--l]); Ans[b[i].i]=ans; } for(i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,Ans[i]); return 0; } 再说一遍最后注意，sort的时候，如果数组本来就有序了，sort会很慢，所以千万不要在里面加if了，容易T","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://hovnySiLenCe.github.io/tags/莫队/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF656B」Scrambled 解题报告","slug":"CF656B-Scrambled-Solution","date":"2019-03-27T13:48:01.000Z","updated":"2019-12-01T07:28:39.692Z","comments":true,"path":"2019/03/27/CF656B-Scrambled-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/CF656B-Scrambled-Solution/","excerpt":"","text":"咳咳~这……不是一道恶意评分题？ 其实这也是一篇不正儿八经的题解这不是一篇科普文吗？！ 好吧，首先数据都很小，立马想到暴力 那么，怎么暴力呢？/摸下巴 先看题目，我们可以发现，题目对精度的要求很小——也就是$10^{-4}$ 所以，我们可以猥琐鱼尾 为所欲为 用各种神奇的方法求解 作为一名低学历的OIer，我想引用初中数学八上？八下？的内容——用频数估计频率 还记得那个抛硬币的实验吗？ 实践出真知可是小平爷爷说的！ 秉承着优良的传统，我们就来 枚举吧！枚举从当前往后1,000,000（别数了，十万，一百万~）天包括当前天,所以循环写（其实问题也不大） i = 0 to Max-1 我话不多，上代码 #include&lt;bits/stdc++.h&gt; #define Max 1000000 using namespace std; int n; int a[20]; int b[20]; int ans; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } int main() { int i,j; n=read(); for(i=1;i&lt;=n;i++) a[i]=read(); for(i=1;i&lt;=n;i++) b[i]=read(); for(j=0;j&lt;Max;j++)//实践出真知！ for(i=1;i&lt;=n;i++) if(j%a[i]==b[i]) { ans++; break; } printf(&quot;%lf&quot;,ans/1000000.0);//就这样~~水了~~过去？！ return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"http://hovnySiLenCe.github.io/tags/暴力/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF1102F」Elongated Matrix 解题报告","slug":"CF1102F-Elongated_Matrix-Solution","date":"2019-03-27T13:48:00.000Z","updated":"2019-12-01T07:28:41.502Z","comments":true,"path":"2019/03/27/CF1102F-Elongated_Matrix-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/CF1102F-Elongated_Matrix-Solution/","excerpt":"","text":"题面给出$n*m$个矩阵，从第一列开始，一列一列访问元素，依次记元素为$S1,S_2,…S{nm}$，则$k$的价值为相邻两个元素差的绝对值的最小值，即$k=min{|S1 - S_2|,|S_2 - S_3|,…,|S{nm-1} - S_{nm}|}$ 现在可以改变任意行的顺序，求$k$的最大值 解题思路正解应该是状压DP 但是以下讲的是另一种玄学做法——搜索 当然啦~，直接爆搜是不行的，在一切之前，我们先研究一下题目 然后做一些预处理 比如： 1、改变的是行的顺序，因此任意两行之间的最小差值可以预先求出来 9 9 10 8 $\\large \\color{red}5$ $\\large \\color{red}3$ $\\large \\color{red}4$ $\\large \\color{red}3$ 图中两行的差值就是 $0$ 吧，然后类似处理其他行 就是先把一些固定的值处理出来 2、可以把两行分别在头尾的代价处理出来 5 $\\large \\color{red}3$ 9 9 10 8 $\\large \\color{red}4$ 3 这里的顺序和先前不一样是想说明行的顺序是可以改变的！这时要处理的比较特殊，想象一下转换成一条链后，标红的是相邻的，我们也依次把这样的差值处理出来 预处理完后 原本和 $m$ 有关的数据就只和 $n$ 有关了，而 $n$ 的范围有那么小，于是开始乱搞 然后我们就搜索，枚举 $n$ 的全排列 当然这是不可能的，不炸就怪，肯定要加剪枝 然后就加——最优性剪枝 其实我没学过深搜的优化技巧 并且加入一个线段树的 $lowbit$ 操作，差不多就挺快的了 其实大致算一下： 16!=20\\ 9227\\ 8988\\ 8000也不多啦~ 加了优化之后，有很大的减少的 先上代码，注释掉的读优不用管 Code： #include&lt;bits/stdc++.h&gt; #define INF 0x7f7f7f7f //#define getchar() *(pos++) #define N 20 #define M 10010 using namespace std; struct node{ int to,nxt,cost; node(int a,int b):to(a),cost(b){ } node(){ } }b[M&lt;&lt;1]; int head[N],n,m,a[N][M],s[N][N],p[N][N],res,ans,bef,Total; int f[1&lt;&lt;20][20],C[100010]; //char bf[1&lt;&lt;25],*pos; //int read(){int s=0;char c=getchar(); // while(!isdigit(c))c=getchar(); // while(isdigit(c)){s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;;c=getchar();} // return s; //} void DFS(int k,int res,int t,int last) {//k表示做 if(res&lt;=ans) return;//ans表示目前的最大值 if(k==n){ ans=max(ans,min(res,p[bef][last])); return; } int cur=Total-t,j; while(cur){//树状数组的lowbit j=C[cur&amp;(-cur)];//对应到回原来的编号-1，因为第一位 1=2^0 if(s[last][j+1]&gt;ans) DFS(k+1,min(res,s[last][j+1]),t|(1&lt;&lt;j),j+1); cur-=cur&amp;(-cur); } } int main() { int i,j,k; // bf[fread(bf,1,1&lt;&lt;25,stdin)]=&#39;\\0&#39;,pos=bf; n=read();m=read();k=1; for(i=0;i&lt;=16;i++)//2^k对应到k，方便后面知道是哪一位 C[k]=i,k&lt;&lt;=1; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) a[i][j]=read(); for(i=1;i&lt;=n;i++)//预处理 第1条 for(j=1;j&lt;i;j++) { res=INF; for(k=1;k&lt;=m;k++) res=min(res,abs(a[i][k]-a[j][k])); s[i][j]=s[j][i]=res; } for(i=1;i&lt;=n;i++)//预处理 第二条 for(j=1;j&lt;=n;j++) { res=INF; for(k=1;k&lt;m;k++) res=min(res,abs(a[i][k+1]-a[j][k])); p[i][j]=res; } if(n==1){printf(&quot;%d&quot;,p[1][1]);return 0;}//这种情况不特判也没关系 Total=(1&lt;&lt;n)-1;//用于DFS中取反操作，是我太菜了，只会这种方法 for(i=1;i&lt;=n;i++)//bef表示记录首行，方便最后判断 bef=i,DFS(1,INF,1&lt;&lt;(i-1),i); printf(&quot;%d&quot;,ans); return 0; } 关于时间复杂度-&gt;Sinner 这位大佬说：时间复杂度是不正确的！ 我（瑟瑟发抖）：根据玄学，跑得超快的，因为两行之间的最小值比较难卡，所以时间还是比较稳定的我们不是理论派 好吧，此份题解仅供参考","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://hovnySiLenCe.github.io/tags/状压DP/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF1082C」Multi-Subject Competition 解题报告","slug":"CF1082C-Multi-Subject_Competition-Solution","date":"2019-03-27T13:15:00.000Z","updated":"2019-12-01T07:28:41.984Z","comments":true,"path":"2019/03/27/CF1082C-Multi-Subject_Competition-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/27/CF1082C-Multi-Subject_Competition-Solution/","excerpt":"","text":"人生第一篇题解，虽然这道题做的人暂时不多，但我相信它——迟早有一天会发扬光大的！！！说完废话步入正题 题意：传送门思路：模拟、枚举对于每个组里的数字，先排序，然后从一到最大可能的情况，枚举要选几个数记录选取的和（用前缀和会更方便），然后就是选择那些前缀和为 正数的组 加进来为 负数的组 舍去（因为出现负数的情况说明这组还未选进来的数都是负数，没有利用价值了，故舍去）具体实现起来比较麻烦把每个数分到相应的组，并把每个组里的数排序 ——》 先对全部的数排序，再用链式前向星分组枚举 数的个数： $\\to$ 用queue记录遍历的顺序，再用两个while循环遍历，res表示有价值的组的个数，里面的num表示这一次遍历了几个组（方便终止）具体见代码 #include&lt;bits/stdc++.h&gt; using namespace std; struct node{ int s,r; }a[100010]; int nxt[100010]; int head[100010]; int s[100010]; int sum,cur,ans,num,res; int n,m; int read()//快读不解释 { int s=0,p=1; char c=getchar(); while(!isdigit(c)) { if(c==&#39;-&#39;) p=-1; c=getchar(); } while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s*p; } bool cmp(node x,node y) { return x.r&lt;y.r; } int main() { int i; n=read();m=read(); for(i=1;i&lt;=n;i++) a[i].s=read(),a[i].r=read(); sort(a+1,a+1+n,cmp);//先进行排序 for(i=1;i&lt;=n;i++)//分组 { nxt[i]=head[a[i].s]; head[a[i].s]=i; } queue&lt;int&gt;p; for(i=1;i&lt;=m;i++)//起始遍历顺序就是组号 p.push(i); res=m; while(res)//有价值的组数 { num=res;//更新下次 sum=0;//记录这次的结果 while(num--) { cur=p.front();p.pop(); s[cur]+=a[head[cur]].r;//前缀和 sum+=max(s[cur],0); head[cur]=nxt[head[cur]];//更新头结点 if(head[cur]&amp;&amp;s[cur]&gt;0)//如果还有利用价值就加入下一次的遍历序列 p.push(cur); else//否则更新组数 res--; } ans=max(ans,sum);//全部的答案 } printf(&quot;%d&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://hovnySiLenCe.github.io/tags/模拟/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「ZJOI2019爆零记」","slug":"ZJOI2019-Travel-Notes","date":"2019-03-24T14:21:08.000Z","updated":"2020-01-30T09:40:17.578Z","comments":true,"path":"2019/03/24/ZJOI2019-Travel-Notes/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/24/ZJOI2019-Travel-Notes/","excerpt":"","text":"2019.3.24 周日 Day0上午8点从$YWHS$门口坐车出发，一路抖啊抖啊抖啊 目的地：宁波镇海中学-&gt;这个牛逼的地方 下车空气格外新鲜 然后刷脸，开房，吃饭 被拉去第一报告厅——鼓掌~ ​ $\\large \\uparrow$这个应该是$Judge$? 竟然有点压力了，到底是我太菜了，空手去的，回来多了一块高端大气上档次的鼠标垫奖牌 晚上吃完放，刚迈出饭店发现准考证forgotten了，然后和Judge还有Yang Xiao巨佬以及Ydk-&gt; 冲啊 然后就找不到路了 晚饭回来，一直在颓$blog$，-&gt;多多指教 h^ovny’s blog $19:00$ $luogu$的$fans$见面会 $21:35$ 外卖 很快就分完了 明天要开始上课了，有点紧张，一定要听懂，虽然我是一个数论菜鸡，跟着$Sinner$巨佬写游记，准备每天将自己的所学整理到游记里，其实是笔记本忘在学校里了，今日完 2019.3.25 周一 Day1是的，就是今天，集训开始了 然后上午和下午两节课，听得完全有点懵逼，深深地感受到自己的弱小 上午讲的大多都是多项式，而我多项式只学了乘法…全程挂机，除了一开始怎么变换的环节听懂… 下午就真的原地挂机了，印象深刻的一道题 $this$ $CF3300$ 然后有瞬秒的大佬，瑟瑟发抖 晚上去试机了，一开始还以为$Dev$有锅，结果是$main$打成了$mian$，愣是打了个树剖，感觉键盘除了有点硬之外，一切都还好，希望省选的时候不要像平时模拟赛来不及写…… 昨天的希望并没有达成，是自己能力还不够，看各位大佬看齐，真的还有好多好多知识没有学，今日完 2019.3.26 周二 Day2有点小复杂，今天上午讲的是数据结构，$LCT$有点没听懂…要学的还有好多好多 下午讲的是随机算法，真的好奇妙，但是巨弱的我并不会 晚上老师讲了下明天的注意事项，有点紧张，都还好，去外面买了点明天的零食 明天就省选了，虽然希望并不是很大，但是希望能比在衢州的时候好吧，事先提醒自己，把握好时间，尽力拿分，多多检查，我可以的，加油！ 2019.3.27 周三 Day3 The End然而，今天，是悲惨的一天，$8:00-13:00$浙江省选 压缩包，密码$JYB@Xzc!!3Yue*$，$5$遍连错，感觉凉凉 第一题，麻将…从来没有玩过麻将的人，看完题目，没思路，跳 第二题，线段树…然后想到了早上$louhc$说的吉司机线段树，开始想正解，用了两个小时，先在草稿纸上手推了一波，发现了一点小规律，然后在电脑上打了$10$行的表，惊奇的发现是杨辉三角&amp;组合数，再处理了一下细节，俩个小时过去了 开始写正解，$77$行，感觉不大对劲，跑了一遍样例，最后一个$case$ $WA$了，突然发现手推的时候推错了……心态炸了 心态爆炸写不下去，粗略看了看第三题，没有思路 乱想，原本想先拿第二题的四十分，然后就把自己$hack$掉了，煎熬 心态爆炸，想了很多，没有坚持下去，一、三题都没有思路，匆匆地打了个表，交了个错接，样例都没测 然后打第二题的暴力，过了样例，没有检查，扔在了一边，$11：30$，边吃巧克力边思考，完全没有思路 $12:20$，交了另外两题的样例，放弃，心态爆炸 感觉凉凉，分数$20$封顶，自我感觉爆零预定 是自己学的太少了，一到考场上，什么都不会 回义乌，车上 困。$ZJOI2019$爆零预定。完……","categories":[{"name":"游记","slug":"游记","permalink":"http://hovnySiLenCe.github.io/categories/游记/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://hovnySiLenCe.github.io/tags/游记/"}],"keywords":[{"name":"游记","slug":"游记","permalink":"http://hovnySiLenCe.github.io/categories/游记/"}]},{"title":"「POJ1845」 Sumdiv 解题报告","slug":"POJ1845-Sumdiv-Solution","date":"2019-03-24T10:15:28.000Z","updated":"2019-11-14T10:11:22.152Z","comments":true,"path":"2019/03/24/POJ1845-Sumdiv-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/24/POJ1845-Sumdiv-Solution/","excerpt":"","text":"题面$a^b$ 所有的因数的和 解题思路对 $a^b$ 进行唯一分解定理，可以写成： \\large (\\prod {p_i}^{c_i})^b那么就是： \\large \\prod p_i^{c_i\\times b}显然，约数和为： \\large (1+p_1+p_1^2+\\cdots+p_1^{c_1\\times b})\\times (1+p_2+p_2^2+\\cdots+p_2^{c_2\\times b})\\times \\cdots\\times(1+p_i+p_i^2+\\cdots+p_i^{c_i\\times b})令 $k_i=c_i\\times b$，那么现在的问题就是，如何求： \\large 1+p_i+p_i^2+\\cdots+p_i^{k_i}如果您学过数列的话，可以直接等比数列求和，逆元求即可 但同样也可以用分治法的思想求解 当 $k\\in2n+1(n\\in\\mathbb{N})$ 时 $f(k)=1+p+p^2+p^3+…+p^k$ $= (1+p+…+p^{\\frac k 2})+(p^{\\frac k 2+1}+…+p^k)$ $= (1+p+…+p^{\\frac k 2})+p^{\\frac k 2+1}*(1+p+…+p^{\\frac k 2})$ $= (p^{\\frac k 2+1}+1)*(1+p+…+p^{\\frac k 2})$ 当 $k\\in2n(n\\in\\mathbb{N}_+)$ 时 $f(k)=f(k-1)*p^k$ 配合快速幂对 $9901$ 取 $\\%$ Code#include&lt;cstdio&gt; #include&lt;iostream&gt; #define rgt register #define rint rgt int #define LL long long #define rll rgt LL #define N 10003 #define M 31 #define p 9901 using namespace std; LL a[M],s[M],n,m,ans=1; int t;bool b[N]; inline int read() { rint s=0; rgt char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;,c=getchar(); return s; } LL Pow(rll a,rll b) { rll res=1; for(;b;b&gt;&gt;=1,a=a*a%p) if(b&amp;1) res=res*a%p; return res; } LL solve(rll p,rll k) { if(k==1) return (p+1)%p; if(k==0) return 1; if(k&amp;1) return solve(p,k/2)*(Pow(p,k/2+1)+1)%p; return ((solve(p,k/2-1)*(Pow(p,k/2)+1))%p+Pow(p,k))%p; } int main() { rint i,j; n=read(),m=read(); if(n%2==0) { a[++t]=2; while(n%2==0) s[t]++,n/=2; } for(i=3;i*i&lt;=n;i+=2) if(!b[i]) { if(n%i==0) { a[++t]=i; while(n%i==0) s[t]++,n/=i; } j=i+i; while(j*j&lt;=n) b[j]=1,j+=i; } if(n&gt;1) a[++t]=n,s[t]=1; for(i=1;i&lt;=t;i++) ans=(ans*solve(a[i],s[i]*m))%p; printf(&quot;%lld&quot;,ans); return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://hovnySiLenCe.github.io/tags/数论/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「CF670C」 Cinema 解题报告","slug":"CF670C-Cinema-Solution","date":"2019-03-24T09:05:12.000Z","updated":"2019-12-01T07:28:39.244Z","comments":true,"path":"2019/03/24/CF670C-Cinema-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/24/CF670C-Cinema-Solution/","excerpt":"","text":"题面传送门思路：离散化、hash对于这样一个明显的统计排序的题目，当然轻而易举啦~ 但是！看！语言的编号 a数组和 b数组的值最大在$10^9$的级别，所以开个数组来存———That’s impossible! 所以我们可以用上离散化（也就是hash） 离散化，我们有两种写法 第一种是自己手码代码先排序，然后去重，接着用二分一一对应，达到离散化的目的 板子： sort(b+1,b+n+1,cmp); n=unique(b+1,b+n+1)-b-1; for(i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+n+1,a[i])-b; 第二种是使用STL库的map头文件：#include &lt;map&gt; 定义方式：map&lt;type,type&gt; p;表示将前一种type映射到后一种type 其中的类型可以很多，比如double，string，int，bool等基本类型，也包括pair这种 如map&lt;pair&lt;int,int&gt;,bool&gt;p;允许的 操作：一般用数组的形式，直接p[x]访问、写入 PS：但是map的速度比较慢，想进一步提高可以使用unordered_map 此处不才不做讲解，具体详见洛谷日报 Code: #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; int b; int a[200010]; map&lt;int,int&gt; p; int cur,res,ans; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } int main() { int i; int x; n=read(); for(i=1;i&lt;=n;i++) p[read()]++;//科（珂）学家们能听懂的语言 m=read(); for(i=1;i&lt;=m;i++)//电影配音 a[i]=read(); b=p[read()]; ans=1;//一开始默认第一种是答案 res=p[a[1]]; cur=b; for(i=2;i&lt;=m;i++) { b=p[read()]; x=p[a[i]]; if(x&gt;=res)//比较听的懂配音，看的懂字幕的人数 { if(x&gt;res) { res=x; cur=b; ans=i; } else if(cur&lt;b) { ans=i; cur=b; } } } printf(&quot;%d&quot;,ans); return 0; } 推荐题目：「Luogu」[NOI2015]程序自动分析","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"离散化","slug":"离散化","permalink":"http://hovnySiLenCe.github.io/tags/离散化/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「技术」LaTeX数学符号","slug":"LaTeX","date":"2019-03-24T09:05:10.000Z","updated":"2020-05-15T12:42:43.160Z","comments":true,"path":"2019/03/24/LaTeX/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/24/LaTeX/","excerpt":"","text":"一个神奇的网站 上标语法： x^2效果： $x^2$ 下标语法： x_i效果： $x_i$ 整体语法： x^{2y}效果： $x^{2y}$ 大括号语法：\\{\\}效果：$\\{\\}$ 分数线语法： \\frac12 \\frac{12}{23}效果： \\frac12\\ , \\ \\frac{12}{23}开方语法： \\sqrt{x} \\sqrt[3]{x}效果： $\\sqrt{x}$ $\\sqrt[3]{x}$ 省略号语法： \\ldots \\cdots效果： $\\ldots \\cdots$ 矢量语法： \\vec{ a }效果： $\\vec{ a }$ 积分语法： \\int_0^2 x^2 {\\rm d}x效果： $\\int_0^2 x^2 {\\rm d}x$ 极限语法： \\lim\\limits_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)}效果： $\\lim\\limits_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)}$ 累加语法： \\sum_{i=0}^n i^2 \\Sigma_{i=0}^n i^2效果： \\sum_{i=0}^n i^2\\ ,\\ \\Sigma_{i=0}^n i^2累乘语法： \\prod_{i=1}^n i^2 \\Pi_{i=1}^n i^2效果： \\prod_{i=1}^ni^2\\ ,\\ \\Pi_{i=1}^ni^2希腊字母 语法(大写) 效果(大写) 语法(小写) 效果(小写) \\Alpha $\\Alpha$ \\alpha $\\alpha$ \\Beta $\\Beta$ \\beta $\\beta$ \\Gamma $\\Gamma$ \\gamma $\\gamma$ \\Delta $\\Delta$ \\delta $\\delta$ \\Epsilon $\\Epsilon$ \\epsilon $\\epsilon$ \\Zeta $\\Zeta$ \\zeta $\\zeta$ \\Eta $\\Eta$ \\eta $\\eta$ \\Theta $\\Theta$ \\theta $\\theta$ \\Iota $\\Iota$ \\iota $\\iota$ \\Kappa $\\Kappa$ \\kappa $\\kappa$ \\Lambda $\\Lambda$ \\lambda $\\lambda$ \\Mu $\\Mu$ \\mu $\\mu$ \\Nu $\\Nu$ \\nu $\\nu$ \\Xi $\\Xi$ \\xi $\\xi$ \\Omicron $\\Omicron$ \\omicron $\\omicron$ \\Pi $\\Pi$ \\pi $\\pi$ \\Rho $\\Rho$ \\rho $\\rho$ \\Sigma $\\Sigma$ \\sigma $\\sigma$ \\Tau $\\Tau$ \\tau $\\tau$ \\Upsilon $\\Upsilon$ \\upsilon $\\upsilon$ \\Phi $\\Phi$ \\phi $\\phi$ \\Chi $Chi$ \\chi $\\chi$ \\Psi $\\Psi$ \\psi $\\psi$ \\Omega $\\Omega$ \\omega $\\omega$ 关系运算符 语法 效果 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\le $\\le$ \\ge $\\ge$ \\ne $\\ne$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ \\coprod $\\coprod$ 集合运算符 语法 效果 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\bigcap $\\bigcap$ \\bigcup $\\bigcup$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\biguplus $\\biguplus$ \\bigsqcup $\\bigsqcup$ 对数运算符 语法 效果 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ 三角运算符 语法 效果 \\bot $\\bot$ \\angle $\\angle$ 30^\\circ $30^\\circ$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\cot $\\cot$ \\sec $\\sec$ \\csc $\\csc$ 微积分运算符 语法 效果 \\prime $\\prime$ \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\iiiint $\\iiiint$ \\oint $\\oint$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ 逻辑运算符 语法 效果 \\because $\\because$ \\therefore $\\therefore$ \\forall $\\forall$ \\exists $\\exists$ \\not= $\\not=$ \\not&gt; $\\not&gt;$ \\not\\subset $\\not\\subset$ 戴帽符号 语法 效果 \\hat{y} $\\hat{y}$ \\check{y} $\\check{y}$ \\breve{y} $\\breve{y}$ 连线符号 语法 效果 \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+b+c+d} $\\overbrace{a+b+c+d}$ \\underbrace{a+b+c+d} $\\underbrace{a+b+c+d}$ 箭头符号 语法 效果 \\uparrow $\\uparrow$ \\downarrow $\\downarrow$ \\Uparrow $\\Uparrow$ \\Downarrow $\\Downarrow$ \\rightarrow $\\rightarrow$ \\leftarrow $\\leftarrow$ \\Rightarrow $\\Rightarrow$ \\Leftarrow $\\Leftarrow$ \\longrightarrow $\\longrightarrow$ \\longleftarrow $\\longleftarrow$ \\Longrightarrow $\\Longrightarrow$ \\Longleftarrow $\\Longleftarrow$ more$\\downarrow$","categories":[{"name":"技术","slug":"技术","permalink":"http://hovnySiLenCe.github.io/categories/技术/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"http://hovnySiLenCe.github.io/tags/LaTeX/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"http://hovnySiLenCe.github.io/categories/技术/"}]},{"title":"「CF444C」 DZY Loves Colors 解题报告","slug":"CF444C-DZY-Loves-Colors-Solution","date":"2019-03-24T08:25:45.000Z","updated":"2019-12-01T07:28:41.056Z","comments":true,"path":"2019/03/24/CF444C-DZY-Loves-Colors-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/24/CF444C-DZY-Loves-Colors-Solution/","excerpt":"","text":"题面题目描述DZY喜欢色彩，他热爱绘画。 在一个多姿多彩的日子里，$DZY$得到了一个彩色的缎带，它由$N$个单元组成（从左到右从$1$到$n$编号）。色带的第$i$个单位的最初颜色是$i$。虽然颜色足够丰富，但我们仍然认为每个单元的颜色数量最初是$0$。 我们知道$DZY$热衷于绘画。他拿起一把彩色笔，用它在缎带上画一条线。在这种情况下，他就绘制了一段连续的单元。想象一下，单位$i$被涂之前颜色是$y$。被涂之后时，单元的颜色变为$x$，令单位的颜色增加了$|x-y|$。 $DZY$想要执行$M$个操作，每个操作可以是下列操作之一： 1、将区间$[L,R]$内单元绘制为颜色$x$。 2、询问$[L,R]$之间的单位颜色的总和（包括两者）。 你能帮助$DZY$吗？ 输入：第一行包含用空格隔开的整数$n,m$（$1 \\leq n\\leq m \\leq 10^5$）。 接下来$m$行中的每一行都以一个整数开头（$1\\leq tyqe \\leq 2$）开始，表示该操作的类型。 如果$type = 1$，则在该行中，有$3$个整数$L,R,x(1 \\leq L \\leq R \\leq n; 1\\leq x \\leq 10^8)$，表示操作$1$。 如果$type=2$，则这一行，有$2$个整数$L,R,(1 \\leq L \\leq R \\leq n)$，表示操作$2$。 输出：对于每个操作$2$，输出一行，包含着色数量的和。 思路：这是一个区间覆盖的题，不经过思考就想到了$Old\\ Driver\\ Tree$，然后配合着线段树，就用数据结构过去了qaq 时间复杂度分析O(玄学)最坏的查询是$log$级的，显然不是影响时间复杂度关键，假设所有都是修改操作，修改绝大多数的时候都是使原本$n$个点变少的，最坏的情况应该是把同一个区间分裂成三个不同的区间，也就是每次把三个连在一起，再把一个区间分开三个，似乎复杂度也不会很高，最多三倍，加上$lower_bound$的$log$和线段树的$log$，时间复杂度$O(能过)$，结束，cheer Code： #include&lt;bits/stdc++.h&gt; #define It set&lt;node&gt;::iterator #define N 100010 #define ll long long using namespace std; struct node{//用于ODT int l,r; mutable int val; node(int a,int b=-1,int c=0):l(a),r(b),val(c){ } node(){ } bool operator&lt; (const node x) const{ return l&lt;x.l; } }; int n,T,L,R,val,y; ll f[N&lt;&lt;2],tag[N&lt;&lt;2],ans;//线段树，别忘了开ll set&lt;node&gt;s; It Itl,Itr,it;//迭代器 inline int read(){ register int s=0; register char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } It Split(int pos)//分离 { it=s.lower_bound(node(pos)); if(it!=s.end() &amp;&amp; it-&gt;l ==pos) return it; --it; int l=it-&gt;l,r=it-&gt;r,val=it-&gt;val; s.erase(it); s.insert(node(l,pos-1,val)); return s.insert(node(pos,r,val)).first;//返回的是pair类型，第一段关键字是插入位置的迭代器 } void push(int k,int l,int r) { f[k]+=tag[k]*(r-l+1); if(l!=r) { int cur=k&lt;&lt;1; tag[cur]+=tag[k]; tag[cur|1]+=tag[k]; } tag[k]=0; } void Modify(int k,int l,int r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R) { tag[k]=y; push(k,l,r); return; } int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; Modify(cur,l,mid); Modify(cur|1,mid+1,r); f[k]=f[cur]+f[cur|1]; } void Cov(int l,int r) { Itr=Split(r+1);it=Itl=Split(l); for(;it!=Itr;++it) { L=it-&gt;l;R=it-&gt;r;y=abs(val- it-&gt;val); Modify(1,1,n); } s.erase(Itl,Itr); s.insert(node(l,r,val));//记得这里要重新插入过 } void Query(int k,int l,int r) { if(tag[k]) push(k,l,r); if(r&lt;L||R&lt;l) return; if(L&lt;=l&amp;&amp;r&lt;=R){ans+=f[k];return;} int mid=(l+r)&gt;&gt;1,cur=k&lt;&lt;1; Query(cur,l,mid); Query(cur|1,mid+1,r); } int main() { int i; n=read();T=read(); for(i=1;i&lt;=n;i++) s.insert(node(i,i,i)); while(T--) { if(read()==1) { L=read(),R=read(),val=read(); Cov(L,R); } else ans=0,L=read(),R=read(),Query(1,1,n),printf(&quot;%lld\\n&quot;,ans); } return 0; }","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://hovnySiLenCe.github.io/tags/线段树/"},{"name":"ODT","slug":"ODT","permalink":"http://hovnySiLenCe.github.io/tags/ODT/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「UVA1328」Period 解题报告","slug":"UVA1328-Period-Solution","date":"2019-03-11T12:55:12.000Z","updated":"2019-12-01T07:28:02.713Z","comments":true,"path":"2019/03/11/UVA1328-Period-Solution/","link":"","permalink":"http://hovnySiLenCe.github.io/2019/03/11/UVA1328-Period-Solution/","excerpt":"","text":"English题面题意：给你一个长度为n的字符串，依次取字符串前i个（前缀），如果前缀由k(k&gt;0)个相同真子串构成，那么输出i和k 直到n为0结束，每组数据后要有一行空白 思路：KMP+一点点判断其实这道题并不是很难 可以先用KMP求出最长的 是s[1~i]的前缀和后缀的真子串的长度j 话说的有点复杂，分开来理 1、真子串：不是字符串本身的子串 2、是s[1~i]的前缀和后缀：以aabaab为例 aabaab aabaab aab是aabaab的前缀，又是后缀 j=3 两种条件下：以aaa为例 就应该是 aaa aaa aa是aaa的前缀&amp;后缀&amp;真子串 j=2 判断方法 if(i%(i-j)==0) //说明循环的子串长度为i-j，循环次数为i/(i-j) 证明： RT： $\\because$ l=r $\\therefore$ ①=①，②=②，③=③ $\\therefore$ ①=②=③ 其他情况无论多少都可以这样 连等，只要i-j能够整除i那么就是成立的 Code： #include&lt;bits/stdc++.h&gt; using namespace std; string s; int n,t; int len,cur; int p[1000010]; int read() { int s=0; char c=getchar(); while(!isdigit(c)) c=getchar(); while(isdigit(c)) { s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-&#39;0&#39;; c=getchar(); } return s; } int main() { int i,j; n=read(); while(n) { printf(&quot;Test case #%d\\n&quot;,++t); cin&gt;&gt;s; len=s.size(); for(i=len;i;i--) s[i]=s[i-1]; for(i=2,j=0;i&lt;=len;i++)//KMP大法 { while(j&amp;&amp;s[i]!=s[j+1])//求前缀的那个东东 j=p[j]; if(s[i]==s[j+1]) j++; p[i]=j; if(j&gt;=(i&gt;&gt;1)&amp;&amp;i%(i-j)==0)//判断一下 printf(&quot;%d %d\\n&quot;,i,i/(i-j)); } printf(&quot;\\n&quot;); n=read(); } return 0; } 友情链接KMP百度百科 【模板】KMP字符串匹配","categories":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://hovnySiLenCe.github.io/tags/KMP/"}],"keywords":[{"name":"解题报告","slug":"解题报告","permalink":"http://hovnySiLenCe.github.io/categories/解题报告/"}]},{"title":"「网络流挖坑大全」最大流最小割 错误点记录","slug":"Maxflow-Mistakes","date":"2018-12-27T10:15:01.000Z","updated":"2019-12-01T07:28:10.678Z","comments":true,"path":"2018/12/27/Maxflow-Mistakes/","link":"","permalink":"http://hovnySiLenCe.github.io/2018/12/27/Maxflow-Mistakes/","excerpt":"","text":"2018年12月27日 天气：阴 心情：一般because!——学网络流第二、三道题就WA，查错花了INF的时间 今天作为学习网络流的第二天，本人决定潜心研究记录网络流的错题 顺便补上昨天的错题 Ⅰ、炸点优化对象炸弄错了[BJOI2006]狼抓兔子WA Code：int Dinic(int k,int flow) { if(k==T) return flow; int i,to,cap,res,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].nxt) { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;deep[to]==deep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) deep[res]=0;//它错在这里！！！炸点炸的应该是to不是res！ b[i].cap-=res; b[i^1].cap+=res; rest-=res; } } return flow-rest; } AC Code：int Dinic(int k,int flow) { if(k==T) return flow; int i,to,cap,res,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].nxt) { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;deep[to]==deep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) deep[to]=0;//就是这里！哼~不高兴! b[i].cap-=res; b[i^1].cap+=res; rest-=res; } } return flow-rest; } Ⅱ、建边没看方向 眼睛呢！[BJOI2006]狼抓兔子WA Code： for(i=1;i&lt;=n;i++) for(j=1;j&lt;m;j++) { cap=read(); add(TtO(i,j),TtO(i,j+1),cap);//这里！ } for(i=1;i&lt;n;i++) for(j=1;j&lt;=m;j++) { cap=read(); add(TtO(i,j),TtO(i+1,j),cap);//这里！！ } for(i=1;i&lt;n;i++) for(j=1;j&lt;m;j++) { cap=read(); add(TtO(i,j),TtO(i+1,j+1),cap);//还有这里！！！ }//别看了，我码量大~ AC Code： for(i=1;i&lt;=n;i++) for(j=1;j&lt;m;j++) { cap=read(); add(TtO(i,j),TtO(i,j+1),cap); add(TtO(i,j+1),TtO(i,j),cap);//这样就对了 } for(i=1;i&lt;n;i++) for(j=1;j&lt;=m;j++) { cap=read(); add(TtO(i,j),TtO(i+1,j),cap); add(TtO(i+1,j),TtO(i,j),cap);//嗯，就是这样 } for(i=1;i&lt;n;i++) for(j=1;j&lt;m;j++) { cap=read(); add(TtO(i,j),TtO(i+1,j+1),cap); add(TtO(i+1,j+1),TtO(i,j),cap);//不错，这样很Nice } 不过这位大佬想出了省一半空间的方法瑟瑟发抖 这个事情告诉我们：珍惜时间，好好看题 Ⅲ、边的方向弄错[CQOI2009]跳舞WA Code： for(i=1;i&lt;=(n&lt;&lt;1);i++)//偷懒而已…… { add(i,i+(n&lt;&lt;1),n); add(i,i+(n&lt;&lt;2),k); } AC Code： for(i=1;i&lt;=n;i++) { add(i,i+(n&lt;&lt;1),n); add(i,i+(n&lt;&lt;2),k); } for(i=n+1;i&lt;=(n&lt;&lt;1);i++)//反过来就对了！ { add(i+(n&lt;&lt;1),i,n); add(i+(n&lt;&lt;2),i,k); } 这个事情告诉我们：年轻人切莫偷懒 Ⅳ、遍历边的时候写错[CQOI2009]跳舞WA Code：int Dinic(int k,int flow) { if(k==T) return flow; int i,to,cap,res,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].to)//厉害吧~ { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;deep[to]==deep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) deep[to]=0; b[i].cap-=res; b[i^1].cap+=res; rest-=res; } } return flow-rest; } AC Code：int Dinic(int k,int flow) { if(k==T) return flow; int i,to,cap,res,rest=flow; for(i=head[k];i&amp;&amp;rest;i=b[i].nxt)//这样才对嘛！众人：智障！ { to=b[i].to;cap=b[i].cap; if(cap&amp;&amp;deep[to]==deep[k]+1) { res=Dinic(to,min(rest,cap)); if(!res) deep[to]=0; b[i].cap-=res; b[i^1].cap+=res; rest-=res; } } return flow-rest; } 13:04，这是今天第二次，查错查了半天，我才学了两天啊！Ⅴ、汇点变量T混用教辅的组成WA Code： S=n1+n1+n2+n3+1;T=n1+n1+n2+n3+2;//T是汇点~ for(i=1;i&lt;=n3;i++) add(S,i+n1+n2,1); for(i=1;i&lt;=n2;i++) add(i+n1,T,1); for(i=1;i&lt;=n1;i++) add(i+n1+n2+n3,i,1); T=read();//T记录边数……黑脸 while(T--) { x=read();y=read()+n1; add(x,y,1); } T=read();//还有这里……居然！吐血 while(T--) { x=read()+n1+n2+n3;y=read()+n1+n2; add(y,x,1); } AC Code： S=n1+n1+n2+n3+1;T=n1+n1+n2+n3+2; for(i=1;i&lt;=n3;i++) add(S,i+n1+n2,1); for(i=1;i&lt;=n2;i++) add(i+n1,T,1); for(i=1;i&lt;=n1;i++) add(i+n1+n2+n3,i,1); m=read();//换个变量就行了…… while(m--) { x=read();y=read()+n1; add(x,y,1); } m=read();//我肯定是傻了…… while(m--) { x=read()+n1+n2+n3;y=read()+n1+n2; add(y,x,1); } Ⅵ、边的数组范围开小教辅的组成WA Code：#define M 50010//少了20000！ using namespace std; struct node{ int to,cap; int nxt; node(int a,int b):to(a),cap(b){ } node(){ } }b[M&lt;&lt;1]; AC Code：#define M 70010//看来真的要多加一个zero才行！ using namespace std; struct node{ int to,cap; int nxt; node(int a,int b):to(a),cap(b){ } node(){ } }b[M&lt;&lt;1]; 13:53 今天第三次 Orz网络流Ⅶ、建边交错混杂弄反 h^ovny：@#%&amp;？！[USACO07OPEN]吃饭DiningWA Code： for(i=1;i&lt;=F;i++)//看出来哪里错了吗？ add(S,n+i,1); for(i=1;i&lt;=D;i++)//混杂弄反emmm add(n+F+i,T,1); for(i=1;i&lt;=n;i++)//边弄反 add(i,n+F+D+i,1); AC Code： for(i=1;i&lt;=D;i++)//这才是正解嘛！ add(S,n+F+i,1); for(i=1;i&lt;=F;i++) add(n+i,T,1); for(i=1;i&lt;=n;i++) add(n+F+D+i,i,1); h^ovny：脑白金？！","categories":[{"name":"错误点记录","slug":"错误点记录","permalink":"http://hovnySiLenCe.github.io/categories/错误点记录/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://hovnySiLenCe.github.io/tags/网络流/"}],"keywords":[{"name":"错误点记录","slug":"错误点记录","permalink":"http://hovnySiLenCe.github.io/categories/错误点记录/"}]}]}