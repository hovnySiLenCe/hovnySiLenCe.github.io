<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「Luogu P3964」[TJOI2013]松鼠聚会 解题报告 (咕)</title>
      <link href="/2019/06/26/Luogu_P3964-%5BTJOI2013%5DSquirrelParty-Solution/"/>
      <url>/2019/06/26/Luogu_P3964-%5BTJOI2013%5DSquirrelParty-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P3964" target="_blank" rel="noopener">题面</a></h2><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF LONG_LONG_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100003</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;b[N];</span><br><span class="line"><span class="keyword">int</span> n,X[N],Y[N];</span><br><span class="line">ll Sx[N],Sy[N],x,y,ans=INF,res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">int</span> s=<span class="number">0</span>,p=<span class="number">1</span>;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) p=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">x=read(),y=read();</span><br><span class="line">X[i]=b[i].x=x+y,</span><br><span class="line">Y[i]=b[i].y=x-y;</span><br><span class="line">&#125;</span><br><span class="line">sort(X+<span class="number">1</span>,X+n+<span class="number">1</span>),sort(Y+<span class="number">1</span>,Y+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) Sx[i]=Sx[i<span class="number">-1</span>]+X[i];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) Sy[i]=Sy[i<span class="number">-1</span>]+Y[i];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">x=lower_bound(X+<span class="number">1</span>,X+n+<span class="number">1</span>,b[i].x)-X;</span><br><span class="line">y=lower_bound(Y+<span class="number">1</span>,Y+n+<span class="number">1</span>,b[i].y)-Y;</span><br><span class="line">res=b[i].x*x-Sx[x]+Sx[n]-Sx[x]-b[i].x*(n-x);</span><br><span class="line">res+=b[i].y*y-Sy[y]+Sy[n]-Sy[y]-b[i].y*(n-y);</span><br><span class="line">ans=min(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 距离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「USACO2004OPEN」Cave Cows 3 解题报告 (咕)</title>
      <link href="/2019/06/25/USACO2004OPEN-Cave_Cows_3-Solution/"/>
      <url>/2019/06/25/USACO2004OPEN-Cave_Cows_3-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P5098" target="_blank" rel="noopener">题面</a></h2><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,y,Xmax,Xmin=INF,Ymax,Ymin=INF;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">int</span> s=<span class="number">0</span>,p=<span class="number">1</span>;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) p=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">x=read(),y=read();</span><br><span class="line">Xmax=max(Xmax,x+y),</span><br><span class="line">Xmin=min(Xmin,x+y),</span><br><span class="line">Ymax=max(Ymax,x-y),</span><br><span class="line">Ymin=min(Ymin,x-y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,max(Xmax-Xmin,Ymax-Ymin));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 距离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P4551」最长异或路径 解题报告 (咕)</title>
      <link href="/2019/06/25/Luogu_P4551-TheLongestXORPath-Solution/"/>
      <url>/2019/06/25/Luogu_P4551-TheLongestXORPath-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P4551" target="_blank" rel="noopener">题面</a></h2><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100003</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt,cost;</span><br><span class="line">Edge(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c):to(a),nxt(b),cost(c)&#123;&#125;</span><br><span class="line">Edge()&#123;&#125;</span><br><span class="line">&#125;b[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],f[N],bit[<span class="number">33</span>];</span><br><span class="line"><span class="keyword">int</span> n,ans,t,T[N*<span class="number">33</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(rgt <span class="keyword">int</span> x,rgt <span class="keyword">int</span> y,rgt <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">b[++t]=Edge(y,head[x],cost),head[x]=t;</span><br><span class="line">b[++t]=Edge(x,head[y],cost),head[y]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">built</span><span class="params">(rgt <span class="keyword">int</span> k,rgt <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rgt <span class="keyword">int</span> i=head[k],to;i;i=b[i].nxt) &#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line"><span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">f[to]=f[k]^b[i].cost,built(to,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,c,p=<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">c=(k&amp;bit[i])?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(T[p][c]) res+=bit[i],p=T[p][c];</span><br><span class="line"><span class="keyword">else</span> p=T[p][c^<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,c,p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">c=(k&amp;bit[i])?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!T[p][c])</span><br><span class="line">T[p][c]=++t;</span><br><span class="line">p=T[p][c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,x,y,cost;</span><br><span class="line">n=read();</span><br><span class="line">bit[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">31</span>;i++) bit[i]=bit[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">x=read(),y=read(),cost=read(),add(x,y,cost);</span><br><span class="line">built(<span class="number">1</span>,<span class="number">0</span>),t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">ans=max(ans,f[i]),Search(f[i]),Insert(f[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「OI-wiki」 距离 学习笔记 (咕)</title>
      <link href="/2019/06/25/Oiwiki-Distance-Notes/"/>
      <url>/2019/06/25/Oiwiki-Distance-Notes/</url>
      
        <content type="html"><![CDATA[<p>欧几里得距离</p><p>曼哈顿距离</p><p>切比雪夫距离</p><p>$L_m$距离</p><p>汉明距离</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
            <tag> 距离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P2446」 [SDOI2010]大陆争霸 解题报告</title>
      <link href="/2019/06/18/Luogu_P2446-%5BSDOI2010%5DMainlandFight-Solution/"/>
      <url>/2019/06/18/Luogu_P2446-%5BSDOI2010%5DMainlandFight-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P2446" target="_blank" rel="noopener">题面</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>幻想历$8012$年$5$月$12$日深夜，斯普林·布拉泽降下神谕：$“Trust\ me, earn\ eternal\ life.”$ 克里斯军团士气大增。作为克里斯军团的主帅，你决定利用这一机会发动奇袭，一举击败杰森国。具体地说，杰森国有 $N$ 个城市，由 $M$ 条单向道路连接。神谕镇是城市 $1$ 而杰森国的首都是城市 $N$。你只需摧毁位于杰森国首都的曾·布拉泽大神殿，杰森国的信仰，军队还有一切就都会土崩瓦解，灰飞烟灭。</p><p>为了尽量减小己方的消耗，你决定使用自爆机器人完成这一任务。唯一的困难是，杰森国的一部分城市有结界保护，不破坏掉结界就无法进入城市。而每个城市的结界都是由分布在其他城市中的一些结界发生器维持的，如果想进入某个城市，你就必须破坏掉维持这个城市结界的所有结界发生器。</p><p>现在你有无限多的自爆机器人，一旦进入了某个城市，自爆机器人可以瞬间引爆，破坏一个目标（结界发生器，或是杰森国大神殿），当然机器人本身也会一起被破坏。你需要知道：摧毁杰森国所需的最短时间。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入文件的 $landcraft.in$ 的第一行两个正整数 $N, M$。</p><p>接下来 $M$ 行，每行三个正整数 $ui, vi, wi$，表示有一条从城市 $ui$ 到城市 $vi$ 的单向道路，自爆机器人通过这条道路需要 $wi$ 的时间。</p><p>之后N行，每行描述一个城市。首先是一个正整数 $li$，维持这个城市结界所使用的结界发生器数目。之后 $li$ 个 $1~N$ 之间的城市编号，表示每个结界发生器的位置。如果 $li = 0$，则说明该城市没有结界保护，保证 $l1 = 0$。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>输出文件 $landcraft.out$ 仅包含一个正整数 ，击败杰森国所需的最短时间。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6 6</span><br><span class="line">1 2 1</span><br><span class="line">1 4 3</span><br><span class="line">2 3 1</span><br><span class="line">2 5 2</span><br><span class="line">4 6 2</span><br><span class="line">5 3 2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1 3</span><br><span class="line">0</span><br><span class="line">2 3 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><img src="https://cdn.luogu.org/upload/pic/1590.png" alt="img"></p><p><img src="https://cdn.luogu.org/upload/pic/1591.png" alt="img"></p><p>对于 $20\%$的数据，满足 $N\le15$，$M\le50$；</p><p>对于 $50\%$ 的数据，满足 $N\le500$，$M\le6,000$；</p><p>对于 $100\% $的数据，满足 $N\le3,000$，$M\le70,000$，$1\le wi\le10^8$。</p><p>输入数据保证一定有解，且不会存在维持某个城市结界的结界发生器在这个城市内部。</p><p>连接两个城市的道路可能不止一条，也可能存在一个城市自己到自己的道路。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>$Dijksra$，可以说是一道比较好的最短路吧</p><p>对于控制其他城市结界这种情况，果断连边，当然啦，<strong>这些边是不跑图的</strong></p><p>然后怎么处理<strong>只有结界破坏后才能跑图</strong>呢？</p><p>这就想到了 $Dijskstra$的性质，对于每个点，只拿它<strong>更新了一次</strong>，并且，我们一同更新结界的情况，这样就可以保证，每次更新结界的时间，肯定是最短的，那么所有结界全部被破坏的情况就可以用一个数组记录了，$lim[i]$ 表示 $i$ 这个点所有结界都被破坏的最短时间，而它又是每个结界被破坏的最短时间的最大值（有点绕，仔细理解一下），那么就取 $max$ 即可</p><p>跑图的时候注意：对于<strong>结界还没全部被破坏的城市</strong>不能跑（但是能更新 $d[i]$，也就是先得出最短路答案，最后再判断这个最短距离所用的时间是否大于结界全部被破坏的时间</p><p>总体来说还是比较简单的，但是关于 $long\ long$类型赋极大值问题这里还是要$\%$一波 <a href="https://www.cnblogs.com/Judge" target="_blank" rel="noopener">$Judge$</a> 巨佬</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 70003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 3003</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt,cost;</span><br><span class="line">Edge(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cost(b)&#123;&#125;</span><br><span class="line">Edge()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Extent</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;Ev[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cost;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cost(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node x) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> cost&gt;x.cost;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[N],hv[N],a[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,t,tv,In[N];</span><br><span class="line">ll d[N],lim[N],y;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">b[++t]=Edge(y,cost),b[t].nxt=head[x],head[x]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">Ev[++tv].to=y,Ev[tv].nxt=hv[x],hv[x]=tv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,cur,to;ll cost;</span><br><span class="line">priority_queue&lt;node&gt;p;p.push(node(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(d)),d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!p.empty()) &#123;</span><br><span class="line">cur=p.top().to,p.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;vis[cur]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=hv[cur];i;i=Ev[i].nxt) &#123;<span class="comment">//处理结界</span></span><br><span class="line">to=Ev[i].to,lim[to]=max(lim[to],d[cur]),--In[to];</span><br><span class="line"><span class="keyword">if</span>(!In[to]) &#123;</span><br><span class="line"><span class="keyword">if</span>(d[to]&lt;INF) &#123;<span class="comment">//结界已经炸完了，而且d[to]被跑到过了</span></span><br><span class="line">d[to]=max(d[to],lim[to]);</span><br><span class="line">p.push(node(to,d[to]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=head[cur];i;i=b[i].nxt) &#123;<span class="comment">//跑图</span></span><br><span class="line">to=b[i].to,cost=d[cur]+b[i].cost;</span><br><span class="line"><span class="keyword">if</span>(!In[to]&amp;&amp;lim[to]&gt;cost) cost=lim[to];</span><br><span class="line"><span class="keyword">if</span>(d[to]&gt;cost) &#123;</span><br><span class="line">d[to]=cost;</span><br><span class="line"><span class="keyword">if</span>(!In[to]) p.push(node(to,cost));<span class="comment">//结界没炸完的就算了吧</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,x,y;</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">x=read(),y=read(),a[x][y]=min(a[x][y],read());</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="comment">//什么重边，自环都搞定</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="number">0x7f7f7f7f</span>||i==j)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">add(i,j,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">In[i]=read();<span class="comment">//类似用于拓扑排序一样</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=In[i];j++)</span><br><span class="line">x=read(),Add(x,i);</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,d[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P2577」[ZJOI2004]午餐 解题报告</title>
      <link href="/2019/06/17/Luogu_P2577-%5BZJOI2004%5DLunch-Solution/"/>
      <url>/2019/06/17/Luogu_P2577-%5BZJOI2004%5DLunch-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P2577" target="_blank" rel="noopener">题面</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>上午的训练结束了，THU ACM小组集体去吃午餐，他们一行$N$人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p><p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p><p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p><p>假设THU ACM小组在时刻$0$到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p><p>现在给定$N$个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>第一行一个整数N，代表总共有$N$个人。</p><p>以下$N$行，每行两个整数 $Ai$，$Bi$。依次代表第$i$个人的打饭时间和吃饭时间。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>一个整数$T$，代表所有人吃完饭的最早时刻。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 2</span><br><span class="line">7 7</span><br><span class="line">1 3</span><br><span class="line">6 4</span><br><span class="line">8 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>所有输入数据均为不超过200的正整数。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>果然，我还是太菜了</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>贪心+DP</strong></p><p>对于如此小的数据范围，果断想到$DP$，<del>但是我并没有想到</del></p><p>其实本题和<a href="https://www.luogu.org/problemnew/show/P1489" target="_blank" rel="noopener">这道题</a>，有异曲同工之妙，<del>其实纯属瞎掰，不过$author$都做不来是真的</del></p><p>于是从这道题里就可以总结出一点做题的经验，对于<strong>要求分成两组的，而且数据范围不大</strong>的题目，我们可以<del>果断</del>使用$DP$（当然啦，还要满足$DP$的前提——没有后效性）</p><p>首先来证明贪心，先按照第二关键字从大到小排序，也就是按照吃饭的时间$a[i].b$排序</p><p><strong>但是为什么呢？</strong></p><p>为什么贪心是正确的，<del>感性理解一下</del></p><p>用一个序列表示排队的顺序，</p><p>假设$i$和$j$分别为俩个人，</p><blockquote><p>$i&lt;j$ ，$i$ 在 $j$ 的前面，</p><p>且 $a[i].b&lt;a[j].b$ ，即 $i$ 吃饭比 $j$ 慢，</p></blockquote><p>设，整个序列由 $i$ 和 $j$ 两个位置决定，又因为 $i$ 耗的时间肯定比 $j$ 少，所以整个序列的时间由 $j$ 决定</p><p>则，如果交换 $i$ 和 $j$ 位置， </p><p>那么对于原本 $j$ 的位置来说，</p><p>等待时间不变，吃饭时间变短，答案变优，</p><p>对于原本的 $i$ 的位置说，$j$ 移到 $i$ 位置之后，等待时间变短，吃饭时间不变，因此答案也变优</p><p>综上，吃饭时间 $a[i].b$ 较长的人应该放在前面</p><p><del><strong>证毕！！！</strong></del></p><p>没那么夸张，但是真的证明完了 $qwq$</p><p>接下去是 $DP$ ，也就是开三维表示一下：</p><blockquote><p>$f[i][j][k]$ ：在 $i$ 这个点，$1$ 号窗的等待时间为 $j$，$2$ 号窗的等待时间为 $k$ 时的答案</p></blockquote><p>三维明显会炸</p><p>稍微观察一下：$j+k$ 是不是定值啊，就是等于前 $i$ 个人的等待时间总和，于是我们可以维护一下前缀和 $sum[i]$，然后将数组变成两维的</p><p>接下去，转移方程就比较好推了：</p><p>$$<br>f[i][j]=max{f[i-1][j-a[i].a],f[i-1][j],j+a[i].b,sum[i]-j+a[i].b}<br>$$<br>当然啦，$j&lt;a[i].a$ 时，有些转移就无效了 <del>否则<code>RE</code>爽死</del></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 40007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 203</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="keyword">int</span> n,sum[N],f[N][M],ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.b&gt;b.b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i].a=read(),a[i].b=read();</span><br><span class="line"><span class="built_in">memset</span>(f,INF,<span class="keyword">sizeof</span>(f));<span class="comment">//全都初始化为INF</span></span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp),f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//初始状态为啥都没有</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+a[i].a;<span class="comment">//处理前缀和</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;a[i].a;j++)</span><br><span class="line"><span class="keyword">if</span>(f[i<span class="number">-1</span>][j]!=INF)<span class="comment">//一些不可能的状态就不要转移了</span></span><br><span class="line">f[i][j]=max(f[i<span class="number">-1</span>][j],sum[i]-j+a[i].b);</span><br><span class="line"><span class="keyword">for</span>(j=a[i].a;j&lt;=sum[i];j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[i<span class="number">-1</span>][j]!=INF)</span><br><span class="line">f[i][j]=max(f[i<span class="number">-1</span>][j],sum[i]-j+a[i].b);</span><br><span class="line"><span class="keyword">if</span>(f[i<span class="number">-1</span>][j-a[i].a]!=INF)</span><br><span class="line">f[i][j]=min(f[i][j],max(f[i<span class="number">-1</span>][j-a[i].a],j+a[i].b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=sum[n];i++) ans=min(ans,f[n][i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SP6517」JOCHEF - Farmer Sepp 解题报告</title>
      <link href="/2019/06/14/SP6517-JOCHEF-Farmer-Sepp-Solution/"/>
      <url>/2019/06/14/SP6517-JOCHEF-Farmer-Sepp-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>悬线法、DP</strong></p><p>对于每个位置，</p><p>记录</p><blockquote><p>以这个位置为下界的最大矩阵的</p><p>左边界 ：$l[i][j]$</p><p>右边界：$r[i][j]$</p><p>高，也就是上下界差：$h[i][j]$</p></blockquote><p>当然啦，暴力做是会$T$的（废话），于是可以充分利用已经求出的信息</p><p>进行$\to\ DP$</p><p>递推式：</p><p><img src="\image\Maximizing&amp;LargestSubmatrix-9.jpg" alt></p><p>在每个位置更新答案，当然，在<code>C</code>的位置不能选，直接<code>continue</code>掉</p><h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,l[N][N],r[N][N],h[N][N];</span><br><span class="line"><span class="keyword">char</span> b[N][N];</span><br><span class="line">ll k,ans,L;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span>((n=read())) &#123;</span><br><span class="line">m=read(),k=read(),ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="comment">//读入</span></span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c==<span class="string">'\n'</span>||c==<span class="string">'\r'</span>) c=getchar();</span><br><span class="line">b[i][<span class="number">1</span>]=c,l[i][<span class="number">1</span>]=r[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=m;j++)<span class="comment">//初始化</span></span><br><span class="line">b[i][j]=getchar(),l[i][j]=r[i][j]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;<span class="comment">//处理出每个位置左右的障碍点</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">if</span>(b[i][j]==b[i][j<span class="number">-1</span>])</span><br><span class="line">l[i][j]=l[i][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(j=m<span class="number">-1</span>;j;j--)</span><br><span class="line"><span class="keyword">if</span>(b[i][j]==b[i][j+<span class="number">1</span>])</span><br><span class="line">r[i][j]=r[i][j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(b[i][j]==<span class="string">'C'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(b[i][j]==b[i<span class="number">-1</span>][j]) &#123;<span class="comment">//更新可能的矩形</span></span><br><span class="line">l[i][j]=max(l[i][j],l[i<span class="number">-1</span>][j]);</span><br><span class="line">r[i][j]=min(r[i][j],r[i<span class="number">-1</span>][j]);</span><br><span class="line">h[i][j]=h[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> h[i][j]=<span class="number">1</span>;</span><br><span class="line">L=r[i][j]-l[i][j]+<span class="number">1</span>;</span><br><span class="line">ans=max(ans,L*h[i][j]);<span class="comment">//用矩形面积公式更新</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans*k);<span class="comment">//别忘了要乘上单位面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 悬线法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「某讲稿」 极大化思想与最大子矩阵的探究 学习笔记</title>
      <link href="/2019/06/13/LectureNotes-Maximizing&amp;LargestSubmatrix-Notes/"/>
      <url>/2019/06/13/LectureNotes-Maximizing&amp;LargestSubmatrix-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这应该算是$author$的第一篇知识笔记吧，<del>且行且珍惜</del>，努力写好啦~</p><h2 id="题目引入"><a href="#题目引入" class="headerlink" title="题目引入"></a>题目引入</h2><p>先来康康一道题吧，</p><h3 id="「Luogu-P1578」-奶牛浴场"><a href="#「Luogu-P1578」-奶牛浴场" class="headerlink" title="「Luogu P1578」 奶牛浴场"></a><a href="https://www.luogu.org/problemnew/show/P1578" target="_blank" rel="noopener">「Luogu P1578」 奶牛浴场</a></h3><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>由于$John$建造了牛场围栏，激起了奶牛的愤怒，奶牛的产奶量急剧减少。为了讨好奶牛，$John$决定在牛场中建造一个大型浴场。但是$John$的奶牛有一个奇怪的习惯，每头奶牛都必须在牛场中的一个固定的位置产奶，而奶牛显然不能在浴场中产奶，于是，$John$希望所建造的浴场不覆盖这些产奶点。这回，他又要求助于$Clevow$了。你还能帮助$Clevow$吗？</p><p>$John$的牛场和规划的浴场都是矩形。浴场要完全位于牛场之内，并且浴场的轮廓要与牛场的轮廓平行或者重合。浴场不能覆盖任何产奶点，但是产奶点可以位于浴场的轮廓上。</p><p>$Clevow$当然希望浴场的面积尽可能大了，所以你的任务就是帮她计算浴场的最大面积。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入文件的第一行包含两个整数$L$和$W$，分别表示牛场的长和宽。文件的第二行包含一个整数$n$，表示产奶点的数量。以下n行每行包含两个整数$x$和$y$，表示一个产奶点的坐标。所有产奶点都位于牛场内，即：$0\le x\le L$，$0\le y\le W$。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>输出文件仅一行，包含一个整数$S$，表示浴场的最大面积。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">9 1</span><br><span class="line">1 9</span><br><span class="line">9 9</span><br></pre></td></tr></table></figure><h4 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>$0\le n\le 5000$</p><p>$1\le L,W\le 30000$</p><p>$Winter\ Camp\ 2002$</p><p><strong>又比如，这道题：</strong></p><h3 id="「Luogu-P1169」-ZJOI2007-棋盘制作"><a href="#「Luogu-P1169」-ZJOI2007-棋盘制作" class="headerlink" title="「Luogu P1169」 [ZJOI2007]棋盘制作"></a><a href="https://www.luogu.org/problemnew/show/P1169" target="_blank" rel="noopener">「Luogu P1169」 [ZJOI2007]棋盘制作</a></h3><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个$8 \times 8$大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。</p><p>而我们的主人公<code>小Q</code>，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友<code>小W</code>决定将棋盘扩大以适应他们的新规则。</p><p><code>小Q</code>找到了一张由$N \times M$个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。<code>小Q</code>想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。</p><p>不过<code>小Q</code>还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。</p><p>于是<code>小Q</code>找到了即将参加全国信息学竞赛的你，你能帮助他么？</p><h3 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h4><p>包含两个整数$N$和$M$，分别表示矩形纸片的长和宽。接下来的$N$行包含一个$N \times M$的$01$矩阵，表示这张矩形纸片的颜色（$0$表示白色，$1$表示黑色）。</p><h4 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h4><p>包含两行，每行包含一个整数。第一行为可以找到的最大正方形棋盘的面积，第二行为可以找到的最大矩形棋盘的面积（注意正方形和矩形是可以相交或者包含的）。</p><h3 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例-1：-1"><a href="#输入样例-1：-1" class="headerlink" title="输入样例#1："></a>输入样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 0 1</span><br><span class="line">0 1 0</span><br><span class="line">1 0 0</span><br></pre></td></tr></table></figure><h4 id="输出样例-1：-1"><a href="#输出样例-1：-1" class="headerlink" title="输出样例#1："></a>输出样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>对于$20\%$的数据，$N, M \le 80$</p><p>对于$40\%$的数据，$N, M ≤ 400$</p><p>对于$100\%$的数据，$N, M ≤ 2000$</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>求解<strong>矩阵中最大子矩阵问题</strong>，可以用<strong>极大化思想</strong></p><p>先来看一些定义：</p><p><strong>有效子矩形</strong>：顾名思义，即满足条件的矩形</p><p><strong>极大子矩形</strong>：原矩阵中无法再拓展（即向四周都无法拓展）的子矩形</p><p><strong>最大子矩形</strong>：<del>字面意思</del>，我们要求的答案</p><h3 id="极大化思想"><a href="#极大化思想" class="headerlink" title="极大化思想"></a>极大化思想</h3><p>可以证明，<strong>最大子矩形</strong>一定是<strong>极大子矩形</strong></p><p>于是，我们就可设计一个算法，即枚举所有极大子矩阵，然后求解</p><p>但是<del>暴力出奇迹</del>暴力总不是最好的解法，我们可以高效利用我们处理出来的信息，将算法的复杂度降到$O(n^2)$</p><h3 id="不同的题型，不同的解法"><a href="#不同的题型，不同的解法" class="headerlink" title="不同的题型，不同的解法"></a>不同的题型，不同的解法</h3><p>对于给出的第一道题，肯定不能<strong>基于矩形的大小</strong>做，于是就可以设计一个<strong>基于障碍点数</strong>的算法</p><p>由于极大化思想，一个极大子矩阵的边缘上一定有障碍点，所以可以枚举每个障碍点，再从障碍点扩展</p><p>这叫<strong>也不知道叫什么</strong>的算法</p><p>如图：</p><p><img src="\image\Maximizing&amp;LargestSubmatrix-1.jpg" alt></p><p>这是一个矩阵，为了方便处理，我们引入了矩阵的四个顶点</p><p>然后枚举每个点，比如我们做到这点，只向一个方向更新，令$U$为以$i$点为左边的矩形最大可能的上界编号，$D$则为相对应的最大可能的下界编号</p><p><img src="\image\Maximizing&amp;LargestSubmatrix-2.jpg" alt></p><p>此时：$U=7\  \ D=0$</p><p>可以看出，还可以向右拓展，于是做到$j$点</p><p><img src="\image\Maximizing&amp;LargestSubmatrix-3.jpg" alt></p><p>此时：$U=7\ \ D=0$</p><p>虽然说，现在的答案已经是最大了（程序又不是人，但是我们还要拓展</p><p>既然要求$i$点一定要在矩形的边缘上且矩形内不能有障碍点，所以就改变$U$或$D$的值</p><p><img src="\image\Maximizing&amp;LargestSubmatrix-4.jpg" alt></p><p>此时：$U=7\ \ D=3$</p><p>然后继续往右拓展，直到$U==D$或者所有点都拓展完，前者不能拓展的原因是因为无法形成矩形——已经是一条线了</p><p><img src="\image\Maximizing&amp;LargestSubmatrix-5.jpg" alt></p><p><img src="\image\Maximizing&amp;LargestSubmatrix-6.jpg" alt></p><p>然后将$i$点右移，继续做，不断更新答案</p><p>但是，这样就足够了嘛？</p><p>样例过了啊，<del>样例是真水</del></p><p>我们在样例的基础上加两个点</p><p><img src="\image\Maximizing&amp;LargestSubmatrix-7.jpg" alt></p><p><img src="\image\Maximizing&amp;LargestSubmatrix-8.jpg" alt></p><p>是不是就忘记了这两种情况，而实际上，这两种情况就都是要竖着做一遍，但是由于<del>嫌烦</del></p><p>还是特判一下好了，前者排序后特判，后者再从右往左扫一遍（一开始我们是从右往左更新</p><h4 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M b[i].y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5007<span class="comment">//由于坐标系和文中所描述的方法对x和y的定义有点不同</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//造成的小差异读者可以自行思考</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):x(a),y(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[N];</span><br><span class="line"><span class="keyword">int</span> n,m,t,ans,D,U;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.y&lt;b.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(node a,node b)</span> </span>&#123;<span class="keyword">return</span> a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">n=read(),m=read(),t=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;++i) b[i].x=read(),b[i].y=read();</span><br><span class="line">b[++t]=node(<span class="number">0</span>,m),b[++t]=node(n,<span class="number">0</span>),</span><br><span class="line">b[++t]=node(<span class="number">0</span>,<span class="number">0</span>),b[++t]=node(n,m);</span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+t,cmp);<span class="comment">//按y排序</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;t;++i) ans=max(ans,(b[i+<span class="number">1</span>].y-b[i].y)*n);<span class="comment">//对于第一种情况的特判</span></span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+t,Cmp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;t;++i) &#123;</span><br><span class="line">D=<span class="number">0</span>,U=m;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=t;++j) &#123;</span><br><span class="line">ans=max(ans,(b[j].x-b[i].x)*(U-D));</span><br><span class="line"><span class="keyword">if</span>(D&lt;=b[j].y&amp;&amp;b[j].y&lt;=U) &#123;</span><br><span class="line"><span class="keyword">if</span>(b[j].y==M) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(M&lt;b[j].y&amp;&amp;b[j].y&lt;U) U=b[j].y;</span><br><span class="line"><span class="keyword">if</span>(D&lt;b[j].y&amp;&amp;b[j].y&lt;M) D=b[j].y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">D=<span class="number">0</span>,U=m;</span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j;--j) &#123;</span><br><span class="line">ans=max(ans,(b[i].x-b[j].x)*(U-D));</span><br><span class="line"><span class="keyword">if</span>(D&lt;=b[j].y&amp;&amp;b[j].y&lt;=U) &#123;</span><br><span class="line"><span class="keyword">if</span>(b[j].y==M) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(M&lt;b[j].y&amp;&amp;b[j].y&lt;U) U=b[j].y;</span><br><span class="line"><span class="keyword">if</span>(D&lt;b[j].y&amp;&amp;b[j].y&lt;M) D=b[j].y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h3><p>当障碍点变得密集，上文所述的方法就不适用了，于是就引出了新算法——<strong>悬线法</strong></p><p>这是一个基于矩阵大小的算法</p><p>对于每个点处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l[i][j]：以(i,j)点为下界的半极大有效子矩形(因为可能还能向下拓展)的左边界(障碍点的j值)</span><br><span class="line">r[i][j]：以(i,j)点为下界的半极大有效子矩形的右边界</span><br><span class="line">h[i][j]：以(i,j)点为下界的半极大有效子矩形的高，上界到下界的距离</span><br></pre></td></tr></table></figure><p>递推式：</p><p><img src="\image\Maximizing&amp;LargestSubmatrix-9.jpg" alt></p><p>$(i,j)$位置左右最近的障碍点可以用一次$dp$处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)<span class="comment">//一开始l[i][j]和r[i][j]都是j</span></span><br><span class="line">b[i][j]=read(),l[i][j]=r[i][j]=j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">if</span>(b[i][j]^b[i][j<span class="number">-1</span>])</span><br><span class="line">l[i][j]=l[i][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(j=m<span class="number">-1</span>;j;j--)</span><br><span class="line"><span class="keyword">if</span>(b[i][j]^b[i][j+<span class="number">1</span>])</span><br><span class="line">r[i][j]=r[i][j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在每个点更新答案</p><h4 id="Code：-1"><a href="#Code：-1" class="headerlink" title="Code："></a>Code：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,l[N][N],r[N][N],h[N][N],L,a,res,ans;</span><br><span class="line"><span class="keyword">bool</span> b[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">return</span> c-<span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">b[i][j]=read(),l[i][j]=r[i][j]=j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">if</span>(b[i][j]^b[i][j<span class="number">-1</span>])<span class="comment">//稍微变换一下，和左右同色的就是障碍点</span></span><br><span class="line">l[i][j]=l[i][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(j=m<span class="number">-1</span>;j;j--)</span><br><span class="line"><span class="keyword">if</span>(b[i][j]^b[i][j+<span class="number">1</span>])</span><br><span class="line">r[i][j]=r[i][j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;b[i][j]^b[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">l[i][j]=max(l[i][j],l[i<span class="number">-1</span>][j]);</span><br><span class="line">r[i][j]=min(r[i][j],r[i<span class="number">-1</span>][j]);</span><br><span class="line">h[i][j]=h[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> h[i][j]=<span class="number">1</span>;</span><br><span class="line">L=r[i][j]-l[i][j]+<span class="number">1</span>,a=min(L,h[i][j]);</span><br><span class="line">res=max(res,a*a);</span><br><span class="line">ans=max(ans,L*h[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,res,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐题目"><a href="#推荐题目" class="headerlink" title="推荐题目"></a>推荐题目</h2><p><a href="https://www.luogu.org/problemnew/show/SP6517" target="_blank" rel="noopener">SP6517 JOCHEF - Farmer Sepp</a></p><p><a href="https://www.luogu.org/problemnew/show/P4147" target="_blank" rel="noopener">Luogu P4147 玉蟾宫</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 悬线法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P4802」[CCO 2015]路短最 解题报告</title>
      <link href="/2019/06/11/Luogu_P4802-%5BCCO%202015%5DPathShortestMost-Solution/"/>
      <url>/2019/06/11/Luogu_P4802-%5BCCO%202015%5DPathShortestMost-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><del>其实这就是<code>Hamilton路径</code>的模板题</del> <a href="https://hovnysilence.github.io/2019/03/27/AlgorithmGuide-0x01_ShortHamiltonPath-Solution/">$\to ​$</a></p><p>根本做法其实是<strong>状压DP</strong></p><p>用<code>b</code>数组存边，然后<code>f</code>数组用来跑$DP$</p><p>用$i$表示 状压后，已经走过的点有哪些（当然啦，包含下面的$j$点），为<code>f</code>数组的第一维</p><p>用$j$表示 最后到的是哪个点，为<code>f</code>数组的第二维</p><p>然后对于每种情况，可以从其他状态转移过来，这里就不详述了，具体的见代码</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 19</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Max,res,ans;<span class="comment">//Max表示每一位都取的状压值（也就是范围）</span></span><br><span class="line"><span class="keyword">int</span> b[N][N],f[<span class="number">1</span>&lt;&lt;<span class="number">19</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,x,y;</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//单向边</span></span><br><span class="line">x=read(),y=read(),b[x][y]=read();</span><br><span class="line">Max=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;<span class="comment">//求范围，f[1][0]=0</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=Max;i++) &#123;<span class="comment">//因为必经过0号点，所以直接从状态2开始，虽然2无意义，但是你要赋初值啊</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++) &#123;<span class="comment">//就是枚举，判断可以 以哪些点为终点</span></span><br><span class="line">f[i][j]=-INF;<span class="comment">//赋初值</span></span><br><span class="line"><span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>) &#123;<span class="comment">//判断</span></span><br><span class="line">res=i^(<span class="number">1</span>&lt;&lt;j);<span class="comment">//除去为结尾的这个点，可以从哪些状态转移过来</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)<span class="comment">//再枚举</span></span><br><span class="line"><span class="keyword">if</span>((res&gt;&gt;k)&amp;<span class="number">1</span>&amp;&amp;b[k][j])<span class="comment">//再判断，要注意有边才能走</span></span><br><span class="line">f[i][j]=max(f[i][j],f[res][k]+b[k][j]);<span class="comment">//求较大值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>+(<span class="number">1</span>&lt;&lt;n);i&lt;=Max;i++)<span class="comment">//以n为结尾的各种情况，i赋的初值是为了保证n-1这个点能取到</span></span><br><span class="line">ans=max(ans,f[i][n]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一点小问题"><a href="#一点小问题" class="headerlink" title="一点小问题"></a>一点小问题</h2><p>可以自行思考一下时间复杂度</p><p>这里是不会超的，但是将$n$改为$20$时，仍不会$T$，<del>暴力就是这么优秀</del></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hamilton路径 </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P1772」[ZJOI2006]物流运输 解题报告</title>
      <link href="/2019/06/10/Luogu_P1772-%5BZJOI2006%5DLogisticsTransportation-Solution/"/>
      <url>/2019/06/10/Luogu_P1772-%5BZJOI2006%5DLogisticsTransportation-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>震惊！这种非主流的方法居然$A$了</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>介绍一种不一样的思路，也就是不是<strong>DP</strong>的写法，</p><p><em>纯粹的最短路</em></p><p>数据范围比较小，然后又不同的天数</p><p>于是就可以搞<strong>分层图</strong></p><h4 id="改变路径的情况"><a href="#改变路径的情况" class="headerlink" title="改变路径的情况"></a>改变路径的情况</h4><p>只要在一层的$n$号点与下一层$1$号点之间连一条边权为$K$的边</p><h4 id="不改变路径的情况"><a href="#不改变路径的情况" class="headerlink" title="不改变路径的情况"></a>不改变路径的情况</h4><p>这种情况比较复杂，但还是由于数据范围比较小，我们就可以愉快地暴力了</p><p>把每一种路径不改变的情况（称为阶段）求出来</p><p>先枚举$i$，表示这一阶段的开始时间（即分层图上的第$i$层），</p><p>再枚举$j$，表示这一阶段的结束时间（即分层图上的第$j$层），</p><p>期间，能用的点，应该在这阶段内的每一天都可以通过，</p><p>也就是只能走没标记过的点</p><p>对于每个阶段，也可以很愉快地跑最短路</p><p>跑完最短路的结果就是一次（跑一层）的费用，再乘上 层数，在第$i$层的$1$号点和第$j$层的$n$号点之间连边，也就是表示可以直接略过中间部分</p><p>最后再整体跑个图就好了</p><p><del>怎么可能没有坑</del></p><p>坑点就是，为了防止我们连在$1$号点和$n$号点的边更新$n$号点所在层的其他节点的答案（毕竟你略过了中间部分就不能往回走了），所以在建图的时候，与$n$号点相连的边由<strong>双向边改为单向边</strong>即可</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10407</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mn 107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 23</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cost,nxt;</span><br><span class="line">Edge(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cost(b) &#123;&#125;</span><br><span class="line">Edge()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> p,t,cost;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c):p(a),t(b),cost(c)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node x) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> cost&gt;x.cost;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> head[N],hed[Mn];<span class="comment">//分别存点和时间</span></span><br><span class="line"><span class="keyword">int</span> n,m,t,T,K,D,d[N],s[N][Mn];<span class="comment">//d数组是一层的最短路，s是分层图上最短路</span></span><br><span class="line"><span class="keyword">bool</span> vis[N],usd[N],gg[N][Mn];<span class="comment">//usd记录一个阶段不能选的点有哪些</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">b[++t]=Edge(y,cost),b[t].nxt=head[x],head[x]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">b[++t]=Edge(y,cost),b[t].nxt=hed[x],hed[x]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa</span><span class="params">()</span> </span>&#123;<span class="comment">//求一层的最短路</span></span><br><span class="line"><span class="keyword">int</span> i,to,cur,cost;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p;p.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(d,INF,<span class="keyword">sizeof</span>(d)),d[<span class="number">1</span>]=<span class="number">0</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!p.empty()) &#123;</span><br><span class="line">cur=p.front(),p.pop(),vis[cur]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=head[cur];i;i=b[i].nxt) &#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line"><span class="keyword">if</span>(usd[to]) <span class="keyword">continue</span>;</span><br><span class="line">cost=d[cur]+b[i].cost;</span><br><span class="line"><span class="keyword">if</span>(d[to]&gt;cost) &#123;</span><br><span class="line">d[to]=cost;</span><br><span class="line"><span class="keyword">if</span>(!vis[to])</span><br><span class="line">vis[to]=<span class="number">1</span>,</span><br><span class="line">p.push(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">()</span> </span>&#123;<span class="comment">//求整体的最短路</span></span><br><span class="line"><span class="keyword">int</span> i,to,p,t,cost;</span><br><span class="line"><span class="keyword">bool</span> vis[N][Mn];</span><br><span class="line">priority_queue&lt;node&gt;Q;Q.push(node(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="built_in">memset</span>(s,INF,<span class="keyword">sizeof</span>(s));s[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">p=Q.top().p,t=Q.top().t,Q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[p][t]||t&gt;T) <span class="keyword">continue</span>;vis[p][t]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=head[p];i;i=b[i].nxt) &#123;</span><br><span class="line">to=b[i].to;<span class="keyword">if</span>(gg[to][t]) <span class="keyword">continue</span>;</span><br><span class="line">cost=b[i].cost+s[p][t];</span><br><span class="line"><span class="keyword">if</span>(s[to][t]&gt;cost) &#123;</span><br><span class="line">s[to][t]=cost;</span><br><span class="line">Q.push(node(to,t,cost));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="number">1</span>) &#123;<span class="comment">//特别的操作，其实就是为了减少连边数（有俩个关键字太烦了</span></span><br><span class="line"><span class="keyword">for</span>(i=hed[t];i;i=b[i].nxt) &#123;</span><br><span class="line">to=b[i].to,cost=b[i].cost+s[p][t];</span><br><span class="line"><span class="keyword">if</span>(s[n][to]&gt;cost) &#123;</span><br><span class="line">s[n][to]=cost;</span><br><span class="line">Q.push(node(n,to,cost));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(p==n) &#123;<span class="comment">//这种情况直接特判，不用连边（因为太烦了</span></span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">1</span>][t+<span class="number">1</span>]&gt;s[n][t]+K) &#123;</span><br><span class="line">s[<span class="number">1</span>][t+<span class="number">1</span>]=s[n][t]+K;</span><br><span class="line">Q.push(node(<span class="number">1</span>,t+<span class="number">1</span>,s[<span class="number">1</span>][t+<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,l,r,x,y,cost;</span><br><span class="line">T=read(),n=read(),K=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read(),y=read(),cost=read();</span><br><span class="line"><span class="keyword">if</span>(x==n) swap(x,y);<span class="comment">//建图的时候n点连的是单向边</span></span><br><span class="line"><span class="keyword">if</span>(y!=n) Add(y,x,cost);</span><br><span class="line">Add(x,y,cost);</span><br><span class="line">&#125;</span><br><span class="line">D=read();</span><br><span class="line"><span class="keyword">while</span>(D--) &#123;</span><br><span class="line">x=read(),l=read(),r=read();</span><br><span class="line"><span class="keyword">for</span>(i=l;i&lt;=r;i++) gg[x][i]=<span class="number">1</span>;<span class="comment">//gg就是不能用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;T;i++) &#123;<span class="comment">//枚举i</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++) usd[k]=gg[k][i];<span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=T;j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++) usd[k]|=gg[k][j];</span><br><span class="line">Spfa();<span class="keyword">if</span>(d[n]!=INF) add(i,j,d[n]*(j-i+<span class="number">1</span>));<span class="comment">//如果不连通，就不能连，否则就会嘿嘿嘿</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;Dijstra();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,s[n][T]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P3365」改造二叉树 解题报告</title>
      <link href="/2019/05/12/Luogu_P3365-TransformationBinaryTree-Solution/"/>
      <url>/2019/05/12/Luogu_P3365-TransformationBinaryTree-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P3365" target="_blank" rel="noopener">题面</a></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在打模拟赛的时候好像$sha$了一样想不出来，（肯定是我太菜了</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目中描述的是<strong>一棵二叉搜索树</strong>，但是实际上题目不要求改变<strong>树的形态</strong>，所以我们就把<strong>树形结构转化为线性结构</strong>，这应该是一个比较有用的小$tip$吧</p><p>转化为线性的数组之后，就变成了这样的问题：</p><blockquote><p>求 使数组 <strong>严格上升</strong> <strong>最少</strong> 要改变的元素个数</p></blockquote><p>一开始想不出来，那就可以先打打暴力找灵感</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) &#123;<span class="comment">//DP，f数组表示在保留i这个元素的情况下，</span></span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)<span class="comment">//最多可以保留多少元素</span></span><br><span class="line"><span class="keyword">if</span>(b[i]-b[j]&gt;=i-j)</span><br><span class="line">f[i]=max(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">    ans=max(f[i],ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还是有点像$LIS$的感觉的</p><p>那从哪里入手呢？</p><p>$b[i]-b[j]&gt;=i-j$</p><p>好像这个式子可以<strong>移项</strong>啊</p><p>然后就变成</p><p>$b[i]-i&gt;=b[j]-j$！！</p><p>这下真的可以用最长不下降子序列那套东西了</p><p>将$O(n^2)$优化成$O(nlogn)$ <del>就是这么优秀</del></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>献上<del>极短</del>丑陋的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() *(p++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100007<span class="comment">//有巨佬说这里开奇数的数组能快一点</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">2</span>],n,t,a[N],b[N];</span><br><span class="line"><span class="keyword">char</span> bf[<span class="number">1</span>&lt;&lt;<span class="number">23</span>],*p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="comment">//快读不管</span></span><br><span class="line">rgt <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">built</span><span class="params">(rgt <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(son[x][<span class="number">0</span>]) built(son[x][<span class="number">0</span>]);a[++t]=b[x];</span><br><span class="line"><span class="keyword">if</span>(son[x][<span class="number">1</span>]) built(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">bf[fread(bf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">23</span>,<span class="built_in">stdin</span>)]=<span class="string">'\0'</span>,p=bf;<span class="comment">//快读一部分不管</span></span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) b[i]=read();<span class="comment">//读入每个原宿</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++) son[read()][read()]=i;<span class="comment">//偷懒读入边</span></span><br><span class="line">built(<span class="number">1</span>),b[t=<span class="number">0</span>]=-INF;<span class="comment">//因为b[i]-i之后可能为负数，保险就赋一个极小值</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">a[i]-=i;<span class="comment">//处理一下</span></span><br><span class="line"><span class="keyword">if</span>(b[t]&lt;=a[i]) b[++t]=a[i];<span class="comment">//最长不下降子序列板子</span></span><br><span class="line"><span class="keyword">else</span> *upper_bound(b+<span class="number">1</span>,b+t+<span class="number">1</span>,a[i])=a[i];<span class="comment">//直接指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,n-t);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「USACO18OPEN」 Disruption 解题报告</title>
      <link href="/2019/04/21/USACO18OPEN-Disruption-Solution/"/>
      <url>/2019/04/21/USACO18OPEN-Disruption-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.luogu.org/problemnew/show/P4374" target="_blank" rel="noopener">题目描述</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>$Farmer\ John$自豪于他所经营的交通发达的的农场。这个农场是由$N$块牧场（$2 \leq N \leq 50,000$）组成的，$N-1$条双向道路将它们连接起来，每一条道路的都为一单位长度。$Farmer\ John$注意到，从任何一块牧场到另一块牧场，都能通过一组合适的道路到达。</p><p>尽管$FJ$的农场现在是连通的，他担心如果有一条道路被阻断会发生什么，因为这事实上会将他的农场分为两个不相交的牧场集合，奶牛们只能够在每一个集合内移动但不能在集合间移动。于是$FJ$又建造了$M$条额外的双向道路（$1 \leq M \leq 50,000$），每一条的长度都是一个至多为$10^9$的正整数。奶牛们仍然可以使用原有的道路进行移动，除非其中的某些被阻断了。</p><p>如果某条原有的道路被阻断了，农场就会被分为两块不相交的区域，那么$FJ$就会从他的额外修建的道路中选择一条能够重建这两块区域的连通性的，取代原来那条，从而奶牛们又可以从任何一块牧场去往另一块牧场。</p><p>对于农场上每一条原有的道路，帮助$FJ$选出最短的替代用的道路。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入的第一行包含$N$和$M$。接下来的$N-1$行，每行用整数$p$和$q$描述了一条原有的道路，其中$p \ne q$是这条道路连接的两块牧场（在$1 \ldots N$范围内）。剩下的$M$行，每行用三个整数$p$、$q$和$r$描述了一条额外的道路，其中$r$是这条道路的长度。任何两块牧场之间至多只有一条道路。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>对原有的$N−1$条道路的每一条，按照它们在输入中出现的顺序，输出如果这条道路被阻断的话，能够重新连接农场的最短的替代用道路的长度。如果不存在合适的替代用的道路，输出$-1$。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">4 1</span><br><span class="line">4 5</span><br><span class="line">6 5</span><br><span class="line">2 3 7</span><br><span class="line">3 6 8</span><br><span class="line">6 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>树链剖分</strong></p><p>经过比较仔细的分析，还是可以得出一条变删掉之后，加入的那条边必能使树重新联通，那么加入的这条边的两端点，在原树上的路径必经过那条删掉的边，$RT \downarrow$</p><p><img src="\image\Luogu_P4374.jpg" alt></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;b[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],seg[N],top[N],f[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> deep[N],Sz[N],son[N],fa[N];</span><br><span class="line"><span class="keyword">int</span> n,m,t,x,y,num,L,R,res,ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(rgt <span class="keyword">int</span> x,rgt <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">b[++t].to=y,b[t].nxt=head[x],head[x]=t;</span><br><span class="line">b[++t].to=x,b[t].nxt=head[y],head[y]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(rgt <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">rgt <span class="keyword">int</span> i,to;</span><br><span class="line">deep[k]=deep[fa[k]]+<span class="number">1</span>,Sz[k]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line"><span class="keyword">if</span>(to==fa[k]) <span class="keyword">continue</span>;</span><br><span class="line">fa[to]=k,dfs1(to);</span><br><span class="line">Sz[k]+=Sz[to];</span><br><span class="line"><span class="keyword">if</span>(Sz[to]&gt;Sz[son[k]])</span><br><span class="line">son[k]=to;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(rgt <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(son[k])</span><br><span class="line">&#123;</span><br><span class="line">seg[son[k]]=++num;</span><br><span class="line">top[son[k]]=top[k];</span><br><span class="line">dfs2(son[k]);</span><br><span class="line">&#125;</span><br><span class="line">rgt <span class="keyword">int</span> i,to;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line"><span class="keyword">if</span>(top[to]) <span class="keyword">continue</span>;</span><br><span class="line">seg[to]=++num;</span><br><span class="line">top[to]=to;</span><br><span class="line">dfs2(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(rgt <span class="keyword">int</span> k)</span> </span>&#123;<span class="comment">//其实一个数组就够了，就是特判有点复杂</span></span><br><span class="line"><span class="keyword">int</span> cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">f[cur]=min(f[cur],f[k]);</span><br><span class="line">f[cur|<span class="number">1</span>]=min(f[cur|<span class="number">1</span>],f[k]);</span><br><span class="line">f[k]=INF;<span class="comment">//下传后初值要变成INF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(rgt <span class="keyword">int</span> k,rgt <span class="keyword">int</span> l,rgt <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[k]!=INF&amp;&amp;l!=r) push(k);</span><br><span class="line"><span class="keyword">if</span>(r&lt;L||R&lt;l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">f[k]=min(f[k],res);</span><br><span class="line"><span class="keyword">if</span>(l!=r) push(k);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">rgt <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">Modify(cur,l,mid);</span><br><span class="line">Modify(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fx top[x]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fy top[y]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(fx!=fy) &#123;</span><br><span class="line"><span class="keyword">if</span>(deep[fx]&lt;deep[fy]) swap(x,y);</span><br><span class="line">L=seg[fx],R=seg[x];</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">x=fa[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(deep[x]&lt;deep[y]) swap(x,y);</span><br><span class="line">L=seg[y]+<span class="number">1</span>,R=seg[x];</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Query</span><span class="params">(rgt <span class="keyword">int</span> k,rgt <span class="keyword">int</span> l,rgt <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[k]!=INF&amp;&amp;l!=r) push(k);</span><br><span class="line"><span class="keyword">if</span>(l==r&amp;&amp;l==L) &#123;ans=f[k];<span class="keyword">return</span>;&#125;</span><br><span class="line">rgt <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid) Query(cur,l,mid);</span><br><span class="line"><span class="keyword">else</span> Query(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">x=read(),y=read(),add(x,y);</span><br><span class="line">num=seg[<span class="number">1</span>]=top[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(f,INF,<span class="keyword">sizeof</span>(f));<span class="comment">//注意一开始的初始化</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read(),y=read(),res=read();</span><br><span class="line">Add(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;t;i+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=b[i+<span class="number">1</span>].to,y=b[i].to;</span><br><span class="line"><span class="keyword">if</span>(deep[x]&gt;deep[y]) L=seg[x];</span><br><span class="line"><span class="keyword">else</span> L=seg[y];</span><br><span class="line">Query(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">if</span>(ans!=INF) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P3306」[SDOI2013]随机数生成器 解题报告</title>
      <link href="/2019/04/21/Luogu_P3306-%5BSDOI2013%5DRandomMachine-Solution/"/>
      <url>/2019/04/21/Luogu_P3306-%5BSDOI2013%5DRandomMachine-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.luogu.org/problemnew/show/P3306" target="_blank" rel="noopener">题目描述</a></h2><p>小$W$喜欢读书，尤其喜欢读《约翰克里斯朵夫》。最近小W准备读一本新书，这本书一共有$P$页，页码范围为$0 \cdots P-1$。</p><p>小$W$很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用NOI2012上学习的线性同余法生成一个序列，来决定每天具体读哪一页。</p><p>我们用$Xi$来表示通过这种方法生成出来的第$i$个数，也即小$W$第$i$天会读哪一页。这个方法需要设置$3$个参数$a,b,X1$，满足$0\leq a,b,X1\leq p-1$，且$a,b,X1$都是整数。按照下面的公式生成出来一系列的整数：$X_{i+1} \equiv aX_i+b \pmod p$其中$mod$表示取余操作。</p><p>但是这种方法可能导致某两天读的页码一样。</p><p>小W要读这本书的第$t$页，所以他想知道最早在哪一天能读到第$T$页，或者指出他永远不会读到第$t$页。</p><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入含有多组数据，第一行一个正整数$T$，表示这个测试点内的数据组数。</p><p>接下来$T$行，每行有五个整数$p$，$a$，$b$，$X1$，$t$，表示一组数据。保证$X1$和$t$都是合法的页码。 注意：$P$一定为质数</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>共$T$行，每行一个整数表示他最早读到第$t$页是哪一天。如果他永远不会读到第$t$页，输出$-1$。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p>输入样例#1：<br>3<br>7  1 1 3 3<br>7  2 2 2 0<br>7  2 2 2 1<br>输出样例#1：<br>1<br>3<br>-1</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>$0≤a≤P−1,0≤b≤P−1,2≤P≤10^9$</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><del>致敬</del>自己的$16$次提交，漏洞百出</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种题目，当然就是<del>找规律</del>套路题啊</p><p>有经验就会知道这是一道<code>BSGS</code>的题 <del>找BSGS找到的不是BSGS是什么</del></p><p>最复杂的就是<del>颓</del>推公式了</p><p>先随便从$x_1$开始写几组</p><blockquote><p>$x_1=x_1$  题目已经给出了</p><p>$x_2=ax_1+b$</p><p>$x_3=a^2x_1+ab+b$</p><p>$x_4=a^3x_1+a^2b+ab+b$</p></blockquote><p>好像就可以得出结论了<br>$$<br>x_i=a^{i-1}x_1+a^{i-1}b+a^{i-2}b+…+b<br>$$<br>对于后面这一串东东，<del>如果上过小学</del>学过<strong>等比数列求和公式</strong>的巨蛤都知道</p><p>$$<br>x_i=a^{i-1}x_1+\frac{b(1-a^{i-1})} {1-a}<br>$$</p><p>那么是不是可以开始狂颓公式了</p><p><del>1、换元（这绝对不是高中数学课</del><br>$$<br>x_i \equiv t(mod\ p)<br>$$</p><p>然后把上面那个代入<br>$$<br>a^{i-1}x_1+\frac {b(1-a^{i-1})} {1-a} \equiv t<br>$$<br>疯狂搞一搞，把$a^{i-1}$搞出来<br>$$<br>（1-a）·a^{i-1}x_1+{b(1-a^{i-1})} \equiv t-t·a<br>$$</p><p>$$<br>(x_1-x_1·a)·a^{i-1}+b-b·a^{i-1} \equiv t-t·a<br>$$</p><p>$$<br>(x_1-x_1·a-b)·a^{i-1}\equiv t-t·a-b<br>$$</p><p>$$<br>a^{i-1}\equiv \frac {t-t·a-b} {x_1-x_1·a-b}<br>$$</p><p>这样我们就可以按照普通的$BSGS$求，把结果$+1$即可</p><p><del>然后就很OK了</del></p><p>然鹅并没完，（不要问为什么，<del>否则我也不会提交16次了</del></p><p><strong>考虑几种特殊情况：</strong></p><p>$1、x_1=t$</p><p>第一天就可以读到，输出<code>1</code>，其实也没是什么影响，因为结果还是一样的</p><p>$2、a=1$</p><p>这就变成了$x_1+k·b \equiv t(mod\ p)$，费马小定理求一下就好了，注意无解的情况——也就是$b=0$</p><p>$3、a=0$</p><p><del>傻子</del>都知道和$x_1$无关了，这时只要判断一下$b==t$，则第二天就能读到$t$，否则读一辈子都读不完<del>（那就别读了</del></p><h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;//这里原题中的t用r表示</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rgt register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],nxt[N],val[N],num[N];<span class="comment">//用hash表存会快一点，虽然可以用unordered_map</span></span><br><span class="line"><span class="keyword">int</span> T,t,ans;</span><br><span class="line">ll a,b,r,p,x,Mol,Den,res;<span class="comment">//Mol是分子，Den是分母，（鬼畜的变量名</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rgt <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    rgt <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(rgt <span class="keyword">int</span> x,rgt <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//插入，链式前向星</span></span><br><span class="line">    nxt[++t]=head[x%N],head[x%N]=t;</span><br><span class="line">    val[t]=x,num[t]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Search</span><span class="params">(rgt <span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//查询，理论上是挺快的</span></span><br><span class="line">    <span class="keyword">for</span>(rgt <span class="keyword">int</span> i=head[x%N];i;i=nxt[i])</span><br><span class="line">        <span class="keyword">if</span>(val[i]==x) <span class="keyword">return</span> num[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(rgt ll a,rgt <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//快速幂</span></span><br><span class="line">    rgt ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p;</span><br><span class="line">        a=a*a%p,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head)),t=<span class="number">0</span>;<span class="comment">//t用于链式前向星，原来的t代码中用r表示</span></span><br><span class="line">    Mol=((r-r*a-b)%p+p)%p,Den=Pow(((x-a*x-b)%p+p)%p,p<span class="number">-2</span>);<span class="comment">//求出右边那一大串东东</span></span><br><span class="line">    b=Mol*Den%p;<span class="comment">//现在就变成了a^x≡b(mod p)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//有这个下文x==r的特判就可以省去</span></span><br><span class="line">    rgt <span class="keyword">int</span> i,j,t;</span><br><span class="line">    t=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>,res=b;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++) Insert(res,i),res=res*a%p;</span><br><span class="line">    a=Pow(a,t),res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!a) <span class="keyword">return</span> (!b)?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=t;i++) &#123;</span><br><span class="line">        j=Search(res);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>&amp;&amp;i*t-j&gt;=<span class="number">0</span>) <span class="keyword">return</span> i*t-j;</span><br><span class="line">        res=res*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=read();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        p=read(),a=read(),b=read(),x=read(),r=read();</span><br><span class="line">        <span class="keyword">if</span>(x==r) &#123;<span class="built_in">printf</span>(<span class="string">"1\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!b) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                r=((r-x)%p+p)%p;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,r*Pow(b,p<span class="number">-2</span>)%p+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b==r) <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=BSGS();</span><br><span class="line">        <span class="keyword">if</span>(~ans) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans+<span class="number">1</span>);<span class="comment">//答案记得+1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P2486」[SDOI2011]染色 解题报告</title>
      <link href="/2019/04/02/Luogu_P2486-%5BSDOI2011%5DDye-Solution/"/>
      <url>/2019/04/02/Luogu_P2486-%5BSDOI2011%5DDye-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是屯了一道很久的题目，昨天做完今天补一下题解，其实也并不是很难，只要想清楚一些细节就好了</p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P2486" target="_blank" rel="noopener">题面</a></h2><p>树上区间覆盖，区间查询颜色段数</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>由易到难</strong>是我们数学老师经常说的一句话，所以我们这里也来<del>乱搞</del>应用一下</p><h3 id="0、预备"><a href="#0、预备" class="headerlink" title="0、预备"></a>0、预备</h3><p>首先，这当然是一道树剖的题，然后加一个线段树维护区间<strong>颜色段数</strong>，考虑到合并时候最多就是中间会少去一段</p><blockquote><p>$1\ 3\ 4$ 和 $4\ 2 \ 1$合并时，中间的$4$会多算一遍，所以要减去</p></blockquote><p>也就是说，我们需要记录三个值</p><blockquote><p>$l$和$r$是当前区间的左右端点，用$k$表示当前区间的编号</p><p>$f[k]\ =\ l$到$r$这段区间中颜色段数</p><p>$fl[k]\ =\ $最左边节点的颜色，也就是$l$的颜色</p><p>$fr[k]\ =\ $最右边节点的颜色，即$r$的颜色</p></blockquote><p>于是$built$就可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Upd</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> k,<span class="keyword">register</span> <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">f[k]=f[cur]+f[cur|<span class="number">1</span>]-(fr[cur]==fl[cur|<span class="number">1</span>]);</span><br><span class="line">fl[k]=fl[cur],fr[k]=fr[cur|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> k,<span class="keyword">register</span> <span class="keyword">int</span> l,<span class="keyword">register</span> <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;fl[k]=fr[k]=a[rev[l]];f[k]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;<span class="comment">//不要忘记rev数组</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">built(cur,l,mid);</span><br><span class="line">built(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">Upd(k,cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、对于不在树上的修改-amp-查询"><a href="#1、对于不在树上的修改-amp-查询" class="headerlink" title="1、对于不在树上的修改&amp;查询"></a>1、对于不在树上的修改&amp;查询</h3><p>修改区间覆盖，肯定是直接覆盖不用说的，区间修改注意打标记的方式，然后再和$built$的时候一样$Upd$一下就好了<del>，感性理解这样是对的</del></p><p>对于查询，线段树的查询方式是将$[L,R]$这个区间分成$Log$块，然后依次查询$[L,R]$的每一块，很明显，查询的顺序是<strong>从左到右</strong>的，那么和$built$的时候一样，$Upd$把左右节点相同颜色的情况减掉即可</p><blockquote><p>$Las\ =\ $上一次查询的块  最右节点的颜色（$Las$的初始值为一个不可能在序列中出现的数，比如$0$）</p></blockquote><p>然后就可以这样写查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> k,<span class="keyword">register</span> <span class="keyword">int</span> l,<span class="keyword">register</span> <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[k]) push(k,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&lt;L||R&lt;l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;</span><br><span class="line"><span class="keyword">if</span>(Las==fl[k]) --ans;</span><br><span class="line">ans+=f[k];Las=fr[k];</span><br><span class="line"><span class="keyword">if</span>(l==L) Lres=fl[k];</span><br><span class="line"><span class="keyword">if</span>(r==R) Rres=fr[k];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">Query(cur,l,mid);</span><br><span class="line">Query(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、对于在树上的修改"><a href="#2、对于在树上的修改" class="headerlink" title="2、对于在树上的修改"></a>2、对于在树上的修改</h3><p>虽然会分成很多链，但实际上<del>人的</del>本质是不变的，只要对于每条重链$Modify$一下就好了</p><h3 id="3、对于在树上的查询"><a href="#3、对于在树上的查询" class="headerlink" title="3、对于在树上的查询"></a>3、对于在树上的查询</h3><p>现在不仅是块了，还有很多条链相连，所以还要考虑链的影响，但其实链的本质和上文所述块是一样的，也只要记录一下相邻的两个点就好了，为了方便，我直接全部记录在数组里，最后再一起遍历了，不要这种写法也是可以的，开几个变量然后在过程中判断就好了</p><p>附上超多的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fx top[x]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fy top[y]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Uni</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;p[<span class="number">0</span>][<span class="number">0</span>];i+=<span class="number">2</span>)</span><br><span class="line">ans-=(p[i][<span class="number">0</span>]==p[i+<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;p[<span class="number">0</span>][<span class="number">1</span>];i+=<span class="number">2</span>)</span><br><span class="line">ans-=(p[i][<span class="number">1</span>]==p[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(p[p[<span class="number">0</span>][<span class="number">0</span>]][<span class="number">0</span>]==p[p[<span class="number">0</span>][<span class="number">1</span>]][<span class="number">1</span>]) --ans;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">p[<span class="number">0</span>][<span class="number">0</span>]=p[<span class="number">0</span>][<span class="number">1</span>]=ans=<span class="number">0</span>;<span class="comment">//表示的是公共祖先左边这条链和右边这条链的键值个数</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> l=<span class="number">0</span>;<span class="comment">//表示当前的x是在公共祖先的哪一边，初始的时候默认x一侧为0</span></span><br><span class="line"><span class="keyword">while</span>(fx!=fy) &#123;</span><br><span class="line"><span class="keyword">if</span>(deep[fx]&lt;deep[fy]) swap(x,y),l^=<span class="number">1</span>;</span><br><span class="line">L=seg[fx],R=seg[x],Las=<span class="number">0</span>;</span><br><span class="line">Query(<span class="number">1</span>,<span class="number">1</span>,num);</span><br><span class="line">p[++p[<span class="number">0</span>][l]][l]=Rres,p[++p[<span class="number">0</span>][l]][l]=Lres;<span class="comment">//就是把键值记录进去</span></span><br><span class="line">x=fa[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(deep[x]&lt;deep[y]) swap(x,y),l^=<span class="number">1</span>;</span><br><span class="line">L=seg[y],R=seg[x],Las=<span class="number">0</span>;</span><br><span class="line">Query(<span class="number">1</span>,<span class="number">1</span>,num);</span><br><span class="line">p[++p[<span class="number">0</span>][l]][l]=Rres,p[++p[<span class="number">0</span>][l]][l]=Lres;</span><br><span class="line">Uni();<span class="comment">//最后再一起搞</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() *(pos++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fx top[x]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fy top[y]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;b[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],seg[N],top[N],rev[N],tag[N&lt;&lt;<span class="number">2</span>],f[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> deep[N],Sz[N],son[N],fa[N],fl[N&lt;&lt;<span class="number">2</span>],fr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,T,C,t,num,x,y,a[N],p[N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>],L,R,Lres,Rres,ans,Las;</span><br><span class="line"><span class="keyword">char</span> bf[<span class="number">1</span>&lt;&lt;<span class="number">25</span>],*pos;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> x,<span class="keyword">register</span> <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">b[++t].to=y,b[t].nxt=head[x],head[x]=t;</span><br><span class="line">b[++t].to=x,b[t].nxt=head[y],head[y]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,to;</span><br><span class="line">deep[k]=deep[fa[k]]+<span class="number">1</span>;Sz[k]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line"><span class="keyword">if</span>(to==fa[k]) <span class="keyword">continue</span>;</span><br><span class="line">fa[to]=k,dfs1(to);</span><br><span class="line">Sz[k]+=Sz[to];</span><br><span class="line"><span class="keyword">if</span>(Sz[to]&gt;Sz[son[k]])</span><br><span class="line">son[k]=to;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(son[k]) &#123;</span><br><span class="line">seg[son[k]]=++num;</span><br><span class="line">top[son[k]]=top[k];</span><br><span class="line">rev[num]=son[k];</span><br><span class="line">dfs2(son[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i,to;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i;i=b[i].nxt) &#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line"><span class="keyword">if</span>(top[to]) <span class="keyword">continue</span>;</span><br><span class="line">seg[to]=++num;</span><br><span class="line">rev[num]=to;</span><br><span class="line">top[to]=to;</span><br><span class="line">dfs2(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Upd</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> k,<span class="keyword">register</span> <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">f[k]=f[cur]+f[cur|<span class="number">1</span>]-(fr[cur]==fl[cur|<span class="number">1</span>]);</span><br><span class="line">fl[k]=fl[cur],fr[k]=fr[cur|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> k,<span class="keyword">register</span> <span class="keyword">int</span> l,<span class="keyword">register</span> <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r) &#123;fl[k]=fr[k]=a[rev[l]];f[k]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">built(cur,l,mid);</span><br><span class="line">built(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">Upd(k,cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> k,<span class="keyword">register</span> <span class="keyword">int</span> l,<span class="keyword">register</span> <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">f[k]=<span class="number">1</span>;</span><br><span class="line">fl[k]=fr[k]=tag[k];</span><br><span class="line"><span class="keyword">if</span>(l!=r) &#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">tag[cur]=tag[cur|<span class="number">1</span>]=tag[k];</span><br><span class="line">&#125;</span><br><span class="line">tag[k]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> k,<span class="keyword">register</span> <span class="keyword">int</span> l,<span class="keyword">register</span> <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[k]) push(k,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&lt;L||R&lt;l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">tag[k]=C;</span><br><span class="line">push(k,l,r);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">Modify(cur,l,mid);</span><br><span class="line">Modify(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">Upd(k,cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> k,<span class="keyword">register</span> <span class="keyword">int</span> l,<span class="keyword">register</span> <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[k]) push(k,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&lt;L||R&lt;l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;</span><br><span class="line"><span class="keyword">if</span>(Las==fl[k]) --ans;</span><br><span class="line">ans+=f[k];Las=fr[k];</span><br><span class="line"><span class="keyword">if</span>(l==L) Lres=fl[k];</span><br><span class="line"><span class="keyword">if</span>(r==R) Rres=fr[k];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">Query(cur,l,mid);</span><br><span class="line">Query(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span> </span>&#123;<span class="comment">//修改就放一起了，直接模板式改就好了</span></span><br><span class="line">C=read();</span><br><span class="line"><span class="keyword">while</span>(fx!=fy) &#123;</span><br><span class="line"><span class="keyword">if</span>(deep[fx]&lt;deep[fy]) swap(x,y);</span><br><span class="line">L=seg[fx],R=seg[x];</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,num);</span><br><span class="line">x=fa[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(deep[x]&lt;deep[y]) swap(x,y);</span><br><span class="line">L=seg[y],R=seg[x];</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,num);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Uni</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;p[<span class="number">0</span>][<span class="number">0</span>];i+=<span class="number">2</span>)<span class="comment">//首先要理解每条重链的键值成对出现，而两条链之间的键值才是有用的</span></span><br><span class="line">ans-=(p[i][<span class="number">0</span>]==p[i+<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;p[<span class="number">0</span>][<span class="number">1</span>];i+=<span class="number">2</span>)</span><br><span class="line">ans-=(p[i][<span class="number">1</span>]==p[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(p[p[<span class="number">0</span>][<span class="number">0</span>]][<span class="number">0</span>]==p[p[<span class="number">0</span>][<span class="number">1</span>]][<span class="number">1</span>]) --ans;<span class="comment">//最后尾连接的时候也要判断一下</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">p[<span class="number">0</span>][<span class="number">0</span>]=p[<span class="number">0</span>][<span class="number">1</span>]=ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(fx!=fy) &#123;</span><br><span class="line"><span class="keyword">if</span>(deep[fx]&lt;deep[fy]) swap(x,y),l^=<span class="number">1</span>;</span><br><span class="line">L=seg[fx],R=seg[x],Las=<span class="number">0</span>;</span><br><span class="line">Query(<span class="number">1</span>,<span class="number">1</span>,num);</span><br><span class="line">p[++p[<span class="number">0</span>][l]][l]=Rres,p[++p[<span class="number">0</span>][l]][l]=Lres;</span><br><span class="line">x=fa[fx];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(deep[x]&lt;deep[y]) swap(x,y),l^=<span class="number">1</span>;</span><br><span class="line">L=seg[y],R=seg[x],Las=<span class="number">0</span>;</span><br><span class="line">Query(<span class="number">1</span>,<span class="number">1</span>,num);</span><br><span class="line">p[++p[<span class="number">0</span>][l]][l]=Rres,p[++p[<span class="number">0</span>][l]][l]=Lres;</span><br><span class="line">Uni();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">bf[fread(bf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">25</span>,<span class="built_in">stdin</span>)]=<span class="string">'\0'</span>,pos=bf;</span><br><span class="line">n=read();T=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++) x=read(),y=read(),add(x,y);</span><br><span class="line">num=seg[<span class="number">1</span>]=rev[<span class="number">1</span>]=top[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">dfs1(<span class="number">1</span>),dfs2(<span class="number">1</span>),built(<span class="number">1</span>,<span class="number">1</span>,num);</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'C'</span>&amp;&amp;c!=<span class="string">'Q'</span>) c=getchar();</span><br><span class="line">x=read(),y=read();</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'C'</span>) Add();</span><br><span class="line"><span class="keyword">else</span> Ask();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「算法竞赛进阶指南」0x01 最短Hamilton路径 解题报告</title>
      <link href="/2019/03/27/AlgorithmGuide-0x01_ShortHamiltonPath-Solution/"/>
      <url>/2019/03/27/AlgorithmGuide-0x01_ShortHamiltonPath-Solution/</url>
      
        <content type="html"><![CDATA[<p><a href="http://contest-hunter.org:83/contest/0x00%E3%80%8C%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%8D%E4%BE%8B%E9%A2%98/0103%20%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84" target="_blank" rel="noopener">题目在这里啊题目在这里~</a>  </p><p>Hamilton路径：将所有点都遍历刚好一次的路径  </p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>数据范围比较小（1~20），所以我们可以考虑<strong>暴力</strong>中的<strong>枚举</strong>  </p><p>数组<code>f[i][j]</code> i的二进制表示选取了哪些点 j表示以哪个点结尾</p><p>然后就是状态压缩</p><p>由于求的是<strong>最小值</strong>，所以一开始的时候要<strong>赋初值INF</strong></p><p>为了有解，<code>f[1][0]</code>应该<strong>赋值为0</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max (1&lt;&lt;n)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hamilton</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;Max;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=INF;</span><br><span class="line"><span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=i^(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line"><span class="keyword">if</span>((res&gt;&gt;k)&amp;<span class="number">1</span>)</span><br><span class="line">f[i][j]=min(f[i][j],f[res][k]+a[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">a[i][j]=read();</span><br><span class="line">Hamilton();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[Max<span class="number">-1</span>][n<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hamilton路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「算法竞赛进阶指南」0x01 位运算 学习笔记</title>
      <link href="/2019/03/27/AlgorithmGuide-0x01_bit-Notes/"/>
      <url>/2019/03/27/AlgorithmGuide-0x01_bit-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制是计算机的根本！"><a href="#二进制是计算机的根本！" class="headerlink" title="二进制是计算机的根本！"></a>二进制是计算机的根本！</h2><p>你了解<del>她</del>它吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);<span class="comment">//x&amp;(~x+1),~x=-1-x;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __builtin_ctz(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span><br><span class="line"><span class="keyword">int</span> __builtin_ctzll(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x)</span><br><span class="line">返回x的二进制表示下最低位的<span class="number">1</span>后面有多少个<span class="number">0</span> </span><br><span class="line"><span class="keyword">int</span> __builtin_popcount(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span><br><span class="line"><span class="keyword">int</span> __builtin_popcountll(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x)</span><br><span class="line">返回x的二进制表示下有多少位为<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「USACO11NOV」牛的障碍Cow Steeplechase 解题报告</title>
      <link href="/2019/03/27/USACO11NOV-Cow_Steeplechase-Solution/"/>
      <url>/2019/03/27/USACO11NOV-Cow_Steeplechase-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P3033" target="_blank" rel="noopener">题面</a></h2><p>横的，竖的线<del>短</del>段，求最多能取几条没有相交的线段？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><del>学过网络流的童鞋在哪里？</del></p><p><del>是时候重整网络流雄风了！</del></p><p><del>好吧，废话不多说</del></p><h3 id="这是一道最小割的题目"><a href="#这是一道最小割的题目" class="headerlink" title="这是一道最小割的题目"></a>这是一道最小割的题目</h3><p>怎么想呢？</p><p>要取<strong>最多</strong>，那反过来不就是<strong>不能取的要尽量少</strong>吗？</p><p>深思熟虑一番后，符合网络流中的<strong>最小割</strong>，<del>于是开码</del></p><p>哦，还没完！</p><h3 id="建边是关键！"><a href="#建边是关键！" class="headerlink" title="建边是关键！"></a><strong>建边</strong>是关键！</h3><p>由于只有方向不同的线段才会互相影响，所以考虑在方向不同时建边</p><p>由于<strong>最小割</strong>的用途是使图<strong>不连通</strong>，所以我们把<strong>横的线段</strong>与<strong>源点</strong>相连，<strong>竖的线段</strong>与<strong>汇点</strong>相连（相反也可以），在有相交的线段之间建一条边，表示能连通，这样就变成了求<strong>最小割</strong></p><p><strong>但是！</strong></p><p>要注意的是：由于题目的要求是取线段，而不是我们建的边，因此我们把一个点（线段）拆成<strong>入点</strong>和<strong>出点</strong>，在入点和出点之间建一条容量为1的边，其余边的容量<strong>都赋为INF</strong>，这样就肯定不会“割”去<strong>边</strong>，只会“割”去点</p><h3 id="还有！"><a href="#还有！" class="headerlink" title="还有！"></a>还有！</h3><p>怎么判断线段<del>香蕉</del><strong>相交</strong>呢？</p><p><del>画出来就知道了</del></p><p>这个小问题，就留给大家思考吧</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;//虽然我不想写注释</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f<span class="comment">//但是不写注释的不是好孩纸？！h^ovny：谁说的！</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 65010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 510</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lx,ly,rx,ry,i;</span><br><span class="line">Node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> e):lx(a),ly(b),rx(c),ry(d),i(e)&#123;&#125;</span><br><span class="line">Node()&#123;&#125;</span><br><span class="line">&#125;A[N&gt;&gt;<span class="number">1</span>],B[N&gt;&gt;<span class="number">1</span>];<span class="comment">//这个是分开存横的和竖的线段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="keyword">int</span> nxt;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cap(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];<span class="comment">//边</span></span><br><span class="line"><span class="keyword">int</span> head[N],deep[N];</span><br><span class="line"><span class="keyword">int</span> n,Maxflow,S,T,t=<span class="number">1</span>,ta,tb;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cap)</span><span class="comment">//建边，比较冗长，别介意</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[++t]=node(y,cap);</span><br><span class="line">b[t].nxt=head[x];</span><br><span class="line">head[x]=t;</span><br><span class="line">b[++t]=node(x,<span class="number">0</span>);</span><br><span class="line">b[t].nxt=head[y];</span><br><span class="line">head[y]=t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,cur;</span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span>(deep));</span><br><span class="line">deep[S]=<span class="number">1</span>;p.push(S);</span><br><span class="line"><span class="keyword">while</span>(!p.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=p.front();p.pop();</span><br><span class="line"><span class="keyword">for</span>(i=head[cur];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;!deep[to])</span><br><span class="line">&#123;</span><br><span class="line">deep[to]=deep[cur]+<span class="number">1</span>;</span><br><span class="line">p.push(to);</span><br><span class="line"><span class="keyword">if</span>(to==T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==T)</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> i,to,cap,res,rest=flow;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i&amp;&amp;rest;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;deep[to]==deep[k]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=Dinic(to,min(rest,cap));</span><br><span class="line"><span class="keyword">if</span>(!res)</span><br><span class="line">deep[to]=<span class="number">0</span>;</span><br><span class="line">b[i].cap-=res;</span><br><span class="line">b[i^<span class="number">1</span>].cap+=res;</span><br><span class="line">rest-=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,flow;</span><br><span class="line"><span class="keyword">int</span> lx,ly,rx,ry;</span><br><span class="line">n=read();T=n+n+<span class="number">1</span>;<span class="comment">//源点一般赋为0，那就先确定汇点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//读入，然后开始玄学建边</span></span><br><span class="line">&#123;</span><br><span class="line">lx=read();ly=read();</span><br><span class="line">rx=read();ry=read();</span><br><span class="line"><span class="keyword">if</span>(lx==rx)</span><br><span class="line">&#123;</span><br><span class="line">B[++tb]=Node(min(lx,rx),min(ly,ry),max(lx,rx),max(ly,ry),i);<span class="comment">//注意，要是两端点有序！</span></span><br><span class="line">add(S,i,INF);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=ta;j++)<span class="comment">//判断是否满足，然后建边</span></span><br><span class="line"><span class="keyword">if</span>(B[tb].ry&gt;=A[j].ly&amp;&amp;B[tb].ly&lt;=A[j].ly&amp;&amp;A[j].lx&lt;=B[tb].lx&amp;&amp;B[tb].lx&lt;=A[j].rx)</span><br><span class="line">add(i+n,A[j].i,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">A[++ta]=Node(min(lx,rx),min(ly,ry),max(lx,rx),max(ly,ry),i);</span><br><span class="line">add(i+n,T,INF);<span class="comment">//一切同上</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=tb;j++)</span><br><span class="line"><span class="keyword">if</span>(B[j].ry&gt;=A[ta].ly&amp;&amp;B[j].ly&lt;=A[ta].ly&amp;&amp;A[ta].lx&lt;=B[j].lx&amp;&amp;B[j].lx&lt;=A[ta].rx)</span><br><span class="line">add(B[j].i+n,i,INF);</span><br><span class="line">&#125;</span><br><span class="line">add(i,i+n,<span class="number">1</span>);<span class="comment">//自己的入点和出点之间建边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(BFS())<span class="comment">//Dinic模板直接搬</span></span><br><span class="line"><span class="keyword">while</span>((flow=Dinic(S,INF)))</span><br><span class="line">Maxflow+=flow;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,n-Maxflow);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SP23776」KQUERYO - K-Query Online 解题报告</title>
      <link href="/2019/03/27/SP23776-KQUERYO_-_K-Query_Online-Solution/"/>
      <url>/2019/03/27/SP23776-KQUERYO_-_K-Query_Online-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/SP23776" target="_blank" rel="noopener">题面</a></h2><p>$n$个数，$q$次询问，询问$[i,j]$区间大于$k$的数的个数，输入时，输入$a,b,c$</p><ul><li>i = a xor last_ans</li><li>j = b xor last_ans</li><li>k = c xor last_ans</li></ul><p>一开始last_ans为$0$</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h2 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h2><p><del>其实是一道模板题</del></p><p>离散化后直接硬上模板</p><p>要注意的地方就是——</p><p>最后查询的时候$k$不要离散化，而是在查询函数中改变判断条件</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 30010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;T[N*<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> a[N],b[N],root[N],t,n,m,res;</span><br><span class="line"><span class="keyword">int</span> x,y,k,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">built</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T[++res]=T[y];T[res].sum++;x=res;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">built(l,mid,T[x].l,T[y].l,pos);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">built(mid+<span class="number">1</span>,r,T[x].r,T[y].r,pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[l]&lt;=k)</span><br><span class="line">ans+=T[y].sum-T[x].sum;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum=T[T[y].l].sum-T[T[x].l].sum;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=b[mid])<span class="comment">//就是在这里加判断</span></span><br><span class="line">query(l,mid,T[x].l,T[y].l);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans+=sum,query(mid+<span class="number">1</span>,r,T[x].r,T[y].r);<span class="comment">//ans加上左子树的大小，表示有多少个数比k小</span></span><br><span class="line">&#125;<span class="comment">//但是实际上可以把条件改一改，然后加上右子树的大小，这里为了方便理解，就不改了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">b[i]=a[i]=read();</span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);t=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+t,a[i])-b;</span><br><span class="line">built(<span class="number">1</span>,t,root[i],root[i<span class="number">-1</span>],a[i]);</span><br><span class="line">&#125;</span><br><span class="line">m=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read()^ans;y=read()^ans;k=read()^ans;ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">1</span>)x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y&gt;n) y=n;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans); <span class="keyword">continue</span>; &#125;</span><br><span class="line">query(<span class="number">1</span>,t,root[x<span class="number">-1</span>],root[y]);</span><br><span class="line">ans=y-x+<span class="number">1</span>-ans;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SP20644」ZQUERY - Zero Query 解题报告</title>
      <link href="/2019/03/27/SP20644-ZQUERY_-_Zero_Query-Solution/"/>
      <url>/2019/03/27/SP20644-ZQUERY_-_Zero_Query-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/SP20644" target="_blank" rel="noopener">题面</a></h2><p><del>SPOJ上的题，数据都很坑</del></p><p>大意：长度为$n$的序列，序列中的值为$1$或$-1$</p><p>有$m$个询问，询问在$[L,R]$中<strong>区间和</strong>为$0$<del>的区间</del>的<strong>最大长度</strong></p><p>这样会比较好理解吧，翻译的时候没翻好</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="莫队-multiset"><a href="#莫队-multiset" class="headerlink" title="莫队+multiset"></a>莫队+multiset</h3><p>对于这种区间<del>乱搞</del>操作的，一般选用莫队(Mo’s algorithm)比较方便</p><p>来做这道题的大佬们应该都有学过莫队吧，$Luogu$没有莫队模板确实是一件比较复杂的事情，原本这道题$\large \to$<a href="https://www.luogu.org/problemnew/show/P1972" target="_blank" rel="noopener">HH的项链</a>还是能用莫队水过去，然后结果数据加强了……</p><p>莫队模板题$\to$<a href="https://www.luogu.org/problemnew/show/P2709" target="_blank" rel="noopener">小B的询问</a>可以去做一下</p><p>求和为$0$的区间，显然是要预处理的，所以读入的时候就记录前缀和</p><p>那么题目转化为$\to$两个相同元素的最大间距</p><p>原先的样例为：</p><blockquote><p>1    1    1    -1    -1    -1</p></blockquote><p>转化为前缀和：</p><blockquote><p>1    2    3    2    1    0</p></blockquote><p>求$[1,3]$这个区间，由于前缀和的影响，不应该直接在$[1,3]$这个区间里找相同，而是应该把左端点左移一位，求$[0,3]$这个区间的相同</p><p>由于区间的相同元素可能有多个：</p><blockquote><p>1    -1    1    -1    1    -1</p></blockquote><p>这组数据转化后就是：</p><blockquote><p>1    0    1    0    1    0</p></blockquote><p>设元素$x$，在$[l,r]$中最早出现的位置为$Min[x]$，最晚出现的位置为$Max[x]$</p><p>在$[1,6]$中，元素$1$和$0$分别有$3$个，但是实际上第一个$1$（或$0$）和最后一个$1$（或$0$）才是有价值的（也就是$Max[1],min[1],Max[0],Min[0]$，价值为他们之间的距离，即$5-1=4$或$6-2=4$），那么中间的元素就可以省去吗？     不行！由于莫队算法中$Add$和$Del$操作，要求我们记录这些值，才能在$O(1)$的时间里更新</p><p>$[l,r]$这个区间里，由每种元素都有可能构成最优值，因此还要用$multiset$记录每种元素的最优值，当然，如果一个区间中某个元素只出现了一次，那么该元素的价值应该是$Max[x]=Min[x],Max[x]-Min[x]=0$，也可以加入$multiset$中，但是在这里我怕时间无法承受，就特判掉了</p><p>那么如何记录这些中间值呢？我只想到了链表，其实双端队列（$deque$应该也可以，<del>如果不怕炸的话</del>）</p><p>再说一下前缀和，前缀和可能是负数哦~</p><p>那么就加一个$n+1$就够了（$n$为序列长度，当然保险点加个$n+7$）</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,i;</span><br><span class="line">&#125;b[N];</span><br><span class="line"><span class="keyword">int</span> a[N],n,m,block,pos[N],l,r,num;</span><br><span class="line"><span class="keyword">int</span> Min[N&lt;&lt;<span class="number">1</span>],Max[N&lt;&lt;<span class="number">1</span>],Ans[N],L[N],R[N];<span class="comment">//Ans记录答案，其他数组用于存链表，据说STL中与一个list</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//莫队奇偶划分</span></span><br><span class="line"><span class="keyword">return</span> (pos[a.l]==pos[b.l])?(pos[a.l]&amp;<span class="number">1</span>)?a.r&gt;b.r:a.r&lt;b.r:a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//添加</span></span><br><span class="line">num=a[x]+n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(Max[num]&lt;<span class="number">0</span>)<span class="comment">//这种情况链表中没有元素</span></span><br><span class="line">&#123;</span><br><span class="line">Max[num]=Min[num]=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Max[num]!=Min[num])<span class="comment">//要更新价值，原先的就要删掉，特判掉了价值为0的情况，为0不删</span></span><br><span class="line">ans.erase(ans.lower_bound(Max[num]-Min[num]));</span><br><span class="line"><span class="keyword">if</span>(Min[num]&gt;x)<span class="comment">//加入头</span></span><br><span class="line">&#123;</span><br><span class="line">L[Min[num]]=x;</span><br><span class="line">R[x]=Min[num];</span><br><span class="line">Min[num]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//加入尾</span></span><br><span class="line">&#123;</span><br><span class="line">R[Max[num]]=x;</span><br><span class="line">L[x]=Max[num];</span><br><span class="line">Max[num]=x;</span><br><span class="line">&#125;</span><br><span class="line">ans.insert(Max[num]-Min[num]);<span class="comment">//更新最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//删除</span></span><br><span class="line">num=a[x]+n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(Min[num]==Max[num])</span><br><span class="line">&#123;</span><br><span class="line">Max[num]=<span class="number">-1</span>;Min[num]=(n&lt;&lt;<span class="number">1</span>)+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans.erase(ans.lower_bound(Max[num]-Min[num]));</span><br><span class="line"><span class="keyword">if</span>(Min[num]==x)</span><br><span class="line">Min[num]=R[x];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Max[num]=L[x];</span><br><span class="line"><span class="keyword">if</span>(Max[num]!=Min[num])</span><br><span class="line">ans.insert(Max[num]-Min[num]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);block=<span class="built_in">pow</span>(n,<span class="number">0.54</span>);<span class="comment">//玄学优化</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">a[i]+=a[i<span class="number">-1</span>];<span class="comment">//前缀和</span></span><br><span class="line">pos[i]=i/block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;b[i].l,&amp;b[i].r),b[i].i=i;</span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+m,cmp);l=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>)+<span class="number">7</span>;i++)</span><br><span class="line">Min[i]=(n&lt;&lt;<span class="number">1</span>)+<span class="number">7</span>,Max[i]=<span class="number">-1</span>;<span class="comment">//Max[i]赋为-1是为了包容0这个位置</span></span><br><span class="line">ans.insert(<span class="number">0</span>);<span class="comment">//预先输入0，防止RE（可我还是RE了）</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(r&lt;b[i].r)Add(++r);</span><br><span class="line"><span class="keyword">while</span>(l&gt;b[i].l<span class="number">-1</span>) Add(--l);<span class="comment">//如果RE了，就把Add往前挪吧，千万要注意顺序！</span></span><br><span class="line"><span class="keyword">while</span>(r&gt;b[i].r)Del(r--);<span class="comment">//否则Del(r--)后，r的值可能小于l，然后就爆炸</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;b[i].l<span class="number">-1</span>) Del(l++);</span><br><span class="line">Ans[b[i].i]=*(--ans.end());<span class="comment">//最大的价值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SP1487」PT07J - Query on a tree III 解题报告</title>
      <link href="/2019/03/27/SP1487-PT07J_-_Query_on_a_tree_III-Solution/"/>
      <url>/2019/03/27/SP1487-PT07J_-_Query_on_a_tree_III-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="戳这里看题面"><a href="#戳这里看题面" class="headerlink" title="戳这里看题面"></a><a href="https://www.luogu.org/problemnew/show/SP1487" target="_blank" rel="noopener">戳这里看题面</a></h2><p>一道挺有意思的题，可以练一下板子</p><p>大意：给出$n(1\le n \le10^5)$个结点的树，$m$组询问，求 以$x$为根节点的树中 第$k$小的数（从小到大第$k$个） </p><p>题目中没翻译清楚，该树树<strong>以$1$为根节点</strong></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>对于树上操作，我已开始想到的是树剖，但是题目中所求的是<strong>以$x$为根的树</strong>，那么那么就应该想到<strong>DFS序</strong></p><p>这和树剖一样，是一个能将<strong>树形结构转化为线性结构</strong>的神奇的东西</p><p>确定了使用$DFS$序之后，对于树中第$k$小，由于它是不带修的，所以很容易想到使用<strong>主席树</strong></p><p><del>然后就开始乱搞了</del></p><h2 id="注意要点："><a href="#注意要点：" class="headerlink" title="注意要点："></a>注意要点：</h2><p>题目中所求的是第$k$小点的<strong>编号</strong>！！</p><p>主席树查询出结果后，这个l值<strong>不是实际上的编号</strong></p><p>因为主席树最后得到<code>l==r</code>的时候，<code>l</code>的值实际上是这个点在权值线段树中的位置</p><p>而这个点原先的<code>Id</code>并不一定是<code>l</code>，所以还要记录一下<code>Id</code>然后再对应回去</p><p>具体详见代码吧，结合代码说的更清楚</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;b[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;T[N*<span class="number">80</span>];<span class="comment">//开大点没事，但是算一下，实际上40差不多了</span></span><br><span class="line"><span class="keyword">int</span> head[N],in[N],out[N],a[N],p[N],rev[N],root[N],Id[N];</span><br><span class="line"><span class="keyword">int</span> n,Ts,num,x,y,res,t,ans,k;<span class="comment">//rev数组将dfs序对应会原来的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">b[++t].to=y;b[t].nxt=head[x];head[x]=t;</span><br><span class="line">b[++t].to=x;b[t].nxt=head[y];head[y]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span><span class="comment">//这里求的是dfs序，in[k]表示k这个点的dfs序</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//out[k]表示k这个点的子树中最大dfs序，也就是说，在in[k]~out[k]这个区间，都是以k为根的树 的节点的dfs序</span></span><br><span class="line">in[k]=++num;<span class="comment">//有点绕口</span></span><br><span class="line">rev[num]=k;</span><br><span class="line"><span class="keyword">int</span> i,to;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line"><span class="keyword">if</span>(to==fa)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">dfs(to,k);</span><br><span class="line">&#125;</span><br><span class="line">out[k]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y,<span class="keyword">int</span> pos,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T[++res]=T[y];T[res].sum++;x=res;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">Id[l]=i;<span class="comment">//顺便记录一下这个点原先的编号</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid)</span><br><span class="line">Modify(l,mid,T[x].l,T[y].l,pos,i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Modify(mid+<span class="number">1</span>,r,T[x].r,T[y].r,pos,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">ans=Id[l];<span class="comment">//这样就可以直接对应了</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum=T[T[y].l].sum-T[T[x].l].sum;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=sum)</span><br><span class="line">query(l,mid,T[x].l,T[y].l,k);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">query(mid+<span class="number">1</span>,r,T[x].r,T[y].r,k-sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">p[i]=a[i]=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read();</span><br><span class="line">add(x,y);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//i表示的是dfs序</span></span><br><span class="line">&#123;</span><br><span class="line">a[rev[i]]=lower_bound(p+<span class="number">1</span>,p+<span class="number">1</span>+n,a[rev[i]])-p;<span class="comment">//离散化</span></span><br><span class="line">Modify(<span class="number">1</span>,n,root[i],root[i<span class="number">-1</span>],a[rev[i]],rev[i]);</span><br><span class="line">&#125;</span><br><span class="line">Ts=read();</span><br><span class="line"><span class="keyword">while</span>(Ts--)</span><br><span class="line">&#123;</span><br><span class="line">x=read();k=read();</span><br><span class="line">query(<span class="number">1</span>,n,root[in[x]<span class="number">-1</span>],root[out[x]],k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P4051」[JSOI2007]字符加密 解题报告</title>
      <link href="/2019/03/27/Luogu_P4051-%5BJSOI2007%5DCharPasscode-Solution/"/>
      <url>/2019/03/27/Luogu_P4051-%5BJSOI2007%5DCharPasscode-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P4051" target="_blank" rel="noopener">题面</a></h2><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>作为一个<strong>后缀数组</strong>的初学者，当然首先想到的是<strong>后缀数组</strong></p><p>把$s$这个串首尾相接，扩展为原来的两倍，就能按后缀数组的方法处理</p><h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p><del>神仙一眼就看出这是后缀的裸题，我这个蒟蒻想了半天想不出来</del></p><p>如果我们只对$s$串进行后缀排序，明显无法处理如下的情况，<del>于是就拿了30分</del></p><blockquote><p>$s=bnabn$</p><p>$bn$会在$bnabn$前面，而实际$bn$对应的应该是$bnbna$，比$bnabn$要大</p></blockquote><p>那么应该这么处理这些缺少的串呢？</p><p>我们可以尝试一下把原来的$s$变成两倍</p><blockquote><p>$s=bnabn+bnabn$</p><p>后缀$bnabnbnabn$在后缀$bnbnabn$前面，而实际上$bnabn$也同样在$bnbna$前面</p></blockquote><p>这样扩展了一倍之后，也就是说题目中变化得到的$len(s)$个串都出现过，但是多出来的部分会不会影响结果呢？</p><p>答案是不会</p><p>比如说：</p><blockquote><p>$s=abcd$</p><p>扩展后$ \to s=abcdabcd$</p><p>对于原串的一种变化结果$bcda$</p><p>包含在扩展后的$s$中，而$bcda$对应的后缀就是$bcdabcd$，后缀中多出的$bcd$对于$bcda$来说，它实际上是$bcda$的前缀，也就是说它对$bcda$的影响由$bcda$决定，<del>这不就是没有影响吗</del></p></blockquote><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x[N],y[N],c[N],sa[N],p,t;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">t=<span class="built_in">strlen</span>(s);m=<span class="number">300</span>;n=t&lt;&lt;<span class="number">1</span>;<span class="comment">//t是原来s的长度，n是扩展后长度，m初始值实际不用300</span></span><br><span class="line"><span class="keyword">for</span>(i=t;i&lt;n;i++) s[i]=s[i-t];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) c[x[i]=s[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) sa[--c[x[i]]]=i;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=n-k;i&lt;n;i++) y[p++]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=k) y[p++]=sa[i]-k;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) c[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) c[x[y[i]]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--c[x[y[i]]]]=y[i];</span><br><span class="line">swap(x,y);p=<span class="number">1</span>;x[sa[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">x[sa[i]]=(y[sa[i<span class="number">-1</span>]]==y[sa[i]]&amp;&amp;y[sa[i<span class="number">-1</span>]+k]==y[sa[i]+k])?p<span class="number">-1</span>:p++;</span><br><span class="line"><span class="keyword">if</span>(p&gt;=n) <span class="keyword">break</span>;</span><br><span class="line">m=p;</span><br><span class="line">&#125;<span class="comment">//都是后缀数组的模板</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&lt;t) <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[(sa[i]+t<span class="number">-1</span>)]);<span class="comment">//也就是一个后缀开始的前一位</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P4313」文理分科 解题报告</title>
      <link href="/2019/03/27/Luogu_P4313-DivideSubject-Solution/"/>
      <url>/2019/03/27/Luogu_P4313-DivideSubject-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P4313" target="_blank" rel="noopener">题面</a></h2><p>大意：$n \times m$ 矩阵上的点，分成两部分，每个点分配后会有一个分数，上下左右以及中间 的五个点分到一起会有额外的分数，可以是0，求分配后最大的分数</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>网络流最小割</strong></p><p>网络流的模板并不是很难，难在<strong>建边</strong></p><p>而对于这道题，其实是网络流中的一种标准模型吧</p><p>一个点分到A或B两部分中，不同的点组合在一起有加分的情况</p><p>用网络流的最小割做</p><p>就应该先把问题转化一下：</p><p>最优的答案当然是<strong>所有分值都加在一起</strong>咯</p><p>但是，一个点不可能同时出现在两部分，所以导致了一些不可能的情况</p><p>现在我们的目标就是去掉尽量少的分数（边权），使一个点只能出现在一个部分</p><p>这就非常符合最小割了</p><p>可以一开始把每个点拆成两个点，一个和超级源点S，另一个和超级汇点T相连</p><p>在题目中的实际意义就是这个同学是学文还是学理，边权为 他/她 的满意度，记得在这两个点之间连上一条边权为INF的边，因为同一点是不能分割的！</p><p>然后处理组合，</p><p>对于每个组合，我们新建一个结点，然后把它当做一个普通的节点处理</p><p>RT：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_ZuiXiaoGe_1.png" alt></p><p>1和2是两个普通点，为了表示1和2的组合关系，就引入结点3当做 伪1结点 和 伪2结点，与$1’$和$2’$连边</p><p>$3’$ 做同样的处理</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_ZuiXiaoGe_2.png" alt></p><p>这幅图和上面的图是等价的，但是从意义上来看，上面的图更能说明 $3$ 和 $3’$ 的意义</p><p>建图之后跑一遍Dinic就好了</p><p>由于我们求的是最小割</p><p>所以结果应该是Ans——所有情况的满意度总和，减去Maxflow——至少删去多少边，才能满足一个同学只能选一科</p><h3 id="Warming：新建结点并连边的时候，不要忘记与当前的点相连"><a href="#Warming：新建结点并连边的时候，不要忘记与当前的点相连" class="headerlink" title="Warming：新建结点并连边的时候，不要忘记与当前的点相连"></a>Warming：新建结点并连边的时候，不要忘记与当前的点相连</h3><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 40010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mn 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Cx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//上下左右</span></span><br><span class="line"><span class="keyword">int</span> Cy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="keyword">int</span> nxt;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cap(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],deep[N];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,t=<span class="number">1</span>,Ans,Maxflow,Max;<span class="comment">//Ans累计满意度之和</span></span><br><span class="line"><span class="keyword">bool</span> p[Mn][Mn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[++t]=node(y,cap);</span><br><span class="line">b[t].nxt=head[x];</span><br><span class="line">head[x]=t;</span><br><span class="line">b[++t]=node(x,<span class="number">0</span>);</span><br><span class="line">b[t].nxt=head[y];</span><br><span class="line">head[y]=t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cag</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//二维转化为一维</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,cur;</span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span>(deep));</span><br><span class="line">deep[S]=<span class="number">1</span>;p.push(S);</span><br><span class="line"><span class="keyword">while</span>(!p.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=p.front();p.pop();</span><br><span class="line"><span class="keyword">for</span>(i=head[cur];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;!deep[to])</span><br><span class="line">&#123;</span><br><span class="line">deep[to]=deep[cur]+<span class="number">1</span>;</span><br><span class="line">p.push(to);</span><br><span class="line"><span class="keyword">if</span>(to==T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==T)</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> i,to,cap,res,rest=flow;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i&amp;&amp;rest;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;deep[to]==deep[k]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=Dinic(to,min(rest,cap));</span><br><span class="line"><span class="keyword">if</span>(!res)</span><br><span class="line">deep[to]=<span class="number">0</span>;</span><br><span class="line">b[i].cap-=res;</span><br><span class="line">b[i^<span class="number">1</span>].cap+=res;</span><br><span class="line">rest-=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">int</span> to,cap,flow;</span><br><span class="line"><span class="keyword">int</span> Tx,Ty;</span><br><span class="line">n=read();m=read();</span><br><span class="line">Max=n*m;T=<span class="number">4</span>*Max+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">p[i][<span class="number">0</span>]=p[i][m+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">p[<span class="number">0</span>][i]=p[n+<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">Ans+=cap=read();</span><br><span class="line">add(S,Cag(i,j),cap);<span class="comment">//选文科</span></span><br><span class="line">add(Cag(i,j),Cag(i,j)+Max,INF);<span class="comment">//自己的两个结点相连</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">Ans+=cap=read();</span><br><span class="line">add(Cag(i,j)+Max,T,cap);<span class="comment">//选理科</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">Ans+=cap=read();</span><br><span class="line">to=Cag(i,j)+Max+Max;</span><br><span class="line">add(S,to,cap);</span><br><span class="line">add(to,Cag(i,j),INF);<span class="comment">//别忘了自己</span></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)<span class="comment">//组合</span></span><br><span class="line">&#123;</span><br><span class="line">Tx=i+Cx[k];Ty=j+Cy[k];</span><br><span class="line"><span class="keyword">if</span>(!p[Tx][Ty])</span><br><span class="line">add(to,Cag(Tx,Ty),INF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">Ans+=cap=read();</span><br><span class="line">to=Cag(i,j)+Max+Max+Max;</span><br><span class="line">add(to,T,cap);</span><br><span class="line">add(Cag(i,j)+Max,to,INF);</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line">Tx=i+Cx[k];Ty=j+Cy[k];</span><br><span class="line"><span class="keyword">if</span>(!p[Tx][Ty])</span><br><span class="line">add(Cag(Tx,Ty)+Max,to,INF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(BFS())</span><br><span class="line"><span class="keyword">while</span>((flow=Dinic(S,INF)))</span><br><span class="line">Maxflow+=flow;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,Ans-Maxflow);<span class="comment">//最后还是挺容易的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推荐题目："><a href="#推荐题目：" class="headerlink" title="推荐题目："></a>推荐题目：</h3><p><a href="https://www.luogu.org/problemnew/show/P2057" target="_blank" rel="noopener">Luogu P2057 [SHOI2007]善意的投票</a></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P4987」回文项链 解题报告</title>
      <link href="/2019/03/27/Luogu_P4987-ReverseNecklace-Solution/"/>
      <url>/2019/03/27/Luogu_P4987-ReverseNecklace-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P4987" target="_blank" rel="noopener">题面</a></h2><p>求环中的长度为k（k为奇数）且回文中心不同的回文串个数</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p><del>刚学manacher算法，就送上一道模板题，此题注重对manacher算法的理解</del></p><h3 id="Manacher，但是不用插入其他符号，因为k是奇数，中心一定在字符上"><a href="#Manacher，但是不用插入其他符号，因为k是奇数，中心一定在字符上" class="headerlink" title="Manacher，但是不用插入其他符号，因为k是奇数，中心一定在字符上"></a>Manacher，但是不用插入其他符号，因为k是奇数，中心一定在字符上</h3><p>不知道Manacher？</p><p><a href="https://www.luogu.org/blog/codesonic/manacheralgorithm" target="_blank" rel="noopener">洛谷日报</a>上有讲，但是比较难懂，建议上B站更深入了解下<a href="https://www.bilibili.com/video/av4829276?from=search&amp;seid=12048406571254924464" target="_blank" rel="noopener">$\to$</a></p><p>可以先把代码抄下来，然后一边看讲解一边理解代码含义，这样更能理解</p><p><del>反正我第一遍已经看蒙了</del></p><h2 id="补充和纠正："><a href="#补充和纠正：" class="headerlink" title="补充和纠正："></a>补充和纠正：</h2><p>关于前几篇题解，一些小细节纠正一下</p><p>文末的代码更加简洁易懂</p><p>1、这是一个环，要做Manacher就应该<strong>拆环为链</strong>，第一篇题解说：应该重复复制<strong>三次</strong>（扩展为原来的三倍），但是实际上<strong>两次</strong>（扩展为原来的两倍）就够了</p><p>2、<strong>p</strong>数组（p[i]）表示的是以<strong>i</strong>为中心的最长回文串的半径（包括<strong>i</strong>这个字符），原本的<strong>Manacher算法</strong>因为加入的额外的<code>#</code>号，而是<strong>p[i]</strong>表示的是就是<code>原本最长回文串的长度+1</code>，因此求Ans的时候应该用<code>p[i]-1</code>，但是现在我们不加<code>#</code>号了，<code>p[i]</code>表示的就是<code>以i为中心的最长回文串的半径</code>，此时长度就应该表示为<code>p[i]*2-1</code>，意思是<code>半径*2-回文中心重复计算的字符</code></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010<span class="comment">//N&lt;&lt;1表示长度扩展为原来的两倍</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,p[N&lt;&lt;<span class="number">1</span>],ans,res;</span><br><span class="line"><span class="keyword">char</span> s[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span><span class="comment">//标准的Manacher算法，就是没有加'#'号，而且起点为1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">'?'</span>;</span><br><span class="line">s[<span class="number">2</span>*n+<span class="number">1</span>]=<span class="string">'!'</span>;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>,mx=<span class="number">0</span>;<span class="comment">//id表示目前最长回文串的中心，mx则是右边界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;mx)</span><br><span class="line">p[i]=min(p[<span class="number">2</span>*id-i],mx-i);<span class="comment">//如果中心在mx范围内，用mx去更新p[i]</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]])<span class="comment">//然后暴力</span></span><br><span class="line">p[i]++;</span><br><span class="line"><span class="keyword">if</span>(mx&lt;i+p[i])<span class="comment">//更新mx和id</span></span><br><span class="line">&#123;</span><br><span class="line">id=i;</span><br><span class="line">mx=i+p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//复制</span></span><br><span class="line">s[i+n]=s[i];</span><br><span class="line">manacher();<span class="comment">//跑一遍Manacher</span></span><br><span class="line">res=(k+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;<span class="comment">//表示起始的中心i的位置，这个位置是第一个有可能长度为k的回文串的中心（串s[1-k]的中心）</span></span><br><span class="line"><span class="keyword">for</span>(i=res;i&lt;=res+n<span class="number">-1</span>;i++)<span class="comment">//对于每一个点遍历一次，所以是res+n-1</span></span><br><span class="line"><span class="keyword">if</span>(p[i]*<span class="number">2</span><span class="number">-1</span>&gt;=k)<span class="comment">//真正的长度只要大于等于k就是可以的（大于k的可以把他砍成k啊~）</span></span><br><span class="line">ans++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐题目："><a href="#推荐题目：" class="headerlink" title="推荐题目："></a>推荐题目：</h2><p>一道有趣的黄题   <a href="https://www.luogu.org/problemnew/show/P1210" target="_blank" rel="noopener">P1210 回文检测</a></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P3866」[TJOI2009]战争游戏 解题报告</title>
      <link href="/2019/03/27/Luogu_P3866-%5BTJOI2009%5DWarGame-Solution/"/>
      <url>/2019/03/27/Luogu_P3866-%5BTJOI2009%5DWarGame-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P3866" target="_blank" rel="noopener">题面</a></h2><p>好难表述啊~</p><p>在n*m的矩阵上，有一些大兵（为0），一些空地（一个正整数），障碍物（-1），现在摧毁一些空地，使所有大兵不能走出矩阵去（代价为表示空地的整数），求最小代价</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="网络流最小割"><a href="#网络流最小割" class="headerlink" title="网络流最小割"></a>网络流最小割</h3><p><del>“阻止”，“最小”，看到这样的字眼，肯定就要想到最小割啊</del></p><p>在互相能到达的点之间建边，容量为INF，因为——它不能炸……</p><p>然后把每个点拆成<strong>入点</strong>和<strong>出点</strong>，每个兵所在的出点和<strong>源点S</strong>直接相连，在最外面的点的出点和<strong>汇点T</strong>直接相连</p><p>最后套模板，OK了</p><p>最重要的还是建边，能够理解题目的意思，想出对应的策略</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mn 31</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Cx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//预处理移动的方向</span></span><br><span class="line"><span class="keyword">int</span> Cy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="keyword">int</span> nxt;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cap(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],deep[N],a[Mn][Mn];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,Maxflow,Max,t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> p[Mn][Mn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">p=<span class="number">-1</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Cag</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[++t]=node(y,cap);</span><br><span class="line">b[t].nxt=head[x];</span><br><span class="line">head[x]=t;</span><br><span class="line">b[++t]=node(x,<span class="number">0</span>);</span><br><span class="line">b[t].nxt=head[y];</span><br><span class="line">head[y]=t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Tx,Ty;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">Tx=x+Cx[i];Ty=y+Cy[i];</span><br><span class="line"><span class="keyword">if</span>(p[Tx][Ty])<span class="comment">//边框的用处</span></span><br><span class="line">add(Cag(x,y)+Max,T,INF);<span class="comment">//在矩阵外就和汇点T相连</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">add(Cag(x,y)+Max,Cag(Tx,Ty),INF);<span class="comment">//否则出点和入点相连</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,cur;</span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span>(deep));</span><br><span class="line">p.push(S);deep[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!p.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=p.front();p.pop();</span><br><span class="line"><span class="keyword">for</span>(i=head[cur];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;!deep[to])</span><br><span class="line">&#123;</span><br><span class="line">deep[to]=deep[cur]+<span class="number">1</span>;</span><br><span class="line">p.push(to);</span><br><span class="line"><span class="keyword">if</span>(to==T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==T)</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> i,to,cap,res,rest=flow;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i&amp;&amp;rest;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;deep[to]==deep[k]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=Dinic(to,min(rest,cap));</span><br><span class="line"><span class="keyword">if</span>(!res)</span><br><span class="line">deep[to]=<span class="number">0</span>;</span><br><span class="line">b[i].cap-=res;</span><br><span class="line">b[i^<span class="number">1</span>].cap+=res;</span><br><span class="line">rest-=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,flow;</span><br><span class="line">n=read();m=read();</span><br><span class="line">Max=n*m;T=Max+Max+<span class="number">1</span>;<span class="comment">//汇点T</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//裱个框，方便判断</span></span><br><span class="line">p[i][<span class="number">0</span>]=p[i][m+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">p[<span class="number">0</span>][i]=p[n+<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">a[i][j]=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="number">-1</span>)<span class="comment">//如果是障碍就不建边</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)<span class="comment">//如果是大兵就与源点建边，注意，是出点！否则都要为zero了……</span></span><br><span class="line">add(S,Cag(i,j)+Max,INF);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果是空地，那么在自己的入点和出点之间建边</span></span><br><span class="line">add(Cag(i,j),Cag(i,j)+Max,a[i][j]);<span class="comment">//注意，这里的容量是a[i][j]，就是要炸多少次</span></span><br><span class="line">Add(i,j);<span class="comment">//放个函数里看看能不能和四周相连</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(BFS())<span class="comment">//Dinic模板</span></span><br><span class="line"><span class="keyword">while</span>((flow=Dinic(S,INF)))</span><br><span class="line">Maxflow+=flow;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,Maxflow);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐题目"><a href="#推荐题目" class="headerlink" title="推荐题目"></a>推荐题目</h2><h3 id="Luogu-P2472-SCOI2007-蜥蜴"><a href="#Luogu-P2472-SCOI2007-蜥蜴" class="headerlink" title="Luogu P2472 [SCOI2007]蜥蜴"></a><a href="https://www.luogu.org/problemnew/show/P2472" target="_blank" rel="noopener">Luogu P2472 [SCOI2007]蜥蜴</a></h3><p>有点类似，<del>但很不相同！</del></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P3866」SAC E#1 - 一道难题 Tree 解题报告</title>
      <link href="/2019/03/27/Luogu_P3931-SAC_E#1_-_ADifficultProblem_Tree-Solution/"/>
      <url>/2019/03/27/Luogu_P3931-SAC_E#1_-_ADifficultProblem_Tree-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="圆原题面"><a href="#圆原题面" class="headerlink" title="圆原题面"></a><a href="https://www.luogu.org/problemnew/show/P3931" target="_blank" rel="noopener"><del>圆</del>原题面</a></h2><p>我环顾四周，发现大佬们的写法都好高端！</p><p>比较差劲的我，只能交上一份<strong>DFS</strong>的题解</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="DFS（当然了，其他算法也行）"><a href="#DFS（当然了，其他算法也行）" class="headerlink" title="DFS（当然了，其他算法也行）"></a>DFS（当然了，其他算法也行）</h3><p>要想切断<strong>叶子节点</strong>到<strong>根节点</strong>的连接</p><p>就是在<strong>叶子节点</strong>和<strong>根节点</strong>之间砍掉一条边</p><p>这明显就很符合<strong>DFS</strong>的性质，一条路一直走下去，遇到分枝就分开走</p><p>于是我们DFS每一条路径，然后求答案</p><p>复杂度为<code>O(n)</code></p><h3 id="但是——还没完！"><a href="#但是——还没完！" class="headerlink" title="但是——还没完！"></a>但是——还没完！</h3><p>我们可以发现DFS有三种情况</p><p>1、该节点为叶子节点，此时只能删去连接它和父节点的边</p><p>2、该节点为枝节点，有父节点和子节点，需要选择性的删除</p><p>3、该节点为根节点，只有子节点，只能删去连接它和子节点的边</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cost;</span><br><span class="line"><span class="keyword">int</span> nxt;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cost(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> n,t,r;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cost)</span><span class="comment">//建边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[++t]=node(y,cost);</span><br><span class="line">b[t].nxt=head[x];</span><br><span class="line">head[x]=t;</span><br><span class="line">b[++t]=node(x,cost);</span><br><span class="line">b[t].nxt=head[y];</span><br><span class="line">head[y]=t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i;i=b[i].nxt)</span><br><span class="line"><span class="keyword">if</span>(i!=(in^<span class="number">1</span>))<span class="comment">//成对变换原理，异或值相同但方向相反的边为一组，避免重复</span></span><br><span class="line">res+=Get(b[i].to,i);</span><br><span class="line"><span class="keyword">if</span>(!b[head[k]].nxt&amp;&amp;k!=r)<span class="comment">//确定是叶子节点</span></span><br><span class="line">res=b[in].cost;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">res=min(res,b[in].cost);<span class="comment">//否则两种方法选其一</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> x,y,cost;</span><br><span class="line">n=read();r=read();</span><br><span class="line">t=<span class="number">1</span>;<span class="comment">//初始赋1，利于成对变换</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read();cost=read();</span><br><span class="line">add(x,y,cost);</span><br><span class="line">&#125;</span><br><span class="line">b[<span class="number">0</span>].cost=INF;<span class="comment">//对于根节点的双重保险，防止出什么岔子，比如结果为0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,Get(r,<span class="number">0</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「USACO15FEB」Censoring (Silver) 审查(银) 解题报告</title>
      <link href="/2019/03/27/USACO15FEB-Censoring%20(Silver)-Solution/"/>
      <url>/2019/03/27/USACO15FEB-Censoring%20(Silver)-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P4824" target="_blank" rel="noopener">题面</a></h2><p>就是让你——在字符串A中，如果字符串B是A的子串，那么就删除在A中第一个出现的B，然后拼接在一起，一直重复上述步骤直到B不再是A的子串</p><p>|A|$\le 10^6$</p><hr><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>KMP+栈</p><p>1、由于是两个<strong>字符串匹配</strong>的问题，当然一下子就会想到<strong>KMP</strong></p><p>2、由于是<strong>删去一段区间</strong>，很多人第一反应会想到链表，<strong>但是</strong>在这里，其实删除了一段后，对<strong>之前</strong>是<strong>没有影响</strong>的，并且，一定是<strong>从后往前删除</strong>，所以，更优的存储结构应该是<strong>栈</strong>。</p><p>3、有人会问，为什么删去对前面没有影响，这就根据<strong>KMP</strong>的原理，做到<strong>i</strong>这个位置的结果就是最优的，我们只需要用<strong>f</strong>数组记录一下KMP匹配的结果（f[i]表示以i结尾最大能匹配多长的字符串）。</p><h3 id="如何进行？"><a href="#如何进行？" class="headerlink" title="如何进行？"></a>如何进行？</h3><p>1、<strong>KMP板子</strong>跑一遍</p><p>2、在KMP过程中，把遍历到的<strong>i</strong>（不是字符，而是下标）入栈，当匹配到一个完整的串时，把这一整串出栈，然后<strong>j</strong>从栈顶的<strong>i</strong>所能<strong>匹配到的最大的位置</strong>开始（就是f[i]记录的值），继续做KMP</p><p>时间复杂度：B自身匹配一次+A与B匹配一次+A中最多每个字符进出栈一次，这么说来时间复杂度还是<strong>线性</strong>的</p><hr><p>于是，代码就很好构造了</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> la,lb,res;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> p[N],f[N];<span class="comment">//分别表示B串自身匹配的结果、A串与B串匹配的结果</span></span><br><span class="line"><span class="keyword">int</span> St[N],top;<span class="comment">//模拟栈，STL的栈也是可以的，就是比较低效</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,b+<span class="number">1</span>);</span><br><span class="line">la=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">lb=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=lb;i++)<span class="comment">//自身匹配</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;b[i]!=b[j+<span class="number">1</span>])</span><br><span class="line">j=p[j];</span><br><span class="line"><span class="keyword">if</span>(b[i]==b[j+<span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line">p[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=la;i++)<span class="comment">//A与B匹配</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;a[i]!=b[j+<span class="number">1</span>])</span><br><span class="line">j=p[j];</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j+<span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line">f[i]=j;<span class="comment">//记录结果</span></span><br><span class="line">St[++top]=i;<span class="comment">//入栈</span></span><br><span class="line"><span class="keyword">if</span>(j==lb)<span class="comment">//如果匹配成功</span></span><br><span class="line">&#123;</span><br><span class="line">res=lb;</span><br><span class="line"><span class="keyword">while</span>(res)<span class="comment">//出栈，res记录应该出多少字符</span></span><br><span class="line">res--,top--;</span><br><span class="line">j=f[St[top]];<span class="comment">//更新j值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=top;i++)<span class="comment">//大功率输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,a[St[i]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推荐题目："><a href="#推荐题目：" class="headerlink" title="推荐题目："></a>推荐题目：</h3><p><a href="https://www.luogu.org/problemnew/show/P3121" target="_blank" rel="noopener">Luogu P3121 [USACO15FEB]审查（黄金）Censoring (Gold)</a> <del>似乎这俩是一对？！</del></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「USACO08JAN」电话线Telephone Lines 解题报告</title>
      <link href="/2019/03/27/USACO08JAN-Telephone_Lines-Solution/"/>
      <url>/2019/03/27/USACO08JAN-Telephone_Lines-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P1948" target="_blank" rel="noopener">题面</a></h2><p>大意：在加权无向图上求出一条从 $1$ 号结点到 $N$ 号结点的路径，使路径上第 $K + 1$ 大的边权尽量小。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>由于我们只能直接求最短路，不能记录过程中的具体的边——那样会特别麻烦</p><p>所以，我们就尝试着去想更优的办法</p><p>题目中所说，能够免去 $K$ 条边的费用，那么对于要建设的边中，肯定免去费用最大 $K $ 条边更优</p><p>我们关注的应该是第 $K+1$ 大边的<strong>边权</strong>，因为<strong>其他</strong>边权大于<strong>这条边</strong>边权的边都会被略去</p><h3 id="这条边可以枚举吗？"><a href="#这条边可以枚举吗？" class="headerlink" title="这条边可以枚举吗？"></a>这条边可以枚举吗？</h3><p>似乎不行，枚举的复杂度还要在最短路的基础上，乘上一个 $M$ ，不就TLE<del>（Time Limit Enough）</del>了吗……</p><h3 id="那么——对于这个边的边权，能不能二分呢？"><a href="#那么——对于这个边的边权，能不能二分呢？" class="headerlink" title="那么——对于这个边的边权，能不能二分呢？"></a>那么——对于这个边的<strong>边权</strong>，能不能<strong>二分</strong>呢？</h3><p>首先，二分需要满足<strong>单调性</strong></p><p>题目中，这条第 $K+1$ 大的边<strong>边权</strong>越小，能够满足的情况越少，反之亦然</p><p>因此我们可以使用二分的方法来查找答案</p><h3 id="怎么判断满足或不满足"><a href="#怎么判断满足或不满足" class="headerlink" title="怎么判断满足或不满足"></a>怎么判断满足或不满足</h3><p>对于边权大于 $mid$ 的边，我们改变它的边权为1，否则为0，然后再跑最短路，这样得出来的结果应该是从 $1$ 号结点到 $N $ 号结点至少要有几条大于 $mid$ 的边，然后与 $K$ 比较，小于 $K$ 则满足，否则不满足</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cost;</span><br><span class="line"><span class="keyword">int</span> nxt;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cost(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],d[N],vis[N];</span><br><span class="line"><span class="keyword">int</span> n,m,res,t,ans=INF;<span class="comment">//初值一样要为INF</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cost)</span><span class="comment">//建边，正反一起</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[++t]=node(y,cost);</span><br><span class="line">b[t].nxt=head[x];</span><br><span class="line">head[x]=t;</span><br><span class="line">b[++t]=node(x,cost);</span><br><span class="line">b[t].nxt=head[y];</span><br><span class="line">head[y]=t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//好吧，这里不算严格的最短路，因为边权变成了0和1，可以直接宽搜搞定，但是下面的程序，</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//明明是一个真SPFA，假宽搜</span></span><br><span class="line"><span class="keyword">int</span> i,to,cur,cost;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i]=INF;</span><br><span class="line">vis[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line">p.push(<span class="number">1</span>);</span><br><span class="line">vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!p.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=p.front();p.pop();</span><br><span class="line">vis[cur]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=head[cur];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line">cost=d[cur]+(b[i].cost&gt;k);<span class="comment">//处理边权</span></span><br><span class="line"><span class="keyword">if</span>(cost&lt;d[to])</span><br><span class="line">&#123;</span><br><span class="line">d[to]=cost;</span><br><span class="line"><span class="keyword">if</span>(!vis[to])</span><br><span class="line">&#123;</span><br><span class="line">vis[to]=<span class="number">1</span>;</span><br><span class="line">p.push(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(d[n]&lt;=res)<span class="comment">//判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> x,y,cost;</span><br><span class="line"><span class="keyword">int</span> l,r,mid;</span><br><span class="line">n=read();m=read();res=read();</span><br><span class="line">l=r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read();cost=read();</span><br><span class="line">add(x,y,cost);<span class="comment">//建边，注意是双向的</span></span><br><span class="line">r=max(r,cost);<span class="comment">//r的上限，可以自己赋为1e6，这是题目中给的最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(BFS(mid))<span class="comment">//判断</span></span><br><span class="line">&#123;</span><br><span class="line">ans=mid;</span><br><span class="line">r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==INF)<span class="comment">//初值应该为INF，不能为0，因为有可能电信公司比较大方，免费之类的——给我多好</span></span><br><span class="line">ans=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另外提供一个比较high的评测"><a href="#另外提供一个比较high的评测" class="headerlink" title="另外提供一个比较high的评测"></a><a href="https://loj.ac/problem/10074" target="_blank" rel="noopener">另外提供一个比较high的评测</a></h3><p>在洛谷过了，这里不一定过哦！</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「USACO4.4」追查坏牛奶Pollutant Control 解题报告</title>
      <link href="/2019/03/27/USACO4.4-Pollutant_Control-Solution/"/>
      <url>/2019/03/27/USACO4.4-Pollutant_Control-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P1344" target="_blank" rel="noopener">题面</a></h2><p>求最小割，并且在最小割的情况下求出最少要删去几条边</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="当然是最小割咯！"><a href="#当然是最小割咯！" class="headerlink" title="当然是最小割咯！"></a>当然是最小割咯！</h3><p>就是后一问不大好求</p><p><del>那怎么办呢？ 似乎很复杂的样子</del></p><p>或许我们要在模板里改比较困难</p><p>那么我们就想办法在边上做学问</p><p>比如我们可不可以把边的容量<strong>全部加1</strong>呢？</p><p>有人问：这样最小割不就是不一样了吗？</p><p>但是细想一下可以发现：其实在加1的情况下，原来的最小割确实变了，但是<strong>增大了多少</strong>就等于<strong>最少要删去的边数</strong></p><p>因为对于每条边，容量又多了一个1，在最小割的前提下，肯定是删去越少的边数的情况更优</p><p>举个栗子：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_%e6%9c%80%e5%b0%8f%e5%89%b2.png" alt></p><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_%e6%9c%80%e5%b0%8f%e5%89%b22.png" alt></p><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_%e6%9c%80%e5%b0%8f%e5%89%b23.png" alt></p><p><del>强迫症，这图画了我半天</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="keyword">int</span> nxt;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cap(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],deep[N];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,t=<span class="number">1</span>,Maxflow,Ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[++t]=node(y,cap);</span><br><span class="line">b[t].nxt=head[x];</span><br><span class="line">head[x]=t;</span><br><span class="line">b[++t]=node(x,<span class="number">0</span>);</span><br><span class="line">b[t].nxt=head[y];</span><br><span class="line">head[y]=t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,cur;</span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span>(deep));</span><br><span class="line">deep[S]=<span class="number">1</span>;p.push(S);</span><br><span class="line"><span class="keyword">while</span>(!p.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=p.front();p.pop();</span><br><span class="line"><span class="keyword">for</span>(i=head[cur];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;!deep[to])</span><br><span class="line">&#123;</span><br><span class="line">deep[to]=deep[cur]+<span class="number">1</span>;</span><br><span class="line">p.push(to);</span><br><span class="line"><span class="keyword">if</span>(to==T)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==T)</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> i,to,cap,res,rest=flow;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i&amp;&amp;rest;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;deep[to]==deep[k]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=Dinic(to,min(rest,cap));</span><br><span class="line"><span class="keyword">if</span>(!res)</span><br><span class="line">deep[to]=<span class="number">0</span>;</span><br><span class="line">b[i].cap-=res;</span><br><span class="line">b[i^<span class="number">1</span>].cap+=res;</span><br><span class="line">rest-=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,flow;</span><br><span class="line"><span class="keyword">int</span> x,y,cap;</span><br><span class="line">n=read();m=read();</span><br><span class="line">S=<span class="number">1</span>;T=n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read();cap=read();</span><br><span class="line">add(x,y,cap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(BFS())<span class="comment">//先求最小割</span></span><br><span class="line"><span class="keyword">while</span>((flow=Dinic(S,INF)))</span><br><span class="line">Maxflow+=flow;</span><br><span class="line"><span class="keyword">while</span>(BFS())</span><br><span class="line"><span class="keyword">while</span>((flow=Dinic(S,INF)))</span><br><span class="line">Maxflow+=flow;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=t;i+=<span class="number">2</span>)<span class="comment">//改变边</span></span><br><span class="line">b[i].cap+=b[i^<span class="number">1</span>].cap+<span class="number">1</span>,b[i^<span class="number">1</span>].cap=<span class="number">0</span>;<span class="comment">//初始正边并1，反边还是赋0</span></span><br><span class="line"><span class="keyword">while</span>(BFS())<span class="comment">//再跑一次</span></span><br><span class="line"><span class="keyword">while</span>((flow=Dinic(S,INF)))</span><br><span class="line">Ans+=flow;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,Maxflow,Ans-Maxflow);<span class="comment">//一次性输出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「UVA10810」Ultra-QuickSort 解题报告</title>
      <link href="/2019/03/27/UVA10810-Ultra-QuickSort-Solution/"/>
      <url>/2019/03/27/UVA10810-Ultra-QuickSort-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/UVA10810#sub" target="_blank" rel="noopener">题面</a></h2><p><del>看不懂？！</del>  </p><h4 id="大概的意思就是："><a href="#大概的意思就是：" class="headerlink" title="大概的意思就是："></a>大概的意思就是：</h4><p>给出一个长度为n的序列，然后每次只能交换相邻的两个数，问最小需要几次使序列<strong>严格上升</strong> </p><p>不断读入n，直到n=0结束  </p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>交换相邻的两个数，这不就类似冒泡排序吗？但是<strong>n&lt;500000</strong>  </p><p><del>算了吧，我回去颓A+B</del> </p><p>于是我们就发现用<strong>冒泡排序</strong>直接<strong>计算次数</strong>是行不通的  </p><p>但我们要知道：  </p><p>冒泡排序的<strong>交换次数</strong>就是序列的<strong>逆序对数</strong>！！！  </p><p>所以——<del>就简单了吧</del>~  </p><h3 id="如何求逆序对？"><a href="#如何求逆序对？" class="headerlink" title="如何求逆序对？"></a>如何求逆序对？</h3><p><a href="https://www.luogu.org/problemnew/show/P1908" target="_blank" rel="noopener">较easy版的逆序对</a>  </p><p>1、归并排序  </p><p>思想是分治法  </p><p>不断划分为两小段  </p><p>然后依次由小序列合并为大序列，同时求出逆序数</p><p>2、树状数组</p><p>因为树状数组的修改查询是log级的所以可以使用（前缀和的方法），没学的建议先去学习一下，不是很难</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,i;</span><br><span class="line">&#125;a[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">500010</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;x&lt;=n;x+=x&amp;(-x))</span><br><span class="line">f[x]++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//求前缀和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;x;x-=x&amp;(-x))</span><br><span class="line">res+=f[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].x=read();</span><br><span class="line">a[i].i=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//先hash一下,按数值给其标记，方便后面求逆序对</span></span><br><span class="line">b[a[i].i]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">update(b[i]);<span class="comment">//一步一做</span></span><br><span class="line">ans+=sum(b[i]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">n=read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P3395」路障 解题报告</title>
      <link href="/2019/03/27/Luogu_P3395-Barricades-Solution/"/>
      <url>/2019/03/27/Luogu_P3395-Barricades-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="点开有惊喜"><a href="#点开有惊喜" class="headerlink" title="点开有惊喜"></a><a href="https://www.luogu.org/problemnew/show/P3395" target="_blank" rel="noopener">点开有惊喜</a></h2><p><del>其实是题面</del>  </p><p>这D1T1给的很有面子！  <del>我居然做的来！</del></p><p>从<strong>左上角</strong>走到<strong>右上角</strong>  </p><p>然后n&lt;=1000  </p><p>所以果断放弃<strong>DFS</strong>，选择<strong>BFS</strong>  </p><p>思路还是一样的BFS</p><h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><p>走到一个点的时间越早越好（因为时间越晚能走到的点越少，路障多了）  </p><p>所以用<strong>BFS</strong>，走过的点不用再次走，用 <strong>vis</strong>数组记录已经是否遍历过  </p><p>然后为了防止跑出棋盘去（B君看到了棋盘外美铝？！）  </p><p>我们就给棋盘加一个 <strong>‘1’</strong>的边框，这样就不会出去  </p><p>然后还要记录一个时间<strong>t</strong>、<strong>x</strong>、<strong>y</strong>，可以用一个结构体 </p><p>构造用</p><blockquote><p>struct node{</p><p>​    int x,y,t;</p><p>​    node(int a,int b,int c):x(a),y(b),t(c) {    }</p><p>​    node(){}</p><p>};</p><p>node(x,y,t)//直接构造</p></blockquote><p>但是本菜还是比较喜欢用两个queue  </p><p>一个存pair(x,t)，一个存y  </p><p>贴上：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Cx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//四个方向，八个方向也一样</span></span><br><span class="line"><span class="keyword">int</span> Cy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;<span class="comment">//在下有强迫症，所以用两个数组</span></span><br><span class="line"><span class="keyword">int</span> n,T;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,t;</span><br><span class="line"><span class="keyword">int</span> Tx,Ty;</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;px;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;py;</span><br><span class="line"><span class="keyword">while</span>(!py.empty())</span><br><span class="line">px.pop(),py.pop();</span><br><span class="line">px.push(make_pair(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">py.push(<span class="number">1</span>);</span><br><span class="line">vis[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!px.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=px.front().first;</span><br><span class="line">t=px.front().second;px.pop();</span><br><span class="line">y=py.front();py.pop();</span><br><span class="line"><span class="keyword">if</span>(x==n&amp;&amp;y==n)<span class="comment">//有了这句就不用特判n=1的情况了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">Tx=x+Cx[i];</span><br><span class="line">Ty=y+Cy[i];</span><br><span class="line"><span class="keyword">if</span>(!vis[Tx][Ty]&amp;&amp;t&lt;=b[Tx][Ty])</span><br><span class="line">&#123;</span><br><span class="line">vis[Tx][Ty]=<span class="number">1</span>;</span><br><span class="line">px.push(make_pair(Tx,t+<span class="number">1</span>));</span><br><span class="line">py.push(Ty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">T=read();</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line">n=read();</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(b,INF,<span class="keyword">sizeof</span>(b));<span class="comment">//一开始赋无穷大比较方便</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//裱框</span></span><br><span class="line">vis[i][<span class="number">0</span>]=vis[<span class="number">0</span>][i]=vis[n+<span class="number">1</span>][i]=vis[i][n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read();</span><br><span class="line">b[x][y]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(BFS())<span class="comment">//此处纪念ydk大佬把"Yes"打成"YES"，本蒟瑟瑟发抖</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P3183」[HAOI2016]食物链 解题报告</title>
      <link href="/2019/03/27/Luogu_P3183-%5BHAOI2016%5DFoodLink-Solution/"/>
      <url>/2019/03/27/Luogu_P3183-%5BHAOI2016%5DFoodLink-Solution/</url>
      
        <content type="html"><![CDATA[<p>身为一个蒟蒻，由于刷不过<a href="https://www.luogu.org/problemnew/show/P2024" target="_blank" rel="noopener">[NOI2001]食物链</a></p><p>于是出门左转写了道另一道<del>假的</del>食物链 <a href="https://www.luogu.org/problemnew/show/P3183" target="_blank" rel="noopener">戳这里</a>  </p><p>这里的食物链<del>个</del>条数其实就是有向图的路径数 （应该是这么说吧，我弱）  </p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="拓扑-Topulogy-（一本正经的话说八道）-宽搜-乱搞-（由于本人很弱，所以想不出来了）……"><a href="#拓扑-Topulogy-（一本正经的话说八道）-宽搜-乱搞-（由于本人很弱，所以想不出来了）……" class="headerlink" title="拓扑(Topulogy)（一本正经的话说八道）+宽搜+乱搞+（由于本人很弱，所以想不出来了）……"></a>拓扑<del>(Topulogy)（一本正经的话说八道）</del>+宽搜+乱搞+（由于本人很弱，所以想不出来了）……</h3><p>不用先求拓扑序  </p><p>一边遍历一边用 f数组 统计路径数  </p><p>存个图，然后队列遍历，要注意的是<strong>单独的一个点不算一条链</strong>  </p><p>所以就第一遍把<strong>单独的点</strong>处理出去（不进队列）  </p><p>最后的问题就是累加了  </p><p>如果这个点<strong>出度为0</strong>时，就</p><blockquote><p>ans+= f[to]</p></blockquote><p>否则更新f[to]，并再次把to入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;b[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> n,t,T;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//建边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b[++t].to=y;</span><br><span class="line">b[t].nxt=head[x];</span><br><span class="line">head[x]=t;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Topulogy</span><span class="params">()</span><span class="comment">//假的拓扑（英语不好）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> cur,to;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始化入度为0的点（不包括单独的点）</span></span><br><span class="line"><span class="keyword">if</span>(!d[i]&amp;&amp;head[i])<span class="comment">//分别判断入度为0和是否是单独的点</span></span><br><span class="line">&#123;</span><br><span class="line">f[i]=<span class="number">1</span>;<span class="comment">//初始化路径数，否则会都是0哦~</span></span><br><span class="line">p.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!p.empty())</span><br><span class="line">&#123;</span><br><span class="line">cur=p.front();p.pop();</span><br><span class="line"><span class="keyword">for</span>(i=head[cur];i;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;</span><br><span class="line">d[to]--;</span><br><span class="line">f[to]+=f[cur];</span><br><span class="line"><span class="keyword">if</span>(d[to]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!head[to])</span><br><span class="line">ans+=f[to];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p.push(to);<span class="comment">//只有入度为0且出度不为0时才入队</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">n=read();T=read();</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read();</span><br><span class="line">add(x,y);<span class="comment">//建边</span></span><br><span class="line">d[y]++;<span class="comment">//入度</span></span><br><span class="line">&#125;</span><br><span class="line">Topulogy();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P2508」[HAOI2008]圆上的整点 解题报告</title>
      <link href="/2019/03/27/Luogu_P2508-%5BHAOI2008%5DCirclePoint-Solution/"/>
      <url>/2019/03/27/Luogu_P2508-%5BHAOI2008%5DCirclePoint-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P2508" target="_blank" rel="noopener">题面</a></h2><h3 id="给定圆的半径，求圆上整点数"><a href="#给定圆的半径，求圆上整点数" class="headerlink" title="给定圆的半径，求圆上整点数"></a>给定圆的半径，求圆上整点数</h3><h3 id="这是一道很Nice的数学题！超爱！好吧，由于这道题，我去Study了一下复数-complex-number-复杂的数"><a href="#这是一道很Nice的数学题！超爱！好吧，由于这道题，我去Study了一下复数-complex-number-复杂的数" class="headerlink" title="这是一道很Nice的数学题！超爱！好吧，由于这道题，我去Study了一下复数(complex number)复杂的数"></a>这是一道很Nice的数学题！超爱！好吧，由于这道题，我去Study了一下复数(complex number)<del>复杂的数</del></h3><h3 id="真棒！！！"><a href="#真棒！！！" class="headerlink" title="真棒！！！"></a>真棒！！！</h3><h3 id="有兴趣的戳这里！！！-huge-to"><a href="#有兴趣的戳这里！！！-huge-to" class="headerlink" title="有兴趣的戳这里！！！$\huge \to$"></a>有兴趣的戳这里！！！<a href="https://www.bilibili.com/video/av12131743/" target="_blank" rel="noopener">$\huge \to$</a></h3><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>高斯素数的原理，将整数分解质因数后，再把每个质因数分解成高斯素数，对于质数<code>4n+1</code>，它可以有效的分解成高斯素数，而质数<code>4n+3</code>不能，因为3<strong>无法</strong>分解为<strong>高斯素数</strong>，所以当一个数有奇数个3因子时，这个圆上没有整点，而3的个数为偶数时，由于能分成两组配对，所以有整点，但3对Ans的影响为0，因为<code>x*1=x</code>，因此只要不变就行了，当由于2的高斯素数表示为<code>1-i</code>*<code>1+i</code>，所以2的个数对Ans无影响</p><p>对于25如下：</p><blockquote><p>$$<br>\large 25=5 \times 5<br>$$</p><p>$$<br>\large 25=(2-i)(2+i)(2-i)(2+i)<br>$$</p><p>所以：</p><table><thead><tr><th style="text-align:center">Left</th><th style="text-align:center">Right</th></tr></thead><tbody><tr><td style="text-align:center">$\large 1$</td><td style="text-align:center">$\large 1$</td></tr><tr><td style="text-align:center">$\large 2-i$</td><td style="text-align:center">$\large 2+i$</td></tr><tr><td style="text-align:center">$\large 2-i$</td><td style="text-align:center">$\large 2+i$</td></tr><tr><td style="text-align:center">$\large =3-4i$</td><td style="text-align:center">$\large =3+4i$</td></tr></tbody></table><p>这是一种情况$\large (3,-4)$</p><table><thead><tr><th style="text-align:center">Left</th><th style="text-align:center">Right</th></tr></thead><tbody><tr><td style="text-align:center">$\large 2-i$</td><td style="text-align:center">$\large 2-i$</td></tr><tr><td style="text-align:center">$\large 2+i$</td><td style="text-align:center">$\large 2+i$</td></tr><tr><td style="text-align:center">$\large =5$</td><td style="text-align:center">$\large =5$</td></tr></tbody></table><p>这是一种情况$\large (5,0)$</p><table><thead><tr><th style="text-align:center">Left</th><th style="text-align:center">Right</th></tr></thead><tbody><tr><td style="text-align:center">$\large 2+i$</td><td style="text-align:center">$\large 2+i$</td></tr><tr><td style="text-align:center">$\large 2+i$</td><td style="text-align:center">$\large 2+i$</td></tr><tr><td style="text-align:center">$\large =3+4i$</td><td style="text-align:center">$\large =3-4i$</td></tr></tbody></table><p>这是一种情况$\large (3,-4)$</p></blockquote><blockquote><p>而对于上述</p><table><thead><tr><th style="text-align:center">$\large \times$</th><th style="text-align:center">$\large 3-4i$</th><th style="text-align:center">$\large 5$</th><th style="text-align:center">$\large 3+4i$</th></tr></thead><tbody><tr><td style="text-align:center">$\large -1$</td><td style="text-align:center">$\large -1+4i$</td><td style="text-align:center">$-5$</td><td style="text-align:center">$\large -3-4i$</td></tr><tr><td style="text-align:center">$\large i$</td><td style="text-align:center">$\large 4+3i$</td><td style="text-align:center">$\large 5i$</td><td style="text-align:center">$\large -4+3i$</td></tr><tr><td style="text-align:center">$\large -i$</td><td style="text-align:center">$\large -4-3i$</td><td style="text-align:center">$\large -5i$</td><td style="text-align:center">$\large 4-3i$</td></tr></tbody></table><p>所以一共有点对<strong>12</strong>对</p></blockquote><h3 id="那么高斯素数怎么表示点呢？"><a href="#那么高斯素数怎么表示点呢？" class="headerlink" title="那么高斯素数怎么表示点呢？"></a>那么高斯素数怎么表示点呢？</h3><p>它只要一个数，就可以表示点的坐标，RT：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_K[B_22PQSQJ[L0LBICFQDMD.png" alt></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n,m,res,ans=<span class="number">4</span>;</span><br><span class="line">ll a[N],t,T;</span><br><span class="line">ll p[N];</span><br><span class="line">ll s[N];</span><br><span class="line"><span class="keyword">bool</span> b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll i,j;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">m=n;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!b[i])</span><br><span class="line">&#123;</span><br><span class="line">a[++T]=i;</span><br><span class="line"><span class="keyword">if</span>(m%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[++t]=i;</span><br><span class="line"><span class="keyword">while</span>(m%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">m/=i;</span><br><span class="line">s[t]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=T;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]*i*i*a[j]&gt;m)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">b[a[j]*i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%a[j]==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p[++t]=m;</span><br><span class="line">s[t]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line"><span class="keyword">if</span>((p[i]<span class="number">-1</span>)%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">ans*=(<span class="number">2</span>*s[i]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P2278」[HNOI2003]操作系统 解题报告</title>
      <link href="/2019/03/27/Luogu_P2278-%5BHNOI2003%5DTheOperatingSystem-Solution/"/>
      <url>/2019/03/27/Luogu_P2278-%5BHNOI2003%5DTheOperatingSystem-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P2278" target="_blank" rel="noopener">题面</a></h2><p>一道模拟题，模拟CPU的处理过程？！<del>省选模拟题</del></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="模拟退火大法-优先队列乱搞"><a href="#模拟退火大法-优先队列乱搞" class="headerlink" title="模拟退火大法+优先队列乱搞"></a>模拟<del>退火</del>大法+优先队列乱搞</h3><h3 id="要注意的点"><a href="#要注意的点" class="headerlink" title="要注意的点"></a>要注意的点</h3><p>1、空闲时，CPU要处理进程</p><p>2、当队列中没有进程时，要先进行判断，然后访问</p><p>3、当优先级高的进程替换掉原进程时，原进程已经处理过的时间要减去</p><p>4、结束进程时要更新后面进程的时间</p><p>既然是模拟题，那就不讲具体了<del>h^ovny：我懒</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i,S,l,p;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d):i(a),S(b),l(c),p(d)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node X) <span class="keyword">const</span>&#123;<span class="comment">//重载</span></span><br><span class="line"><span class="keyword">if</span>(p!=X.p)</span><br><span class="line"><span class="keyword">return</span> p&lt;X.p;</span><br><span class="line"><span class="keyword">return</span> S&gt;X.S;</span><br><span class="line">&#125;</span><br><span class="line">&#125;Now,cur;<span class="comment">//Now表示当前处理的进程</span></span><br><span class="line"><span class="keyword">int</span> i,S,l,p;</span><br><span class="line">priority_queue&lt;node&gt;P;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;i,&amp;S,&amp;l,&amp;p);<span class="comment">//预先读入一组</span></span><br><span class="line">Now=node(i,S,l,p);</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;i,&amp;S,&amp;l,&amp;p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(Now.S+Now.l&lt;=S&amp;&amp;!P.empty())<span class="comment">//中间空闲时间先处理掉</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Now.i,Now.S+Now.l);</span><br><span class="line">cur=P.top();P.pop();</span><br><span class="line"><span class="keyword">if</span>(cur.S&lt;Now.S+Now.l)<span class="comment">//计算影响</span></span><br><span class="line">cur.l+=Now.S+Now.l-cur.S;</span><br><span class="line">Now=cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Now.S+Now.l&lt;=S)<span class="comment">//如果队列空了，Now就没有输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Now.i,Now.S+Now.l);</span><br><span class="line">Now=node(i,S,l,p);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p&gt;Now.p)<span class="comment">//更高级的任务</span></span><br><span class="line">&#123;</span><br><span class="line">Now.l=Now.l+Now.S-S;</span><br><span class="line">P.push(Now);</span><br><span class="line">Now=node(i,S,l,p);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">P.push(node(i,S,l,p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Now.i,Now.S+Now.l);<span class="comment">//队列中还有进程，但Now无法被更新</span></span><br><span class="line"><span class="keyword">while</span>(!P.empty())<span class="comment">//弹出队列中的进程</span></span><br><span class="line">&#123;</span><br><span class="line">cur=P.top();P.pop();</span><br><span class="line"><span class="keyword">if</span>(cur.S&lt;Now.S+Now.l)<span class="comment">//前面进程对当前的影响</span></span><br><span class="line">cur.l+=Now.l+Now.S-cur.S;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,cur.i,cur.S+cur.l);</span><br><span class="line">Now=cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P2201」数列编辑器 解题报告</title>
      <link href="/2019/03/27/Luogu_P2201-TheArrayEditor-Solution/"/>
      <url>/2019/03/27/Luogu_P2201-TheArrayEditor-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="数列编辑器，在线IDE"><a href="#数列编辑器，在线IDE" class="headerlink" title="数列编辑器，在线IDE"></a><a href="https://www.luogu.org/problemnew/show/P2201" target="_blank" rel="noopener">数列编辑器</a>，在线IDE</h2><p><del>本期的主题是你谷的在线IDE</del>  </p><p>小学生？！小学生虐我 :cry:  </p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>怎么说<strong>链表</strong>也是可以的吧，虽然比较繁琐  </p><p>然后涉及到了<strong>前缀和</strong>和一些优化<strong>手段</strong>（应该可以说是记忆化吧）？  </p><p>用p记录光标的位置  </p><p>虽然这道题的数据范围挺大的$(1~1,000,000)$</p><p>但是题目中说，k一定在p之前   </p><p>所以实际上只有<strong>p前面的序列</strong>是有效的  </p><p>于是我们就可以写一个<strong>半在线半离线</strong>的算法  </p><p>用<strong>链表模拟数列</strong>  </p><p>当然了，<strong>不用按照顺序</strong>，我们只用把数字存一下，然后顺序什么的一切靠链表解决  </p><p>用 <strong>f</strong>数组 存i点（这里的i不是数列中的顺序，而是实际读入的顺序，下同，具体见代码）的最大前缀和，这样就可以直接查询  </p><p>用 <strong>s</strong>数组 存i点的前缀和，方便更新<strong>f</strong>数组  </p><p>然后用 <strong>ord</strong>数组 记录一下每个数在数列中的编号（不是实际的编号，有点类似hash的样子）  </p><p>每接受一个操作就做一次更新  </p><p>代码如下：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> f,t;<span class="comment">//f表示前驱，t表示后继（由于本菜鸟不喜欢front和next……请谅解~）</span></span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line">&#125;b[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> T,t,p,n;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> ord[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span><span class="comment">//有负数，快读不要忘记符号的问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">p=<span class="number">-1</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">T=read();</span><br><span class="line">f[<span class="number">0</span>]=-INF;<span class="comment">//因为有负数嘛，所以一开始前缀和的最大值应该是一个极小数</span></span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c!=<span class="string">'I'</span>&amp;&amp;c!=<span class="string">'D'</span>&amp;&amp;c!=<span class="string">'L'</span>&amp;&amp;c!=<span class="string">'R'</span>&amp;&amp;c!=<span class="string">'Q'</span>)</span><br><span class="line">c=getchar();<span class="comment">//getchar()比较快（优化后还有更快的），写c=='\n'||c=='\r'||c==' '，关系也不大</span></span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'I'</span>)</span><br><span class="line">&#123;</span><br><span class="line">b[++t].s=read();</span><br><span class="line">b[t].f=p;</span><br><span class="line">b[b[p].t].f=t;</span><br><span class="line">b[t].t=b[p].t;</span><br><span class="line">b[p].t=t;</span><br><span class="line">s[t]=s[p]+b[t].s;<span class="comment">//插入节点</span></span><br><span class="line">f[t]=max(f[p],s[t]);<span class="comment">//更新当前的前缀和最大值</span></span><br><span class="line">p=t;<span class="comment">//更新光标位置</span></span><br><span class="line">ord[++n]=p;<span class="comment">//加入有价值的数列，并hash一下编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'D'</span>)</span><br><span class="line">&#123;</span><br><span class="line">b[b[p].t].f=b[p].f;</span><br><span class="line">b[b[p].f].t=b[p].t;<span class="comment">//删除节点</span></span><br><span class="line">p=b[p].f;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'L'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p=b[p].f;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'R'</span>)</span><br><span class="line">&#123;</span><br><span class="line">s[b[p].t]=s[p]+b[b[p].t].s;</span><br><span class="line">f[b[p].t]=max(f[p],s[b[p].t]);</span><br><span class="line">p=b[p].t;</span><br><span class="line">ord[++n]=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'Q'</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[ord[read()]]);<span class="comment">//这里可以好好理解一下</span></span><br><span class="line">&#125;<span class="comment">//其实这里的五个操作可以合并起来写，放在函数里，然后可以调用</span></span><br><span class="line">     <span class="comment">//比如说在'I'的操作里，可以看成是插入一个节点，然后在右移光标一位 这两步</span></span><br><span class="line">     <span class="comment">//比较方便（其实也没方便多少）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再支持一下Luogu的</p><p><strong>在线IDE！</strong></p><p>极大解决Linux系统和Windows系统造成的差异问题，那些<del>恶心</del>优秀的字符类模拟题就再也不用方了</p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P2015」二叉苹果树 解题报告</title>
      <link href="/2019/03/27/Luogu_P2015-BinaryAppleTree-Solution/"/>
      <url>/2019/03/27/Luogu_P2015-BinaryAppleTree-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P2015" target="_blank" rel="noopener">题面</a></h2><p>一个二叉树，边数为n$(2&lt;n\le 100)​$，每条边有一个权值，求剪枝后剩下p$(1&lt;p&lt;n)​$条边，使p条边的权值和最大</p><p>还看不懂？……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>   <span class="number">5</span>input:<span class="number">5</span> <span class="number">2</span>output:<span class="number">21</span></span><br><span class="line"> \ /<span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">4</span><span class="number">1</span> <span class="number">4</span> <span class="number">10</span></span><br><span class="line">   \ /<span class="number">2</span> <span class="number">3</span> <span class="number">20</span></span><br><span class="line">    <span class="number">1</span><span class="number">3</span> <span class="number">5</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>能理解了吧！</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="树形打屁DP"><a href="#树形打屁DP" class="headerlink" title="树形打屁DP"></a>树形<del>打屁</del>DP</h3><p>很基础的一道树形DP</p><p>对于每个点，用<code>f[k][i]</code>记录在以<code>k</code>为根的子树中，取<code>i</code>条枝的最大值</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>1、要注意叶子节点的判断</p><p>2、有可能只取一侧的子树</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> b[N][<span class="number">5</span>],s[N];</span><br><span class="line"><span class="keyword">int</span> n,p;</span><br><span class="line"><span class="keyword">int</span> a[N][N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s[k]==<span class="number">1</span>)<span class="comment">//叶子节点直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> l,r,value;</span><br><span class="line">l=r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=s[k];i++)<span class="comment">//把l儿子和r儿子处理出来，其实不用严格区分l和r，因为效果是一样的</span></span><br><span class="line"><span class="keyword">if</span>(b[k][i]!=fa)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!l)</span><br><span class="line">l=b[k][i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r=b[k][i];</span><br><span class="line">&#125;</span><br><span class="line">DFS(l,k);DFS(r,k);</span><br><span class="line">f[k][<span class="number">1</span>]=max(a[k][l],a[k][r]);<span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=p<span class="number">-2</span>;i++)<span class="comment">//由于默认要选左枝和右枝，所以i要-2</span></span><br><span class="line">&#123;</span><br><span class="line">f[k][i+<span class="number">2</span>]=max(f[l][i+<span class="number">1</span>]+a[k][l],f[r][i+<span class="number">1</span>]+a[k][r]);<span class="comment">//可能直选一边</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)<span class="comment">//分配左子树多少，右子树去多少枝，不用判断是否能够取满，因为取满的总是最优的</span></span><br><span class="line">&#123;<span class="comment">//不会影响</span></span><br><span class="line">value=f[l][j]+a[k][l]+f[r][i-j]+a[k][r];</span><br><span class="line">f[k][i+<span class="number">2</span>]=max(f[k][i+<span class="number">2</span>],value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,x,y;</span><br><span class="line">n=read();p=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=read(),y=read(),a[x][y]=read();<span class="comment">//矩阵存边权</span></span><br><span class="line">b[x][++s[x]]=y;b[y][++s[y]]=x;<span class="comment">//存边，由于边数不多，直接用邻接表存，不用链式前向星</span></span><br><span class="line">&#125;</span><br><span class="line">DFS(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//以1为根遍历数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,f[<span class="number">1</span>][p]);<span class="comment">//输出最后结果</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P1435」回文字串 解题报告</title>
      <link href="/2019/03/27/Luogu_P1435-ReverseChar-Solution/"/>
      <url>/2019/03/27/Luogu_P1435-ReverseChar-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P1435" target="_blank" rel="noopener">题面</a></h2><p>主要<del>大衣</del>大意：</p><p>给定一个字符串，求<strong>至少</strong>加入多少个字符才能使字符串变成回文字符串</p><p>下面就是我一本正经的<del>胡说八道</del>题解</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>很显然，这应该是一道典型的<strong>最长公共子序列</strong>的题目</p><p>因此，主要思想就是<strong>DP</strong></p><p>方程式也挺好推的</p><p>于是我们就来讲一下为什么这题能用<strong>最长公共子序列（LCS）</strong>求解</p><h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><h4 id="求的是什么？"><a href="#求的是什么？" class="headerlink" title="求的是什么？"></a>求的是什么？</h4><p>想要使这个字符串加入<strong>最少的字符</strong>变成一个回文串，那么肯定就是要是字符串中不能回文的部分回文</p><p>说起来比较难理解，比如：<code>Ab3bd</code>最少添的字符就是<code>A</code>对应的一个<code>A</code>，最后<code>d</code>对应的一个<code>d</code></p><p>我们可以发现，最少要添的字符就是<code>不能匹配的字符数=原字符串长度len-最长回文串的长度</code></p><p>这就变成了求最长回文串的题目</p><h4 id="怎么求？"><a href="#怎么求？" class="headerlink" title="怎么求？"></a>怎么求？</h4><p>又经验的人肯定就会用<strong>最长公共子序列</strong>去解，但是一些人可能要问为什么，那么我们这里就来证明一下</p><p>由于回文串是<strong>回文</strong>的（废话)，也就是说，把原来的字符串<strong>反转</strong>一遍，最长回文串的长度还是<strong>不变</strong>的</p><p>于是我们就变成了求两串的<strong>公共子序列的长度</strong>——其实思想就是回文串正着和反着的效果是一样的，也就是抓住这个特性，去求<strong>公共系序列的长度</strong></p><p>转移方程（最好自己去推一下）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i]==b[j])<span class="comment">//目标状态是f[len][len]</span></span><br><span class="line">f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;<span class="comment">//表示i，j两位置相等，那么就由i-1，j-1的状态（最优解）+1得到</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">f[i][j]=max(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);<span class="comment">//否则去掉i或j，转移最优解</span></span><br></pre></td></tr></table></figure><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a+<span class="number">1</span>);</span><br><span class="line">    len=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        b[i]=a[len-i+<span class="number">1</span>];<span class="comment">//反转</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j]=max(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,len-f[len][len]);<span class="comment">//长度减去最长回文串长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展知识："><a href="#拓展知识：" class="headerlink" title="拓展知识："></a>拓展知识：</h3><p><strong>最长上升子序列（LIS）</strong></p><h3 id="推荐题目（进阶，就是比较难的意思）："><a href="#推荐题目（进阶，就是比较难的意思）：" class="headerlink" title="推荐题目（进阶，就是比较难的意思）："></a>推荐题目（进阶，<del>就是比较难的意思</del>）：</h3><p><a href="https://www.luogu.org/problemnew/show/P1439" target="_blank" rel="noopener">【模板】最长公共子序列</a></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Luogu P1210」回文检测 解题报告</title>
      <link href="/2019/03/27/Luogu_P1210-ReverseCheck-Solution/"/>
      <url>/2019/03/27/Luogu_P1210-ReverseCheck-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P1210" target="_blank" rel="noopener">题面</a></h2><p><del>这是一道诡异的黄题</del></p><p>居然让你求一串吧啦吧啦的东西中 字母（大小写）最长的回文串的长度，还要输出完整的串  <del>吐血</del></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>保持淡定，我们啥都不会，就会Manacher，那就用<strong>Manacher</strong>大法！</p><p>1、把字符串处理成只有字母（去皮）</p><p>2、把字符串中插入<code>#</code>号（掺假）</p><p>3、Manacher跑一跑最长回文串长度（市场检查）</p><p>4、求出最长长度后再重新代入原来的字符串（打回原形！妖孽！）</p><p>然后，就完了~</p><p>就是<code>去皮</code>的时候，顺便记录一下字符的位置，这样重新代入时就比较方便</p><p>并且由于字符串有很多行，读入时就要用<code>getchar()</code>，直到<code>EOF</code>为止</p><p><del>似乎Noip2018普及T1有人因为这个WA？</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 20010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;a[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> st[M],s[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> l1,l2,len,ans,res;</span><br><span class="line"><span class="keyword">int</span> p[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (c&gt;=<span class="string">'a'</span>&amp;&amp;c&lt;=<span class="string">'z'</span>)||(c&gt;=<span class="string">'A'</span>&amp;&amp;c&lt;=<span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;l1;i++)</span><br><span class="line"><span class="keyword">if</span>(check(st[i]))</span><br><span class="line">&#123;</span><br><span class="line">a[l2].c=(st[i]&gt;=<span class="string">'a'</span>&amp;&amp;st[i]&lt;=<span class="string">'z'</span>)? st[i]:st[i]-<span class="string">'A'</span>+<span class="string">'a'</span>;</span><br><span class="line">a[l2++].id=i;<span class="comment">//记录编号（位置）</span></span><br><span class="line">&#125;</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">'!'</span>;</span><br><span class="line">s[<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;l2;i++)</span><br><span class="line">&#123;</span><br><span class="line">s[i*<span class="number">2</span>+<span class="number">2</span>]=a[i].c;</span><br><span class="line">s[i*<span class="number">2</span>+<span class="number">3</span>]=<span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line">len=l2*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">s[len]=<span class="string">'?'</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span><span class="comment">//大法不解释</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;mx)</span><br><span class="line">p[i]=min(p[id*<span class="number">2</span>-i],mx-i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(s[i-p[i]]==s[i+p[i]])</span><br><span class="line">            p[i]++;</span><br><span class="line"><span class="keyword">if</span>(i+p[i]&gt;mx)</span><br><span class="line">&#123;</span><br><span class="line">id=i;</span><br><span class="line">mx=i+p[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&amp;<span class="number">1</span>)<span class="comment">//由扩展后的s数组变回a数组</span></span><br><span class="line">l=(l<span class="number">-3</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l=(l<span class="number">-2</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(r&amp;<span class="number">1</span>)</span><br><span class="line">r=(r<span class="number">-3</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r=(r<span class="number">-2</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=a[l].id;k&lt;=a[r].id;k++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,st[k]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> c=getchar();<span class="comment">//读入</span></span><br><span class="line"><span class="keyword">while</span>(c!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">st[l1++]=c;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line">init();<span class="comment">//初始化</span></span><br><span class="line">manacher();<span class="comment">//大法</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)<span class="comment">//求最长</span></span><br><span class="line">ans=max(ans,p[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)<span class="comment">//求第一次出现的位置</span></span><br><span class="line"><span class="keyword">if</span>(p[i]==ans)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">ans--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">Print(i-ans+<span class="number">1</span>,i+ans<span class="number">-1</span>);<span class="comment">//重新代入</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CF86D」Powerful array 解题报告</title>
      <link href="/2019/03/27/CF86D-Powerful_array-Solution/"/>
      <url>/2019/03/27/CF86D-Powerful_array-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/CF86D" target="_blank" rel="noopener">题面</a></h2><p>给出一个$n$个数组成的数列$a$，有$t$次询问，每次询问为一个$[l,r]$的区间，求区间内<strong>每种数字出现次数的平方×数字的值</strong> 的和</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="直接上莫队咯-然后就T了"><a href="#直接上莫队咯-然后就T了" class="headerlink" title="直接上莫队咯      然后就T了"></a>直接上莫队咯      <del><code>然后就T了</code></del></h3><p>没学过莫队？！<del>我也没办法</del></p><p>这道题的数据范围在$2e5$的级别，有人会问莫队肯定要炸啊 捏~</p><h3 id="时限5000ms，那就可以乱搞了"><a href="#时限5000ms，那就可以乱搞了" class="headerlink" title="时限5000ms，那就可以乱搞了"></a>时限5000ms，那就可以乱搞了</h3><p>但是！还是要加一些优化</p><h3 id="如何优化？"><a href="#如何优化？" class="headerlink" title="如何优化？"></a>如何优化？</h3><p>1.对于算法本身的优化</p><p>由于莫队可以说是一个块状暴力的算法，就是把区间划分为$\sqrt n$块然后在块内暴力<del>（到头还是暴力）</del></p><p>我们可以把要查询的区间当做点表示在平面直角坐标系上，RT：</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_%e8%8e%ab%e9%98%9f1.png" alt></p><p>就像这样把询问放在平面直角坐标系上，<strong>$\large x$轴为询问该区间的顺序，$\large y$轴表示该区间的右端点</strong>，如果我们忽略区间的$L$值的影响，不难看出，虽然我们已经把区间划分在一个块里了，但是还是有很多冗余的操作，如果要是这些冗余的操作少一点就好了，这当然可以啦！</p><p>我们可以让<strong>块内的区间按$\large R$ 递增</strong>，这样能省很多时间，但是在区间过渡的时候，我们还是会做很多多余的操作，因为区间都是递增的，这样改变块的时候就可能有一个很大的落差，就掉了下去，可以自己想象一下</p><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_%e8%8e%ab%e9%98%9f2.png" alt></p><p>为了避免上述的现象，我们可以让区间像一个波浪一样，这样就很高效了，这样的划分方式叫做<code>奇偶划分</code><del>应该是这么叫的吧，还有一个是奇偶性剪枝</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//代码是关键，讲了啥不重要(手动划线)</span></span><br><span class="line"><span class="keyword">return</span> (pos[a.l]==pos[b.l])?(pos[a.l]&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r : a.l&lt;b.l;</span><br><span class="line">&#125;<span class="comment">//千万不要写if，会T！</span></span><br></pre></td></tr></table></figure><p>接着就是块的大小，同样影响速度，一般普通的块的大小应该是$\large \sqrt n$，但是，根据某奆佬研究，大小为$\large n^{0.54}$时更快，Orz</p><p>2.对于程序本身优化，<del>说人话就是卡卡常</del></p><p>比如：</p><blockquote><p>加点<code>register</code></p><p>非递归函数前加个<code>inline</code></p><p>不用快读用<code>fread</code></p><p>还有！乘法变加法……</p></blockquote><p>然后就把最大时间卡到了<code>622ms</code></p><p><del>啊哈哈哈哈哈</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() *(p++)<span class="comment">//在快读基础上改一点就行了</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Re register<span class="comment">//卡常必备</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,i;</span><br><span class="line">&#125;b[N];<span class="comment">//sum是数的多少，pos表示在哪块</span></span><br><span class="line"><span class="keyword">int</span> a[N],pos[N],n,m,sum[M],l,r,block;</span><br><span class="line">ll Ans[N],ans;</span><br><span class="line"><span class="keyword">char</span> bf[<span class="number">1</span>&lt;&lt;<span class="number">25</span>],*p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">Re <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">Re <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="comment">//奇偶划分</span></span><br><span class="line"><span class="keyword">return</span> (pos[a.l]==pos[b.l])?(pos[a.l]&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r : a.l&lt;b.l;</span><br><span class="line">&#125;<span class="comment">//注意，这里不要写if语句，会T</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(Re ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[x]++;<span class="comment">//有些人写在前面，那样的话就应该是+1</span></span><br><span class="line">ans+=(sum[x]+sum[x]<span class="number">-1</span>)*x;<span class="comment">//就是由原来的乘变成了加，手算一小部分也没有关系啦</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(Re ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ans-=(sum[x]+sum[x]<span class="number">-1</span>)*x;<span class="comment">//这里和上面也是一样的</span></span><br><span class="line">sum[x]--;<span class="comment">//为什么我感觉上面-1会更慢呢~</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Re <span class="keyword">int</span> i;</span><br><span class="line">bf[fread(bf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">25</span>,<span class="built_in">stdin</span>)]=<span class="string">'\0'</span>;p=bf;<span class="comment">//fread大法</span></span><br><span class="line">n=read();m=read();block=<span class="built_in">pow</span>(n,<span class="number">0.54</span>);<span class="comment">//神奇的块的大小</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i]=read(),pos[i]=i/block;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">b[i].l=read(),b[i].r=read(),b[i].i=i;</span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+m,cmp);l=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//然后上莫队</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(r&lt;b[i].r)</span><br><span class="line">Add(a[++r]);</span><br><span class="line"><span class="keyword">while</span>(r&gt;b[i].r)</span><br><span class="line">Del(a[r--]);</span><br><span class="line"><span class="keyword">while</span>(l&lt;b[i].l)</span><br><span class="line">Del(a[l++]);</span><br><span class="line"><span class="keyword">while</span>(l&gt;b[i].l)</span><br><span class="line">Add(a[--l]);</span><br><span class="line">Ans[b[i].i]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再说一遍"><a href="#再说一遍" class="headerlink" title="再说一遍"></a><del>再说一遍</del></h3><h3 id="最后注意，sort的时候，如果数组本来就有序了，sort会很慢，所以千万不要在里面加if了，容易T"><a href="#最后注意，sort的时候，如果数组本来就有序了，sort会很慢，所以千万不要在里面加if了，容易T" class="headerlink" title="最后注意，sort的时候，如果数组本来就有序了，sort会很慢，所以千万不要在里面加if了，容易T"></a>最后注意，sort的时候，如果数组本来就有序了，sort会很慢，所以千万不要在里面加if了，容易T</h3>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CF656B」Scrambled 解题报告</title>
      <link href="/2019/03/27/CF656B-Scrambled-Solution/"/>
      <url>/2019/03/27/CF656B-Scrambled-Solution/</url>
      
        <content type="html"><![CDATA[<p><del>咳咳~这……不是一道<a href="https://www.luogu.org/problemnew/show/CF656B" target="_blank" rel="noopener">恶意评分题</a>？</del>  </p><p>其实这也是一篇不正儿八经的题解<del>这不是一篇<a href="https://baike.baidu.com/item/%E4%B8%BA%E6%89%80%E6%AC%B2%E4%B8%BA/1506227?fr=aladdin" target="_blank" rel="noopener">科</a><a href="https://baike.baidu.com/item/%E6%9A%B4%E5%8A%9B%E6%B1%82%E8%A7%A3%E6%B3%95/2689920" target="_blank" rel="noopener">普</a><a href="https://baike.baidu.com/item/%E6%A6%82%E7%8E%87/828845?fr=aladdin" target="_blank" rel="noopener">文</a>吗？！</del></p><p>好吧，首先数据都很小，立马想到<strong>暴力</strong> </p><p>那么，怎么<strong>暴力</strong>呢？/摸下巴  </p><p>先看题目，我们可以发现，题目对精度的要求很小——也就是$10^{-4}$  </p><p>所以，我们可以<del>猥琐鱼尾</del>  <del>为所欲为</del>  用各种神奇的方法求解  </p><p>作为一名低学历的OIer，我想引用初中数学<del>八上？八下？</del>的内容——用频数估计频率  </p><p>还记得那个抛硬币的实验吗？  </p><p>实践出真知可是小平爷爷说的！  </p><p>秉承着优良的传统，我们就来</p><h3 id="枚举吧！"><a href="#枚举吧！" class="headerlink" title="枚举吧！"></a>枚举吧！</h3><p>枚举从当前往后1,000,000（别数了，<del>十万</del>，一百万~）天包括<strong>当前天</strong>,所以循环写（其实问题也不大）</p><blockquote><p>i = 0 to Max-1</p></blockquote><p>我话<del>不</del>多，上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i]=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">b[i]=read();</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Max;j++)<span class="comment">//实践出真知！</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(j%a[i]==b[i])</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf"</span>,ans/<span class="number">1000000.0</span>);<span class="comment">//就这样~~水了~~过去？！</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CF1102F」Elongated Matrix 解题报告</title>
      <link href="/2019/03/27/CF1102F-Elongated_Matrix-Solution/"/>
      <url>/2019/03/27/CF1102F-Elongated_Matrix-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/CF1102F" target="_blank" rel="noopener">题面</a></h2><p>给出$n*m$个矩阵，从第一列开始，一列一列访问元素，依次记元素为$S_1,S_2,…S_{nm}$，则$k$的价值为相邻两个元素差的绝对值的最小值，即$k=min{|S_1 - S_2|,|S_2 - S_3|,…,|S_{nm-1} - S_{nm}|}$</p><p>现在可以改变任意行的顺序，求$k$的最大值</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="正解应该是状压DP"><a href="#正解应该是状压DP" class="headerlink" title="正解应该是状压DP"></a>正解应该是状压DP</h3><h3 id="但是以下讲的是另一种玄学做法——搜索"><a href="#但是以下讲的是另一种玄学做法——搜索" class="headerlink" title="但是以下讲的是另一种玄学做法——搜索"></a>但是以下讲的是另一种玄学做法——搜索</h3><p>当然啦~，直接爆搜是不行的，在一切之前，我们先研究一下题目</p><p>然后做一些预处理</p><p><strong>比如：</strong></p><p>1、改变的是行的顺序，因此任意<strong>两行之间的最小差值</strong>可以预先求出来</p><table><thead><tr><th style="text-align:center">9</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center"><strong>10</strong></td><td style="text-align:center"><strong>8</strong></td></tr><tr><td style="text-align:center">$\large \color{red}5$</td><td style="text-align:center">$\large \color{red}3$</td></tr><tr><td style="text-align:center">$\large \color{red}4$</td><td style="text-align:center">$\large \color{red}3$</td></tr></tbody></table><p>图中两行的差值就是$0$吧，然后类似处理其他行</p><p>就是先把一些<strong>固定的值</strong>处理出来</p><p>2、可以把两行分别在头尾的代价处理出来</p><table><thead><tr><th style="text-align:center">5</th><th style="text-align:center">$\large \color{red}3$</th></tr></thead><tbody><tr><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>9</strong></td></tr><tr><td style="text-align:center"><strong>10</strong></td><td style="text-align:center"><strong>8</strong></td></tr><tr><td style="text-align:center">$\large \color{red}4$</td><td style="text-align:center"><strong>3</strong></td></tr></tbody></table><p>这里的顺序和先前不一样是想说明<strong>行的顺序</strong>是可以<strong>改变</strong>的！这时要处理的比较特殊，想象一下转换成一条链后，标红的是相邻的，我们也依次把这样的差值处理出来</p><p><strong>预处理完后</strong></p><p>原本和$m$有关的数据就只和$n$有关了，而$n$的范围有那么小，<del>于是开始乱搞</del></p><p>然后我们就搜索，<del>枚举$n$的全排列</del></p><p>当然这是不可能的，<del>不炸就怪</del>，肯定要加剪枝</p><p>然后就加——<strong>最优性剪枝</strong>  <del>其实我没学过深搜的优化技巧</del></p><p>并且加入一个线段树的$lowbit$操作，差不多就挺快的了</p><p>其实大致算一下：</p><p>$$16!=20\ 9227\ 8988\ 8000$$</p><p>也不多啦~</p><p>加了优化之后，有很大的减少的</p><p>先上代码，注释掉的读优不用管</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="comment">//#define getchar() *(pos++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 10010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt,cost;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cost(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],n,m,a[N][M],s[N][N],p[N][N],res,ans,bef,Total;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">20</span>],C[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">//char bf[1&lt;&lt;25],*pos;</span></span><br><span class="line"><span class="comment">//int read()&#123;int s=0;char c=getchar();</span></span><br><span class="line"><span class="comment">//while(!isdigit(c))c=getchar();</span></span><br><span class="line"><span class="comment">//while(isdigit(c))&#123;s=(s&lt;&lt;1)+(s&lt;&lt;3)+c-'0';c=getchar();&#125;</span></span><br><span class="line"><span class="comment">//return s;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> res,<span class="keyword">int</span> t,<span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//k表示做</span></span><br><span class="line"><span class="keyword">if</span>(res&lt;=ans) <span class="keyword">return</span>;<span class="comment">//ans表示目前的最大值</span></span><br><span class="line"><span class="keyword">if</span>(k==n)&#123;</span><br><span class="line">ans=max(ans,min(res,p[bef][last]));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur=Total-t,j;</span><br><span class="line"><span class="keyword">while</span>(cur)&#123;<span class="comment">//树状数组的lowbit</span></span><br><span class="line">j=C[cur&amp;(-cur)];<span class="comment">//对应到回原来的编号-1，因为第一位 1=2^0</span></span><br><span class="line"><span class="keyword">if</span>(s[last][j+<span class="number">1</span>]&gt;ans) </span><br><span class="line">DFS(k+<span class="number">1</span>,min(res,s[last][j+<span class="number">1</span>]),t|(<span class="number">1</span>&lt;&lt;j),j+<span class="number">1</span>);</span><br><span class="line">cur-=cur&amp;(-cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="comment">//bf[fread(bf,1,1&lt;&lt;25,stdin)]='\0',pos=bf;</span></span><br><span class="line">n=read();m=read();k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">16</span>;i++)<span class="comment">//2^k对应到k，方便后面知道是哪一位</span></span><br><span class="line">C[k]=i,k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">a[i][j]=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//预处理 第1条</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line">res=INF;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">res=min(res,<span class="built_in">abs</span>(a[i][k]-a[j][k]));</span><br><span class="line">s[i][j]=s[j][i]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//预处理 第二条</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">res=INF;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;m;k++)</span><br><span class="line">res=min(res,<span class="built_in">abs</span>(a[i][k+<span class="number">1</span>]-a[j][k]));</span><br><span class="line">p[i][j]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,p[<span class="number">1</span>][<span class="number">1</span>]);<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//这种情况不特判也没关系</span></span><br><span class="line">Total=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;<span class="comment">//用于DFS中取反操作，是我太菜了，只会这种方法</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//bef表示记录首行，方便最后判断</span></span><br><span class="line">bef=i,DFS(<span class="number">1</span>,INF,<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>),i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h3><p>-&gt;Sinner 这位大佬说：时间复杂度是不正确的！ 我（瑟瑟发抖）：根据<del>玄学</del>，跑得超快的，因为两行之间的最小值比较难卡，所以时间还是比较稳定的<del>我们不是理论派</del></p><p><del>好吧，此份题解仅供参考</del></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CF1082C」Multi-Subject Competition 解题报告</title>
      <link href="/2019/03/27/CF1082C-Multi-Subject_Competition-Solution/"/>
      <url>/2019/03/27/CF1082C-Multi-Subject_Competition-Solution/</url>
      
        <content type="html"><![CDATA[<p><strong><del>人生第一篇题解，虽然这道题做的人暂时不多，但我相信它——迟早有一天会发扬光大的！！！</del></strong><br><strong><del>说完废话</del></strong><br>步入正题  </p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.org/problemnew/show/CF1082C" target="_blank" rel="noopener">传送门</a></h3><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="模拟、枚举"><a href="#模拟、枚举" class="headerlink" title="模拟、枚举"></a>模拟、枚举</h3><p>对于每个组里的数字，先排序，然后从一到最大可能的情况，枚举要选几个数<br>记录选取的和（用前缀和会更方便），然后就是选择<br>那些前缀和<br>为 <strong>正数</strong>的组 加进来<br>为 <strong>负数</strong>的组 舍去（因为出现负数的情况说明这组还未选进来的数<strong>都是负数</strong>，没有利用价值了，故舍去）<br>具体实现起来比较麻烦<br>把每个数分到相应的组，并把每个组里的数排序  ——》 先对全部的数排序，再用链式<strong>前向星</strong>分组<br>枚举 数的个数：  $\to$ 用<strong>queue</strong>记录遍历的顺序，再用两个while循环遍历，res表示<strong>有价值的组</strong>的<strong>个数</strong>，里面的num表示这一次遍历了几个组（方便终止）<br>具体见代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> s,r;</span><br><span class="line">&#125;a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> sum,cur,ans,num,res;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span><span class="comment">//快读不解释</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,p=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'-'</span>)</span><br><span class="line">p=<span class="number">-1</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">n=read();m=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i].s=read(),a[i].r=read();</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);<span class="comment">//先进行排序</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//分组</span></span><br><span class="line">&#123;</span><br><span class="line">nxt[i]=head[a[i].s];</span><br><span class="line">head[a[i].s]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//起始遍历顺序就是组号</span></span><br><span class="line">p.push(i);</span><br><span class="line">res=m;</span><br><span class="line"><span class="keyword">while</span>(res)<span class="comment">//有价值的组数</span></span><br><span class="line">&#123;</span><br><span class="line">num=res;<span class="comment">//更新下次</span></span><br><span class="line">sum=<span class="number">0</span>;<span class="comment">//记录这次的结果</span></span><br><span class="line"><span class="keyword">while</span>(num--)</span><br><span class="line">&#123;</span><br><span class="line">cur=p.front();p.pop();</span><br><span class="line">s[cur]+=a[head[cur]].r;<span class="comment">//前缀和</span></span><br><span class="line">sum+=max(s[cur],<span class="number">0</span>);</span><br><span class="line">head[cur]=nxt[head[cur]];<span class="comment">//更新头结点</span></span><br><span class="line"><span class="keyword">if</span>(head[cur]&amp;&amp;s[cur]&gt;<span class="number">0</span>)<span class="comment">//如果还有利用价值就加入下一次的遍历序列</span></span><br><span class="line">p.push(cur);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则更新组数</span></span><br><span class="line">res--;</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,sum);<span class="comment">//全部的答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJOI2019爆零记</title>
      <link href="/2019/03/24/ZJOI2019-Travel-Notes/"/>
      <url>/2019/03/24/ZJOI2019-Travel-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="2019-3-24-周日-Day0"><a href="#2019-3-24-周日-Day0" class="headerlink" title="2019.3.24 周日 Day0"></a>2019.3.24 周日 Day0</h2><p>上午8点从$YWHS$门口坐车出发，一路抖啊抖啊抖啊</p><p>目的地：宁波镇海中学-&gt;这个牛逼的地方</p><p><del>下车空气格外新鲜</del> <del>然后刷脸，开房，吃饭</del></p><p>被拉去第一报告厅——鼓掌~</p><p><img src="/image/Zhenhai_High_School.jpg" alt></p><p>​                            $\large \uparrow$这个应该是$Judge$?</p><p>竟然有点压力了，到底是我太菜了，空手去的，回来多了一块高端大气上档次的<del>鼠标垫</del>奖牌</p><p>晚上吃完放，刚迈出饭店发现准考证forgotten了，然后和Judge还有Yang Xiao巨佬以及Ydk-&gt;</p><p>冲啊</p><p><del>然后就找不到路了</del></p><p>晚饭回来，一直在颓$blog$，-&gt;多多指教 <a href="https://hovnysilence.github.io/">h^ovny’s blog</a></p><p>$19:00$ $luogu$的$fans$见面会</p><p>$21:35$ 外卖 <del>很快就分完了</del></p><hr><p>明天要开始上课了，有点紧张，一定要听懂，<del>虽然我是一个数论菜鸡</del>，跟着$Sinner$巨佬写游记，准备每天将自己的所学整理到游记里，<del>其实是笔记本忘在学校里了</del>，今日完</p><hr><h2 id="2019-3-25-周一-Day1"><a href="#2019-3-25-周一-Day1" class="headerlink" title="2019.3.25 周一 Day1"></a>2019.3.25 周一 Day1</h2><p>是的，就是今天，集训开始了</p><p>然后上午和下午两节课，听得<del>完全</del>有点懵逼，深深地感受到自己的弱小</p><p>上午讲的大多都是多项式，而我多项式只学了乘法…全程挂机，除了一开始怎么变换的环节听懂…</p><p>下午就真的原地挂机了，印象深刻的一道题 <a href="http://codeforces.com/problemset/problem/1137/F" target="_blank" rel="noopener">$this$</a> $CF3300$</p><p>然后有瞬秒的大佬，瑟瑟发抖</p><p>晚上去试机了，一开始还以为$Dev$有锅，结果是$main$打成了$mian$，愣是打了个树剖，感觉键盘除了有点硬之外，一切都还好，希望省选的时候不要像平时模拟赛来不及写……</p><p>昨天的希望并没有达成，是自己能力还不够，看各位大佬看齐，真的还有好多好多知识没有学，今日完</p><hr><h2 id="2019-3-26-周二-Day2"><a href="#2019-3-26-周二-Day2" class="headerlink" title="2019.3.26 周二 Day2"></a>2019.3.26 周二 Day2</h2><p>有点小复杂，今天上午讲的是数据结构，$LCT$有点没听懂…要学的还有好多好多</p><p>下午讲的是随机算法，真的好奇妙，但是巨弱的我并不会</p><p>晚上老师讲了下明天的注意事项，有点紧张，都还好，去外面买了点明天的零食</p><hr><p>明天就省选了，虽然希望并不是很大，但是希望能比在衢州的时候好吧，事先提醒自己，把握好时间，尽力拿分，多多检查，我可以的，加油！</p><hr><h2 id="2019-3-27-周三-Day3-The-End"><a href="#2019-3-27-周三-Day3-The-End" class="headerlink" title="2019.3.27 周三 Day3 The End"></a>2019.3.27 周三 Day3 The End</h2><p>然而，今天，是悲惨的一天，$8:00-13:00$浙江省选</p><p>压缩包，密码$JYB@Xzc!!3Yue*$，$5$遍连错，感觉凉凉</p><p>第一题，麻将…从来没有玩过麻将的人，看完题目，没思路，跳</p><p>第二题，线段树…然后想到了早上$louhc$说的<code>吉司机线段树</code>，开始想正解，用了两个小时，先在草稿纸上手推了一波，发现了一点小规律，然后在电脑上打了$10$行的表，惊奇的发现是<code>杨辉三角</code>&amp;<code>组合数</code>，再处理了一下细节，俩个小时过去了</p><p>开始写正解，$77$行，感觉不大对劲，跑了一遍样例，最后一个$case$ $WA$了，突然发现手推的时候推错了……心态炸了</p><p>心态爆炸写不下去，粗略看了看第三题，没有思路</p><p>乱想，原本想先拿第二题的四十分，然后就把自己$hack$掉了，煎熬</p><p>心态爆炸，想了很多，没有坚持下去，一、三题都没有思路，匆匆地打了个表，交了个错接，样例都没测</p><p>然后打第二题的暴力，过了样例，没有检查，扔在了一边，$11：30$，边吃巧克力边思考，完全没有思路</p><p>$12:20$，交了另外两题的样例，放弃，心态爆炸</p><p>感觉凉凉，分数$20$封顶，自我感觉爆零预定</p><p>是自己学的太少了，一到考场上，什么都不会</p><p>回义乌，车上 困。$ZJOI2019$爆零预定。完……</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Poj1845」 Sumdiv 解题报告</title>
      <link href="/2019/03/24/Poj1845-Sumdiv-Solution/"/>
      <url>/2019/03/24/Poj1845-Sumdiv-Solution/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="题面戳这里"><a href="#题面戳这里" class="headerlink" title="题面戳这里"></a><a href="http://poj.org/problem?id=1845" target="_blank" rel="noopener">题面戳这里</a></h2><h3 id="啥都别看，只是求"><a href="#啥都别看，只是求" class="headerlink" title="啥都别看，只是求"></a>啥都别看，只是求</h3><h3 id="a-b-所有的因数的和"><a href="#a-b-所有的因数的和" class="headerlink" title="$a^b$所有的因数的和"></a>$a^b$所有的因数的和</h3><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p><del>真没想到！</del></p><p>其实我们可以先将$a^b$<strong>分解成质因数</strong>的</p><p>因为$a^b$的因数肯定是$a^b$的质因数在一定的条件下相乘而成的</p><p>然后<strong>组合一下</strong></p><h3 id="正解！！！"><a href="#正解！！！" class="headerlink" title="正解！！！"></a>正解！！！</h3><p>h^ovny：走开！别误导别人！</p><p>来一波公式：</p><h2 id="a-Pi-n-i-1-p-i-c-i"><a href="#a-Pi-n-i-1-p-i-c-i" class="headerlink" title="$a=\Pi^n_{i=1}p[i]^{c[i]}$"></a>$a=\Pi^n_{i=1}p[i]^{c[i]}$</h2><h2 id="a-b-Pi-n-i-1-p-i-c-i-b"><a href="#a-b-Pi-n-i-1-p-i-c-i-b" class="headerlink" title="$a^b=\Pi^n_{i=1}p[i]^{c[i]*b}$"></a>$a^b=\Pi^n_{i=1}p[i]^{c[i]*b}$</h2><p>所有因数的和：</p><h2 id="Ans-Pi-i-1-n-Sigma-k-i-j-0-p-i-j"><a href="#Ans-Pi-i-1-n-Sigma-k-i-j-0-p-i-j" class="headerlink" title="$Ans=\Pi_{i=1}^n\Sigma^{k[i]}_{j=0}p[i]^j$"></a>$Ans=\Pi_{i=1}^n\Sigma^{k[i]}_{j=0}p[i]^j$</h2><p>$\Pi$ ：读作Pi，是$\pi$的大写，表示累乘</p><p>$\Sigma$ ：读作Sigma，是$\sigma$的大写，表示累加</p><p>现在的问题就变成了如何求：</p><h2 id="Sigma-j-0-k-i"><a href="#Sigma-j-0-k-i" class="headerlink" title="$\Sigma_{j=0}^{k[i]}$"></a>$\Sigma_{j=0}^{k[i]}$</h2><p>展开来写乘：</p><h2 id="1-p-p-2-p-3-…-p-k"><a href="#1-p-p-2-p-3-…-p-k" class="headerlink" title="$(1+p+p^2+p^3+…+p^k)$"></a>$(1+p+p^2+p^3+…+p^k)$</h2><h3 id="用分治法的思想求解"><a href="#用分治法的思想求解" class="headerlink" title="用分治法的思想求解"></a>用分治法的思想求解</h3><p>当<strong>k</strong>为<strong>奇数</strong>时：</p><blockquote><p> $f(k)=1+p+p^2+p^3+…+p^k$<br> ​        $= (1+p+…+p^{\frac k 2})+(p^{\frac k 2+1}+…+p^k)$<br> ​        $= (1+p+…+p^{\frac k 2})+p^{\frac k 2+1}<em>(1+p+…+p^{\frac k 2})$<br> ​        $= (p^{\frac k 2+1}+1)</em>(1+p+…+p^{\frac k 2})$</p></blockquote><p>当<strong>k</strong>为<strong>偶数</strong>时</p><blockquote><p>$f(k)=f(k-1)*p^k$</p></blockquote><p>然后配合快速幂%9901</p><h2 id="正解！！！-1"><a href="#正解！！！-1" class="headerlink" title="正解！！！"></a>正解！！！</h2><p><del>人已憔悴</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 9901</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll a[<span class="number">30</span>];</span><br><span class="line">ll s[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">10010</span>];</span><br><span class="line">ll n,m;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">quickPow</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)</span><br><span class="line">res=(res*a)%Mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">a=(a*a)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll p,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> (p+<span class="number">1</span>)%Mod;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> work(p,k/<span class="number">2</span>)*(quickPow(p,k/<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>)%Mod;</span><br><span class="line"><span class="keyword">return</span> ((work(p,k/<span class="number">2</span><span class="number">-1</span>)*(quickPow(p,k/<span class="number">2</span>)+<span class="number">1</span>))%Mod+quickPow(p,k))%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">n=read();m=read();</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[++t]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">s[t]++;</span><br><span class="line">n/=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">3</span>;i*i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(!b[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[++t]=i;</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">s[t]++;</span><br><span class="line">n/=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">j=i+i;</span><br><span class="line"><span class="keyword">while</span>(j*j&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">b[j]=<span class="number">1</span>;</span><br><span class="line">j+=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[++t]=n;</span><br><span class="line">s[t]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">ans=(ans*work(a[i],s[i]*m))%Mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CF670C」 Cinema 解题报告</title>
      <link href="/2019/03/24/CF670C-Cinema-Solution/"/>
      <url>/2019/03/24/CF670C-Cinema-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.org/problemnew/show/CF670C" target="_blank" rel="noopener">传送门</a></h3><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="离散化、hash"><a href="#离散化、hash" class="headerlink" title="离散化、hash"></a><strong>离散化</strong>、<strong>hash</strong></h3><p>对于这样一个明显的统计排序的题目，当然轻而易举啦~</p><p>但是！看！语言的编号 <strong>a</strong>数组和 <strong>b</strong>数组的值最大在$10^9$的级别，所以开个数组来存———That’s impossible!</p><p>所以我们可以用上<strong>离散化</strong>（也就是hash）</p><p>离散化，我们有两种写法</p><h4 id="第一种是自己手码代码"><a href="#第一种是自己手码代码" class="headerlink" title="第一种是自己手码代码"></a>第一种是自己手码代码</h4><p>先排序，然后去重，接着用二分一一对应，达到离散化的目的</p><p>板子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>,cmp);</span><br><span class="line">n=unique(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i]=lower_bound(b+<span class="number">1</span>,b+n+<span class="number">1</span>,a[i])-b;</span><br></pre></td></tr></table></figure></p><h4 id="第二种是使用STL库的map"><a href="#第二种是使用STL库的map" class="headerlink" title="第二种是使用STL库的map"></a>第二种是使用STL库的map</h4><p>头文件：<code>#include &lt;map&gt;</code></p><p>定义方式：<code>map&lt;type,type&gt; p;</code>表示将前一种type映射到后一种type</p><p>其中的类型可以很多，比如double，string，int，bool等基本类型，也包括pair这种</p><p>如<code>map&lt;pair&lt;int,int&gt;,bool&gt;p;</code>允许的</p><p>操作：一般用数组的形式，直接<code>p[x]</code>访问、写入</p><p><strong>PS</strong>：但是map的速度比较慢，想进一步提高可以使用unordered_map</p><p>此处不才不做讲解，具体详见<a href="https://www.luogu.org/blog/yihan/unordered" target="_blank" rel="noopener">洛谷日报</a></p><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="keyword">int</span> cur,res,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">p[read()]++;<span class="comment">//科（珂）学家们能听懂的语言</span></span><br><span class="line">m=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//电影配音</span></span><br><span class="line">a[i]=read();</span><br><span class="line">b=p[read()];</span><br><span class="line">ans=<span class="number">1</span>;<span class="comment">//一开始默认第一种是答案</span></span><br><span class="line">res=p[a[<span class="number">1</span>]];</span><br><span class="line">cur=b;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">b=p[read()];</span><br><span class="line">x=p[a[i]];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=res)<span class="comment">//比较听的懂配音，看的懂字幕的人数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;res)</span><br><span class="line">&#123;</span><br><span class="line">res=x;</span><br><span class="line">cur=b;</span><br><span class="line">ans=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(cur&lt;b)</span><br><span class="line">&#123;</span><br><span class="line">ans=i;</span><br><span class="line">cur=b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推荐题目："><a href="#推荐题目：" class="headerlink" title="推荐题目："></a>推荐题目：</h3><p><a href="https://www.luogu.org/problemnew/show/P1955" target="_blank" rel="noopener">「Luogu」[NOI2015]程序自动分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown数学符号</title>
      <link href="/2019/03/24/Markdowm-Mathematical_Symbols/"/>
      <url>/2019/03/24/Markdowm-Mathematical_Symbols/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h2><p>语法：</p><p>x^2</p><p>效果：</p><blockquote><p>$x^2$</p></blockquote><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>语法：</p><p>x_i</p><p>效果：</p><blockquote><p>$x_i$</p></blockquote><h2 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h2><p>语法：</p><p>x^{2y}</p><p>效果：</p><blockquote><p>$x^{2y}$</p></blockquote><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><p>语法：</p><p>\{\}</p><p>效果：</p><blockquote><p>${}$</p></blockquote><h2 id="分数线"><a href="#分数线" class="headerlink" title="分数线"></a>分数线</h2><p>语法：</p><p>\frac12</p><p>\frac{12}{23}</p><p>效果：</p><blockquote><p>$\frac12$</p><p>$\frac{12}{23}$</p></blockquote><h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><p>语法：</p><p>\sqrt{x}</p><p>\sqrt[3]{x}</p><p>效果：</p><blockquote><p>$\sqrt{x}$</p><p>$\sqrt[3]{x}$</p></blockquote><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>语法：</p><p>\ldots \cdots</p><p>效果：</p><blockquote><p>$\ldots \cdots$</p></blockquote><h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h2><p>语法：</p><p>\vec{ a }</p><p>效果：</p><blockquote><p>$\vec{ a }$</p></blockquote><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>语法：</p><p>\int_0^2 x^2 {\rm d}x</p><blockquote><p>$\int_0^2 x^2 {\rm d}x$</p></blockquote><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>语法：</p><p>\lim\limits_{n \rightarrow +\infty} \frac{1}{n(n+1)}</p><p>效果：</p><blockquote><p>$\lim\limits_{n \rightarrow +\infty} \frac{1}{n(n+1)}$</p></blockquote><h2 id="累加"><a href="#累加" class="headerlink" title="累加"></a>累加</h2><p>语法：</p><p>\sum_{i=0}^n i^2</p><p>\Sigma_{i=0}^n i^2</p><p>效果：</p><blockquote><p>$\sum_{i=0}^n i^2​$</p><p>$\Sigma_{i=0}^n i^2​$</p></blockquote><h2 id="累乘"><a href="#累乘" class="headerlink" title="累乘"></a>累乘</h2><p>语法：</p><p>\prod_{i=1}^n i^2</p><p>\Pi_{i=1}^n i^2</p><p>效果：</p><blockquote><p>$\prod_{i=1}^n i^2$</p><p>$\Pi_{i=1}^n i^2​$</p></blockquote><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th style="text-align:center">语法(大写)</th><th style="text-align:center">效果(大写)</th><th style="text-align:center">语法(小写)</th><th style="text-align:center">效果(小写)</th></tr></thead><tbody><tr><td style="text-align:center">\Alpha</td><td style="text-align:center">$\Alpha$</td><td style="text-align:center">\alpha</td><td style="text-align:center">$\alpha$</td></tr><tr><td style="text-align:center">\Beta</td><td style="text-align:center">$\Beta$</td><td style="text-align:center">\beta</td><td style="text-align:center">$\beta$</td></tr><tr><td style="text-align:center">\Gamma</td><td style="text-align:center">$\Gamma$</td><td style="text-align:center">\gamma</td><td style="text-align:center">$\gamma$</td></tr><tr><td style="text-align:center">\Delta</td><td style="text-align:center">$\Delta$</td><td style="text-align:center">\delta</td><td style="text-align:center">$\delta$</td></tr><tr><td style="text-align:center">\Epsilon</td><td style="text-align:center">$\Epsilon$</td><td style="text-align:center">\epsilon</td><td style="text-align:center">$\epsilon$</td></tr><tr><td style="text-align:center">\Zeta</td><td style="text-align:center">$\Zeta$</td><td style="text-align:center">\zeta</td><td style="text-align:center">$\zeta$</td></tr><tr><td style="text-align:center">\Eta</td><td style="text-align:center">$\Eta$</td><td style="text-align:center">\eta</td><td style="text-align:center">$\eta$</td></tr><tr><td style="text-align:center">\Theta</td><td style="text-align:center">$\Theta$</td><td style="text-align:center">\theta</td><td style="text-align:center">$\theta$</td></tr><tr><td style="text-align:center">\Iota</td><td style="text-align:center">$\Iota$</td><td style="text-align:center">\iota</td><td style="text-align:center">$\iota$</td></tr><tr><td style="text-align:center">\Kappa</td><td style="text-align:center">$\Kappa$</td><td style="text-align:center">\kappa</td><td style="text-align:center">$\kappa$</td></tr><tr><td style="text-align:center">\Lambda</td><td style="text-align:center">$\Lambda$</td><td style="text-align:center">\lambda</td><td style="text-align:center">$\lambda$</td></tr><tr><td style="text-align:center">\Mu</td><td style="text-align:center">$\Mu$</td><td style="text-align:center">\mu</td><td style="text-align:center">$\mu$</td></tr><tr><td style="text-align:center">\Nu</td><td style="text-align:center">$\Nu$</td><td style="text-align:center">\nu</td><td style="text-align:center">$\nu$</td></tr><tr><td style="text-align:center">\Xi</td><td style="text-align:center">$\Xi$</td><td style="text-align:center">\xi</td><td style="text-align:center">$\xi$</td></tr><tr><td style="text-align:center">\Omicron</td><td style="text-align:center">$\Omicron$</td><td style="text-align:center">\omicron</td><td style="text-align:center">$\omicron$</td></tr><tr><td style="text-align:center">\Pi</td><td style="text-align:center">$\Pi$</td><td style="text-align:center">\pi</td><td style="text-align:center">$\pi$</td></tr><tr><td style="text-align:center">\Rho</td><td style="text-align:center">$\Rho$</td><td style="text-align:center">\rho</td><td style="text-align:center">$\rho$</td></tr><tr><td style="text-align:center">\Sigma</td><td style="text-align:center">$\Sigma$</td><td style="text-align:center">\sigma</td><td style="text-align:center">$\sigma$</td></tr><tr><td style="text-align:center">\Tau</td><td style="text-align:center">$\Tau$</td><td style="text-align:center">\tau</td><td style="text-align:center">$\tau$</td></tr><tr><td style="text-align:center">\Upsilon</td><td style="text-align:center">$\Upsilon$</td><td style="text-align:center">\upsilon</td><td style="text-align:center">$\upsilon$</td></tr><tr><td style="text-align:center">\Phi</td><td style="text-align:center">$\Phi$</td><td style="text-align:center">\phi</td><td style="text-align:center">$\phi$</td></tr><tr><td style="text-align:center">\Chi</td><td style="text-align:center">$Chi$</td><td style="text-align:center">\chi</td><td style="text-align:center">$\chi$</td></tr><tr><td style="text-align:center">\Psi</td><td style="text-align:center">$\Psi$</td><td style="text-align:center">\psi</td><td style="text-align:center">$\psi$</td></tr><tr><td style="text-align:center">\Omega</td><td style="text-align:center">$\Omega$</td><td style="text-align:center">\omega</td><td style="text-align:center">$\omega$</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\pm</td><td style="text-align:center">$\pm$</td></tr><tr><td style="text-align:center">\times</td><td style="text-align:center">$\times$</td></tr><tr><td style="text-align:center">\div</td><td style="text-align:center">$\div$</td></tr><tr><td style="text-align:center">\mid</td><td style="text-align:center">$\mid$</td></tr><tr><td style="text-align:center">\nmid</td><td style="text-align:center">$\nmid$</td></tr><tr><td style="text-align:center">\cdot</td><td style="text-align:center">$\cdot$</td></tr><tr><td style="text-align:center">\circ</td><td style="text-align:center">$\circ$</td></tr><tr><td style="text-align:center">\ast</td><td style="text-align:center">$\ast$</td></tr><tr><td style="text-align:center">\bigodot</td><td style="text-align:center">$\bigodot$</td></tr><tr><td style="text-align:center">\bigotimes</td><td style="text-align:center">$\bigotimes$</td></tr><tr><td style="text-align:center">\bigoplus</td><td style="text-align:center">$\bigoplus$</td></tr><tr><td style="text-align:center">\le</td><td style="text-align:center">$\le$</td></tr><tr><td style="text-align:center">\ge</td><td style="text-align:center">$\ge$</td></tr><tr><td style="text-align:center">\ne</td><td style="text-align:center">$\ne$</td></tr><tr><td style="text-align:center">\approx</td><td style="text-align:center">$\approx$</td></tr><tr><td style="text-align:center">\equiv</td><td style="text-align:center">$\equiv$</td></tr><tr><td style="text-align:center">\sum</td><td style="text-align:center">$\sum$</td></tr><tr><td style="text-align:center">\prod</td><td style="text-align:center">$\prod$</td></tr><tr><td style="text-align:center">\coprod</td><td style="text-align:center">$\coprod$</td></tr></tbody></table><h2 id="集合运算符"><a href="#集合运算符" class="headerlink" title="集合运算符"></a>集合运算符</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\emptyset</td><td style="text-align:center">$\emptyset$</td></tr><tr><td style="text-align:center">\in</td><td style="text-align:center">$\in$</td></tr><tr><td style="text-align:center">\notin</td><td style="text-align:center">$\notin$</td></tr><tr><td style="text-align:center">\subset</td><td style="text-align:center">$\subset$</td></tr><tr><td style="text-align:center">\supset</td><td style="text-align:center">$\supset$</td></tr><tr><td style="text-align:center">\subseteq</td><td style="text-align:center">$\subseteq$</td></tr><tr><td style="text-align:center">\supseteq</td><td style="text-align:center">$\supseteq$</td></tr><tr><td style="text-align:center">\bigcap</td><td style="text-align:center">$\bigcap$</td></tr><tr><td style="text-align:center">\bigcup</td><td style="text-align:center">$\bigcup$</td></tr><tr><td style="text-align:center">\bigvee</td><td style="text-align:center">$\bigvee$</td></tr><tr><td style="text-align:center">\bigwedge</td><td style="text-align:center">$\bigwedge$</td></tr><tr><td style="text-align:center">\biguplus</td><td style="text-align:center">$\biguplus$</td></tr><tr><td style="text-align:center">\bigsqcup</td><td style="text-align:center">$\bigsqcup$</td></tr></tbody></table><h2 id="对数运算符"><a href="#对数运算符" class="headerlink" title="对数运算符"></a>对数运算符</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\log</td><td style="text-align:center">$\log$</td></tr><tr><td style="text-align:center">\lg</td><td style="text-align:center">$\lg$</td></tr><tr><td style="text-align:center">\ln</td><td style="text-align:center">$\ln$</td></tr></tbody></table><h2 id="三角运算符"><a href="#三角运算符" class="headerlink" title="三角运算符"></a>三角运算符</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\bot</td><td style="text-align:center">$\bot$</td></tr><tr><td style="text-align:center">\angle</td><td style="text-align:center">$\angle$</td></tr><tr><td style="text-align:center">30^\circ</td><td style="text-align:center">$30^\circ$</td></tr><tr><td style="text-align:center">\sin</td><td style="text-align:center">$\sin$</td></tr><tr><td style="text-align:center">\cos</td><td style="text-align:center">$\cos$</td></tr><tr><td style="text-align:center">\tan</td><td style="text-align:center">$\tan$</td></tr><tr><td style="text-align:center">\cot</td><td style="text-align:center">$\cot$</td></tr><tr><td style="text-align:center">\sec</td><td style="text-align:center">$\sec$</td></tr><tr><td style="text-align:center">\csc</td><td style="text-align:center">$\csc$</td></tr></tbody></table><h2 id="微积分运算符"><a href="#微积分运算符" class="headerlink" title="微积分运算符"></a>微积分运算符</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\prime</td><td style="text-align:center">$\prime$</td></tr><tr><td style="text-align:center">\int</td><td style="text-align:center">$\int$</td></tr><tr><td style="text-align:center">\iint</td><td style="text-align:center">$\iint$</td></tr><tr><td style="text-align:center">\iiint</td><td style="text-align:center">$\iiint$</td></tr><tr><td style="text-align:center">\iiiint</td><td style="text-align:center">$\iiiint$</td></tr><tr><td style="text-align:center">\oint</td><td style="text-align:center">$\oint$</td></tr><tr><td style="text-align:center">\lim</td><td style="text-align:center">$\lim$</td></tr><tr><td style="text-align:center">\infty</td><td style="text-align:center">$\infty$</td></tr><tr><td style="text-align:center">\nabla</td><td style="text-align:center">$\nabla$</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\because</td><td style="text-align:center">$\because$</td></tr><tr><td style="text-align:center">\therefore</td><td style="text-align:center">$\therefore$</td></tr><tr><td style="text-align:center">\forall</td><td style="text-align:center">$\forall$</td></tr><tr><td style="text-align:center">\exists</td><td style="text-align:center">$\exists$</td></tr><tr><td style="text-align:center">\not=</td><td style="text-align:center">$\not=$</td></tr><tr><td style="text-align:center">\not&gt;</td><td style="text-align:center">$\not&gt;$</td></tr><tr><td style="text-align:center">\not\subset</td><td style="text-align:center">$\not\subset$</td></tr></tbody></table><h2 id="戴帽符号"><a href="#戴帽符号" class="headerlink" title="戴帽符号"></a>戴帽符号</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\hat{y}</td><td style="text-align:center">$\hat{y}$</td></tr><tr><td style="text-align:center">\check{y}</td><td style="text-align:center">$\check{y}$</td></tr><tr><td style="text-align:center">\breve{y}</td><td style="text-align:center">$\breve{y}$</td></tr></tbody></table><h2 id="连线符号"><a href="#连线符号" class="headerlink" title="连线符号"></a>连线符号</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\overline{a+b+c+d}</td><td style="text-align:center">$\overline{a+b+c+d}$</td></tr><tr><td style="text-align:center">\underline{a+b+c+d}</td><td style="text-align:center">$\underline{a+b+c+d}$</td></tr><tr><td style="text-align:center">\overbrace{a+b+c+d}</td><td style="text-align:center">$\overbrace{a+b+c+d}$</td></tr><tr><td style="text-align:center">\underbrace{a+b+c+d}</td><td style="text-align:center">$\underbrace{a+b+c+d}$</td></tr></tbody></table><h2 id="箭头符号"><a href="#箭头符号" class="headerlink" title="箭头符号"></a>箭头符号</h2><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">\uparrow</td><td style="text-align:center">$\uparrow$</td></tr><tr><td style="text-align:center">\downarrow</td><td style="text-align:center">$\downarrow$</td></tr><tr><td style="text-align:center">\Uparrow</td><td style="text-align:center">$\Uparrow$</td></tr><tr><td style="text-align:center">\Downarrow</td><td style="text-align:center">$\Downarrow$</td></tr><tr><td style="text-align:center">\rightarrow</td><td style="text-align:center">$\rightarrow$</td></tr><tr><td style="text-align:center">\leftarrow</td><td style="text-align:center">$\leftarrow$</td></tr><tr><td style="text-align:center">\Rightarrow</td><td style="text-align:center">$\Rightarrow$</td></tr><tr><td style="text-align:center">\Leftarrow</td><td style="text-align:center">$\Leftarrow$</td></tr><tr><td style="text-align:center">\longrightarrow</td><td style="text-align:center">$\longrightarrow$</td></tr><tr><td style="text-align:center">\longleftarrow</td><td style="text-align:center">$\longleftarrow$</td></tr><tr><td style="text-align:center">\Longrightarrow</td><td style="text-align:center">$\Longrightarrow$</td></tr><tr><td style="text-align:center">\Longleftarrow</td><td style="text-align:center">$\Longleftarrow$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「CF444C」 DZY Loves Colors 解题报告</title>
      <link href="/2019/03/24/CF444C-DZY-Loves-Colors-Solution/"/>
      <url>/2019/03/24/CF444C-DZY-Loves-Colors-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/CF444C" target="_blank" rel="noopener">题面</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>DZY喜欢色彩，他热爱绘画。</p><p>在一个多姿多彩的日子里，$DZY$得到了一个彩色的缎带，它由$N$个单元组成（从左到右从$1$到$n$编号）。色带的第$i$个单位的最初颜色是$i$。虽然颜色足够丰富，但我们仍然认为每个单元的颜色数量最初是$0$。</p><p>我们知道$DZY$热衷于绘画。他拿起一把彩色笔，用它在缎带上画一条线。在这种情况下，他就绘制了一段连续的单元。想象一下，单位$i$被涂之前颜色是$y$。被涂之后时，单元的颜色变为$x$，令单位的颜色增加了$|x-y|$。 $DZY$想要执行$M$个操作，每个操作可以是下列操作之一：</p><p>1、将区间$[L,R]$内单元绘制为颜色$x$。</p><p>2、询问$[L,R]$之间的单位颜色的总和（包括两者）。</p><p>你能帮助$DZY$吗？</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><p>第一行包含用空格隔开的整数$n,m$（$1 \leq n\leq m \leq 10^5$）。</p><p>接下来$m$行中的每一行都以一个整数开头（$1\leq tyqe \leq 2$）开始，表示该操作的类型。</p><p>如果$type = 1$，则在该行中，有$3$个整数$L,R,x(1 \leq L \leq R \leq n; 1\leq x \leq 10^8)$，表示操作$1$。</p><p>如果$type=2$，则这一行，有$2$个整数$L,R,(1 \leq L \leq R \leq n)$，表示操作$2$。</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><p>对于每个操作$2$，输出一行，包含着色数量的和。</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这是一个<strong>区间覆盖</strong>的题，<del>不经过思考</del>就想到了$Old\ Driver\ Tree$，然后配合着<strong>线段树</strong>，就用数据结构过去了qaq</p><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p><del>O(玄学)</del>最坏的查询是$log$级的，显然不是影响时间复杂度关键，假设所有都是修改操作，修改绝大多数的时候都是使原本$n$个点变少的，最坏的情况应该是把同一个区间分裂成三个不同的区间，也就是每次把三个连在一起，再把一个区间分开三个，似乎复杂度也不会很高，最多三倍，加上$lower_bound$的$log$和线段树的$log$，时间复杂度$O(能过)$，<del>结束，cheer</del></p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> It set<span class="meta-string">&lt;node&gt;::iterator </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="comment">//用于ODT</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> val;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b=<span class="number">-1</span>,<span class="keyword">int</span> c=<span class="number">0</span>):l(a),r(b),val(c)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node x) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,T,L,R,val,y;</span><br><span class="line">ll f[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>],ans;<span class="comment">//线段树，别忘了开ll</span></span><br><span class="line"><span class="built_in">set</span>&lt;node&gt;s;</span><br><span class="line">It Itl,Itr,it;<span class="comment">//迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">It <span class="title">Split</span><span class="params">(<span class="keyword">int</span> pos)</span><span class="comment">//分离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">it=s.lower_bound(node(pos));</span><br><span class="line"><span class="keyword">if</span>(it!=s.end() &amp;&amp; it-&gt;l ==pos) <span class="keyword">return</span> it;</span><br><span class="line">--it;</span><br><span class="line"><span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r,val=it-&gt;val;</span><br><span class="line">s.erase(it);</span><br><span class="line">s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line"><span class="keyword">return</span> s.insert(node(pos,r,val)).first;<span class="comment">//返回的是pair类型，第一段关键字是插入位置的迭代器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[k]+=tag[k]*(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(l!=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">tag[cur]+=tag[k];</span><br><span class="line">tag[cur|<span class="number">1</span>]+=tag[k];</span><br><span class="line">&#125;</span><br><span class="line">tag[k]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[k]) push(k,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&lt;L||R&lt;l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line">tag[k]=y;</span><br><span class="line">push(k,l,r);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">Modify(cur,l,mid);</span><br><span class="line">Modify(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">f[k]=f[cur]+f[cur|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cov</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Itr=Split(r+<span class="number">1</span>);it=Itl=Split(l);</span><br><span class="line"><span class="keyword">for</span>(;it!=Itr;++it)</span><br><span class="line">&#123;</span><br><span class="line">L=it-&gt;l;R=it-&gt;r;y=<span class="built_in">abs</span>(val- it-&gt;val);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line">s.erase(Itl,Itr);</span><br><span class="line">s.insert(node(l,r,val));<span class="comment">//记得这里要重新插入过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[k]) push(k,l,r);</span><br><span class="line"><span class="keyword">if</span>(r&lt;L||R&lt;l) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;ans+=f[k];<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,cur=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">Query(cur,l,mid);</span><br><span class="line">Query(cur|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">n=read();T=read();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">s.insert(node(i,i,i));</span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(read()==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">L=read(),R=read(),val=read();</span><br><span class="line">Cov(L,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans=<span class="number">0</span>,L=read(),R=read(),Query(<span class="number">1</span>,<span class="number">1</span>,n),<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ODT </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「UVA1328」Period 解题报告</title>
      <link href="/2019/03/11/UVA1328-Period-Solution/"/>
      <url>/2019/03/11/UVA1328-Period-Solution/</url>
      
        <content type="html"><![CDATA[<h2 id="English题面"><a href="#English题面" class="headerlink" title="English题面"></a><a href="https://uva.onlinejudge.org/external/13/p1328.pdf" target="_blank" rel="noopener">English题面</a></h2><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>给你一个长度为n的字符串，依次取字符串前i个（前缀），如果前缀由k(k&gt;0)个相同真子串构成，那么输出i和k</p><p>直到n为0结束，每组数据后要有一行空白</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="KMP-一点点判断"><a href="#KMP-一点点判断" class="headerlink" title="KMP+一点点判断"></a>KMP+一点点判断</h3><p>其实这道题并不是很难</p><p>可以先用<strong>KMP</strong>求出<strong>最长的</strong> 是<strong>s[1~i]</strong>的前缀和后缀的<strong>真子串</strong>的长度<strong>j</strong></p><p>话说的有点复杂，分开来理</p><h4 id="1、真子串："><a href="#1、真子串：" class="headerlink" title="1、真子串："></a>1、真子串：</h4><p>不是字符串本身的子串</p><h4 id="2、是s-1-i-的前缀和后缀："><a href="#2、是s-1-i-的前缀和后缀：" class="headerlink" title="2、是s[1~i]的前缀和后缀："></a>2、是<strong>s[1~i]</strong>的前缀和后缀：</h4><p>以<strong>aabaab</strong>为例</p><blockquote><p><strong>aab</strong>aab</p><p>aab<strong>aab</strong></p><p><strong>aab</strong>是aabaab的前缀，又是后缀</p><p>j=3</p></blockquote><h4 id="两种条件下："><a href="#两种条件下：" class="headerlink" title="两种条件下："></a>两种条件下：</h4><p>以aaa为例</p><p>就应该是</p><blockquote><p><strong>aa</strong>a</p><p>a<strong>aa</strong></p><p><strong>aa</strong>是aaa的前缀&amp;后缀&amp;真子串</p><p>j=2</p></blockquote><h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><blockquote><p>if(i%(i-j)==0) //说明循环的子串长度为<code>i-j</code>，循环次数为<code>i/(i-j)</code></p></blockquote><h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p><img src="https://www.cnblogs.com/images/cnblogs_com/hovny/1364959/o_]ZX}_CBJQLSA_1$FNGBS]W5.png" alt></p><blockquote><p>RT：</p><p>$\because$ l=r</p><p>$\therefore$ ①=①，②=②，③=③</p><p>$\therefore$ ①=②=③</p><p>其他情况无论多少都可以这样 <strong>连等</strong>，只要i-j能够整除i那么就是成立的</p></blockquote><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> len,cur;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">c=getchar();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">s=(s&lt;&lt;<span class="number">1</span>)+(s&lt;&lt;<span class="number">3</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Test case #%d\n"</span>,++t);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">len=s.size();</span><br><span class="line"><span class="keyword">for</span>(i=len;i;i--)</span><br><span class="line">s[i]=s[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=len;i++)<span class="comment">//KMP大法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>])<span class="comment">//求前缀的那个东东</span></span><br><span class="line">j=p[j];</span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>])</span><br><span class="line">j++;</span><br><span class="line">p[i]=j;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=(i&gt;&gt;<span class="number">1</span>)&amp;&amp;i%(i-j)==<span class="number">0</span>)<span class="comment">//判断一下</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,i/(i-j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">n=read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h3><p><a href="https://baike.baidu.com/item/kmp%E7%AE%97%E6%B3%95/10951804?fr=aladdin" target="_blank" rel="noopener">KMP百度百科</a></p><p><a href="https://www.luogu.org/problemnew/show/P3375" target="_blank" rel="noopener">【模板】KMP字符串匹配</a></p>]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「网络流挖坑大全」最大流最小割 错误点记录</title>
      <link href="/2018/12/27/Maxflow-Mistakes/"/>
      <url>/2018/12/27/Maxflow-Mistakes/</url>
      
        <content type="html"><![CDATA[<h2 id="2018年12月27日-天气：阴-心情：一般"><a href="#2018年12月27日-天气：阴-心情：一般" class="headerlink" title="2018年12月27日     天气：阴        心情：一般"></a>2018年12月27日     天气：阴        心情：一般</h2><p>because!——<del>学网络流第二、三道题就WA，查错花了INF的时间</del></p><p>今天作为学习网络流的第二天，本人决定潜心<del>研究</del>记录网络流的错题</p><p>顺便补上昨天的错题</p><h2 id="Ⅰ、炸点优化对象炸弄错了"><a href="#Ⅰ、炸点优化对象炸弄错了" class="headerlink" title="Ⅰ、炸点优化对象炸弄错了"></a>Ⅰ、炸点优化对象<del>炸</del>弄错了</h2><h3 id="BJOI2006-狼抓兔子"><a href="#BJOI2006-狼抓兔子" class="headerlink" title="[BJOI2006]狼抓兔子"></a><a href="https://www.luogu.org/problemnew/show/P4001" target="_blank" rel="noopener">[BJOI2006]狼抓兔子</a></h3><h3 id="WA-Code："><a href="#WA-Code：" class="headerlink" title="WA Code："></a>WA Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==T)</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> i,to,cap,res,rest=flow;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i&amp;&amp;rest;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;deep[to]==deep[k]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=Dinic(to,min(rest,cap));</span><br><span class="line"><span class="keyword">if</span>(!res)</span><br><span class="line">deep[res]=<span class="number">0</span>;<span class="comment">//它错在这里！！！炸点炸的应该是to不是res！</span></span><br><span class="line">b[i].cap-=res;</span><br><span class="line">b[i^<span class="number">1</span>].cap+=res;</span><br><span class="line">rest-=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC-Code："><a href="#AC-Code：" class="headerlink" title="AC  Code："></a>AC  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==T)</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> i,to,cap,res,rest=flow;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i&amp;&amp;rest;i=b[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;deep[to]==deep[k]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=Dinic(to,min(rest,cap));</span><br><span class="line"><span class="keyword">if</span>(!res)</span><br><span class="line">deep[to]=<span class="number">0</span>;<span class="comment">//就是这里！哼~不高兴!</span></span><br><span class="line">b[i].cap-=res;</span><br><span class="line">b[i^<span class="number">1</span>].cap+=res;</span><br><span class="line">rest-=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ、建边没看方向-眼睛呢！"><a href="#Ⅱ、建边没看方向-眼睛呢！" class="headerlink" title="Ⅱ、建边没看方向  眼睛呢！"></a>Ⅱ、建边没看方向  <del>眼睛呢！</del></h2><h3 id="BJOI2006-狼抓兔子-1"><a href="#BJOI2006-狼抓兔子-1" class="headerlink" title="[BJOI2006]狼抓兔子"></a><a href="https://www.luogu.org/problemnew/show/P4001" target="_blank" rel="noopener">[BJOI2006]狼抓兔子</a></h3><h3 id="WA-Code：-1"><a href="#WA-Code：-1" class="headerlink" title="WA  Code："></a>WA  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cap=read();</span><br><span class="line">add(TtO(i,j),TtO(i,j+<span class="number">1</span>),cap);<span class="comment">//这里！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cap=read();</span><br><span class="line">add(TtO(i,j),TtO(i+<span class="number">1</span>,j),cap);<span class="comment">//这里！！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cap=read();</span><br><span class="line">add(TtO(i,j),TtO(i+<span class="number">1</span>,j+<span class="number">1</span>),cap);<span class="comment">//还有这里！！！</span></span><br><span class="line">&#125;<span class="comment">//别看了，我码量大~</span></span><br></pre></td></tr></table></figure><h3 id="AC-Code：-1"><a href="#AC-Code：-1" class="headerlink" title="AC  Code："></a>AC  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cap=read();</span><br><span class="line">add(TtO(i,j),TtO(i,j+<span class="number">1</span>),cap);</span><br><span class="line">add(TtO(i,j+<span class="number">1</span>),TtO(i,j),cap);<span class="comment">//这样就对了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cap=read();</span><br><span class="line">add(TtO(i,j),TtO(i+<span class="number">1</span>,j),cap);</span><br><span class="line">add(TtO(i+<span class="number">1</span>,j),TtO(i,j),cap);<span class="comment">//嗯，就是这样</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cap=read();</span><br><span class="line">add(TtO(i,j),TtO(i+<span class="number">1</span>,j+<span class="number">1</span>),cap);</span><br><span class="line">add(TtO(i+<span class="number">1</span>,j+<span class="number">1</span>),TtO(i,j),cap);<span class="comment">//不错，这样很Nice</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过<a href="https://www.cnblogs.com/louhancheng/p/10183073.html" target="_blank" rel="noopener">这位大佬</a>想出了省一半空间的方法<del>瑟瑟发抖</del></p><p><del>这个事情告诉我们：珍惜时间，好好看题</del></p><h2 id="Ⅲ、边的方向弄错"><a href="#Ⅲ、边的方向弄错" class="headerlink" title="Ⅲ、边的方向弄错"></a>Ⅲ、边的方向弄错</h2><h3 id="CQOI2009-跳舞"><a href="#CQOI2009-跳舞" class="headerlink" title="[CQOI2009]跳舞"></a><a href="https://www.luogu.org/problemnew/show/P3153" target="_blank" rel="noopener">[CQOI2009]跳舞</a></h3><h3 id="WA-Code：-2"><a href="#WA-Code：-2" class="headerlink" title="WA  Code："></a>WA  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)<span class="comment">//偷懒而已……</span></span><br><span class="line">&#123;</span><br><span class="line">add(i,i+(n&lt;&lt;<span class="number">1</span>),n);</span><br><span class="line">add(i,i+(n&lt;&lt;<span class="number">2</span>),k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC-Code：-2"><a href="#AC-Code：-2" class="headerlink" title="AC Code："></a>AC Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">add(i,i+(n&lt;&lt;<span class="number">1</span>),n);</span><br><span class="line">add(i,i+(n&lt;&lt;<span class="number">2</span>),k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=n+<span class="number">1</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)<span class="comment">//反过来就对了！</span></span><br><span class="line">&#123;</span><br><span class="line">add(i+(n&lt;&lt;<span class="number">1</span>),i,n);</span><br><span class="line">add(i+(n&lt;&lt;<span class="number">2</span>),i,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>这个事情告诉我们：年轻人切莫偷懒</del></p><h2 id="Ⅳ、遍历边的时候写错"><a href="#Ⅳ、遍历边的时候写错" class="headerlink" title="Ⅳ、遍历边的时候写错"></a>Ⅳ、遍历边的时候写错</h2><h3 id="CQOI2009-跳舞-1"><a href="#CQOI2009-跳舞-1" class="headerlink" title="[CQOI2009]跳舞"></a><a href="https://www.luogu.org/problemnew/show/P3153" target="_blank" rel="noopener">[CQOI2009]跳舞</a></h3><h3 id="WA-Code：-3"><a href="#WA-Code：-3" class="headerlink" title="WA  Code："></a>WA  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==T)</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> i,to,cap,res,rest=flow;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i&amp;&amp;rest;i=b[i].to)<span class="comment">//厉害吧~</span></span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;deep[to]==deep[k]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=Dinic(to,min(rest,cap));</span><br><span class="line"><span class="keyword">if</span>(!res)</span><br><span class="line">deep[to]=<span class="number">0</span>;</span><br><span class="line">b[i].cap-=res;</span><br><span class="line">b[i^<span class="number">1</span>].cap+=res;</span><br><span class="line">rest-=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC-Code：-3"><a href="#AC-Code：-3" class="headerlink" title="AC  Code："></a>AC  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==T)</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> i,to,cap,res,rest=flow;</span><br><span class="line"><span class="keyword">for</span>(i=head[k];i&amp;&amp;rest;i=b[i].nxt)<span class="comment">//这样才对嘛！众人：智障！</span></span><br><span class="line">&#123;</span><br><span class="line">to=b[i].to;cap=b[i].cap;</span><br><span class="line"><span class="keyword">if</span>(cap&amp;&amp;deep[to]==deep[k]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=Dinic(to,min(rest,cap));</span><br><span class="line"><span class="keyword">if</span>(!res)</span><br><span class="line">deep[to]=<span class="number">0</span>;</span><br><span class="line">b[i].cap-=res;</span><br><span class="line">b[i^<span class="number">1</span>].cap+=res;</span><br><span class="line">rest-=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow-rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="13-04，这是今天第二次，查错查了半天，我才学了两天啊！"><a href="#13-04，这是今天第二次，查错查了半天，我才学了两天啊！" class="headerlink" title="13:04，这是今天第二次，查错查了半天，我才学了两天啊！"></a><del>13:04，这是今天第二次，查错查了半天，我才学了两天啊！</del></h2><h2 id="Ⅴ、汇点变量T混用"><a href="#Ⅴ、汇点变量T混用" class="headerlink" title="Ⅴ、汇点变量T混用"></a>Ⅴ、汇点变量T混用</h2><h3 id="教辅的组成"><a href="#教辅的组成" class="headerlink" title="教辅的组成"></a><a href="https://www.luogu.org/problemnew/show/P1231" target="_blank" rel="noopener">教辅的组成</a></h3><h3 id="WA-Code：-4"><a href="#WA-Code：-4" class="headerlink" title="WA  Code："></a>WA  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">S=n1+n1+n2+n3+<span class="number">1</span>;T=n1+n1+n2+n3+<span class="number">2</span>;<span class="comment">//T是汇点~</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n3;i++)</span><br><span class="line">add(S,i+n1+n2,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n2;i++)</span><br><span class="line">add(i+n1,T,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n1;i++)</span><br><span class="line">add(i+n1+n2+n3,i,<span class="number">1</span>);</span><br><span class="line">T=read();<span class="comment">//T记录边数……黑脸</span></span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read()+n1;</span><br><span class="line">add(x,y,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">T=read();<span class="comment">//还有这里……居然！吐血</span></span><br><span class="line"><span class="keyword">while</span>(T--)</span><br><span class="line">&#123;</span><br><span class="line">x=read()+n1+n2+n3;y=read()+n1+n2;</span><br><span class="line">add(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC-Code：-4"><a href="#AC-Code：-4" class="headerlink" title="AC Code："></a>AC Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">S=n1+n1+n2+n3+<span class="number">1</span>;T=n1+n1+n2+n3+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n3;i++)</span><br><span class="line">add(S,i+n1+n2,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n2;i++)</span><br><span class="line">add(i+n1,T,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n1;i++)</span><br><span class="line">add(i+n1+n2+n3,i,<span class="number">1</span>);</span><br><span class="line">m=read();<span class="comment">//换个变量就行了……</span></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">x=read();y=read()+n1;</span><br><span class="line">add(x,y,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">m=read();<span class="comment">//我肯定是傻了……</span></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">x=read()+n1+n2+n3;y=read()+n1+n2;</span><br><span class="line">add(y,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅵ、边的数组范围开小"><a href="#Ⅵ、边的数组范围开小" class="headerlink" title="Ⅵ、边的数组范围开小"></a>Ⅵ、边的数组范围开小</h2><h3 id="教辅的组成-1"><a href="#教辅的组成-1" class="headerlink" title="教辅的组成"></a><a href="https://www.luogu.org/problemnew/show/P1231" target="_blank" rel="noopener">教辅的组成</a></h3><h3 id="WA-Code：-5"><a href="#WA-Code：-5" class="headerlink" title="WA Code："></a>WA Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 50010<span class="comment">//少了20000！</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="keyword">int</span> nxt;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cap(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="AC-Code：-5"><a href="#AC-Code：-5" class="headerlink" title="AC  Code："></a>AC  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 70010<span class="comment">//看来真的要多加一个zero才行！</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,cap;</span><br><span class="line"><span class="keyword">int</span> nxt;</span><br><span class="line">node(<span class="keyword">int</span> a,<span class="keyword">int</span> b):to(a),cap(b)&#123;&#125;</span><br><span class="line">node()&#123;&#125;</span><br><span class="line">&#125;b[M&lt;&lt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure><hr><h2 id="13-53-今天第三次-Orz网络流"><a href="#13-53-今天第三次-Orz网络流" class="headerlink" title="13:53  今天第三次  Orz网络流"></a>13:53  今天第三次  Orz网络流</h2><h2 id="Ⅶ、建边交错混杂弄反-h-ovny：-amp-？！"><a href="#Ⅶ、建边交错混杂弄反-h-ovny：-amp-？！" class="headerlink" title="Ⅶ、建边交错混杂弄反  h^ovny：@#%&amp;？！"></a>Ⅶ、建边交错混杂弄反  <del>h^ovny：@#%&amp;？！</del></h2><h3 id="USACO07OPEN-吃饭Dining"><a href="#USACO07OPEN-吃饭Dining" class="headerlink" title="[USACO07OPEN]吃饭Dining"></a><a href="https://www.luogu.org/problemnew/show/P2891" target="_blank" rel="noopener">[USACO07OPEN]吃饭Dining</a></h3><h3 id="WA-Code：-6"><a href="#WA-Code：-6" class="headerlink" title="WA  Code："></a>WA  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=F;i++)<span class="comment">//看出来哪里错了吗？</span></span><br><span class="line">add(S,n+i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=D;i++)<span class="comment">//混杂弄反emmm</span></span><br><span class="line">add(n+F+i,T,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//边弄反</span></span><br><span class="line">add(i,n+F+D+i,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="AC-Code：-6"><a href="#AC-Code：-6" class="headerlink" title="AC  Code："></a>AC  Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=D;i++)<span class="comment">//这才是正解嘛！</span></span><br><span class="line">add(S,n+F+i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=F;i++)</span><br><span class="line">add(n+i,T,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">add(n+F+D+i,i,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>h^ovny：脑白金？！</p>]]></content>
      
      
      <categories>
          
          <category> 错误点记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
